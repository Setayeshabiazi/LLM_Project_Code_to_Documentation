{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/pdf_text_diff.py", "func_name": "main", "whole_func_string": "def main(\n    pdf1: Annotated[typer.FileBinaryRead, typer.Argument()],\n    pdf2: Annotated[typer.FileBinaryRead, typer.Argument()],\n    engine: Annotated[str, typer.Option()] = 'pdftotext',\n):\n                               \n\n    text1 = run(\n        ['pdftotext', '-layout', '-', '-'], stdin=pdf1, capture_output=True, check=True\n    )\n    text2 = run(\n        ['pdftotext', '-layout', '-', '-'], stdin=pdf2, capture_output=True, check=True\n    )\n\n    with NamedTemporaryFile() as f1, NamedTemporaryFile() as f2:\n        f1.write(text1.stdout)\n        f1.flush()\n        f2.write(text2.stdout)\n        f2.flush()\n        diff = run(\n            ['diff', '--color=always', '--side-by-side', f1.name, f2.name],\n            capture_output=True,\n        )\n        run(['less', '-R'], input=diff.stdout, check=True)\n        if text1.stdout.strip() != text2.stdout.strip():\n            return 1\n\n    return 0", "func_code_string": "def main(\n    pdf1: Annotated[typer.FileBinaryRead, typer.Argument()],\n    pdf2: Annotated[typer.FileBinaryRead, typer.Argument()],\n    engine: Annotated[str, typer.Option()] = 'pdftotext',\n):\n                               \n\n    text1 = run(\n        ['pdftotext', '-layout', '-', '-'], stdin=pdf1, capture_output=True, check=True\n    )\n    text2 = run(\n        ['pdftotext', '-layout', '-', '-'], stdin=pdf2, capture_output=True, check=True\n    )\n\n    with NamedTemporaryFile() as f1, NamedTemporaryFile() as f2:\n        f1.write(text1.stdout)\n        f1.flush()\n        f2.write(text2.stdout)\n        f2.flush()\n        diff = run(\n            ['diff', '--color=always', '--side-by-side', f1.name, f2.name],\n            capture_output=True,\n        )\n        run(['less', '-R'], input=diff.stdout, check=True)\n        if text1.stdout.strip() != text2.stdout.strip():\n            return 1\n\n    return 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/batch.py", "func_name": "filecompare", "whole_func_string": "def filecompare(a, b):\n    try:\n        return filecmp.cmp(a, b, shallow=True)\n    except FileNotFoundError:\n        return False", "func_code_string": "def filecompare(a, b):\n    try:\n        return filecmp.cmp(a, b, shallow=True)\n    except FileNotFoundError:\n        return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/example_plugin.py", "func_name": "add_options", "whole_func_string": "def add_options(parser):\n    parser.add_argument('--grayscale-ocr', action='store_true')\n    parser.add_argument('--mono-page', action='store_true')", "func_code_string": "def add_options(parser):\n    parser.add_argument('--grayscale-ocr', action='store_true')\n    parser.add_argument('--mono-page', action='store_true')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/example_plugin.py", "func_name": "prepare", "whole_func_string": "def prepare(options):\n    pass", "func_code_string": "def prepare(options):\n    pass", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/example_plugin.py", "func_name": "validate", "whole_func_string": "def validate(pdfinfo, options):\n    pass", "func_code_string": "def validate(pdfinfo, options):\n    pass", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/example_plugin.py", "func_name": "filter_ocr_image", "whole_func_string": "def filter_ocr_image(page, image):\n    if page.options.grayscale_ocr:\n        log.info(\"graying\")\n        return image.convert('L')\n    return image", "func_code_string": "def filter_ocr_image(page, image):\n    if page.options.grayscale_ocr:\n        log.info(\"graying\")\n        return image.convert('L')\n    return image", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/example_plugin.py", "func_name": "filter_page_image", "whole_func_string": "def filter_page_image(page, image_filename):\n    if page.options.mono_page:\n        with Image.open(image_filename) as im:\n            im = im.convert('1')\n            im.save(image_filename)\n        return image_filename\n    else:\n        output = image_filename.with_suffix('.jpg')\n        with Image.open(image_filename) as im:\n            im.save(output)\n        return output", "func_code_string": "def filter_page_image(page, image_filename):\n    if page.options.mono_page:\n        with Image.open(image_filename) as im:\n            im = im.convert('1')\n            im.save(image_filename)\n        return image_filename\n    else:\n        output = image_filename.with_suffix('.jpg')\n        with Image.open(image_filename) as im:\n            im.save(output)\n        return output", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/pdf_compare.py", "func_name": "do_metadata", "whole_func_string": "def do_metadata(pdf):\n    with pikepdf.open(pdf) as pdf:\n        with pdf.open_metadata() as meta:\n            xml_txt = str(meta)\n            parser = etree.XMLParser(remove_blank_text=True)\n            tree = etree.fromstring(xml_txt, parser=parser)\n            st.code(\n                etree.tostring(tree, pretty_print=True).decode(\"utf-8\"),\n                language=\"xml\",\n            )\n        st.write(pdf.docinfo)\n        st.write(\"Number of pages:\", len(pdf.pages))", "func_code_string": "def do_metadata(pdf):\n    with pikepdf.open(pdf) as pdf:\n        with pdf.open_metadata() as meta:\n            xml_txt = str(meta)\n            parser = etree.XMLParser(remove_blank_text=True)\n            tree = etree.fromstring(xml_txt, parser=parser)\n            st.code(\n                etree.tostring(tree, pretty_print=True).decode(\"utf-8\"),\n                language=\"xml\",\n            )\n        st.write(pdf.docinfo)\n        st.write(\"Number of pages:\", len(pdf.pages))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/pdf_compare.py", "func_name": "main", "whole_func_string": "def main():\n    st.set_page_config(layout=\"wide\")\n\n    st.title(\"PDF Compare\")\n    st.write(\"Compare two PDFs.\")\n\n    col1, col2 = st.columns(2)\n    with col1:\n        uploaded_pdf1 = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"], key='pdf1')\n    with col2:\n        uploaded_pdf2 = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"], key='pdf2')\n    if uploaded_pdf1 is None or uploaded_pdf2 is None:\n        return\n\n    pdf_bytes1 = uploaded_pdf1.getvalue()\n    pdf_bytes2 = uploaded_pdf2.getvalue()\n\n    with st.expander(\"PDF Metadata\"):\n        col1, col2 = st.columns(2)\n        with col1:\n            do_metadata(BytesIO(pdf_bytes1))\n        with col2:\n            do_metadata(BytesIO(pdf_bytes2))\n\n    with TemporaryDirectory() as d:\n        Path(d, \"1.pdf\").write_bytes(pdf_bytes1)\n        Path(d, \"2.pdf\").write_bytes(pdf_bytes2)\n\n        with st.expander(\"Text\"):\n            doc1 = pymupdf.open(os.path.join(d, \"1.pdf\"))\n            doc2 = pymupdf.open(os.path.join(d, \"2.pdf\"))\n            for i, page1_2 in enumerate(zip(doc1, doc2)):\n                st.write(f\"Page {i+1}\")\n                page1, page2 = page1_2\n                col1, col2 = st.columns(2)\n                with col1, st.container(border=True):\n                    st.write(page1.get_text())\n                with col2, st.container(border=True):\n                    st.write(page2.get_text())\n\n        with st.expander(\"PDF Viewer\"):\n            col1, col2 = st.columns(2)\n            with col1:\n                pdf_viewer(Path(d, \"1.pdf\"), key='pdf_viewer1', render_text=True)\n            with col2:\n                pdf_viewer(Path(d, \"2.pdf\"), key='pdf_viewer2', render_text=True)", "func_code_string": "def main():\n    st.set_page_config(layout=\"wide\")\n\n    st.title(\"PDF Compare\")\n    st.write(\"Compare two PDFs.\")\n\n    col1, col2 = st.columns(2)\n    with col1:\n        uploaded_pdf1 = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"], key='pdf1')\n    with col2:\n        uploaded_pdf2 = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"], key='pdf2')\n    if uploaded_pdf1 is None or uploaded_pdf2 is None:\n        return\n\n    pdf_bytes1 = uploaded_pdf1.getvalue()\n    pdf_bytes2 = uploaded_pdf2.getvalue()\n\n    with st.expander(\"PDF Metadata\"):\n        col1, col2 = st.columns(2)\n        with col1:\n            do_metadata(BytesIO(pdf_bytes1))\n        with col2:\n            do_metadata(BytesIO(pdf_bytes2))\n\n    with TemporaryDirectory() as d:\n        Path(d, \"1.pdf\").write_bytes(pdf_bytes1)\n        Path(d, \"2.pdf\").write_bytes(pdf_bytes2)\n\n        with st.expander(\"Text\"):\n            doc1 = pymupdf.open(os.path.join(d, \"1.pdf\"))\n            doc2 = pymupdf.open(os.path.join(d, \"2.pdf\"))\n            for i, page1_2 in enumerate(zip(doc1, doc2)):\n                st.write(f\"Page {i+1}\")\n                page1, page2 = page1_2\n                col1, col2 = st.columns(2)\n                with col1, st.container(border=True):\n                    st.write(page1.get_text())\n                with col2, st.container(border=True):\n                    st.write(page2.get_text())\n\n        with st.expander(\"PDF Viewer\"):\n            col1, col2 = st.columns(2)\n            with col1:\n                pdf_viewer(Path(d, \"1.pdf\"), key='pdf_viewer1', render_text=True)\n            with col2:\n                pdf_viewer(Path(d, \"2.pdf\"), key='pdf_viewer2', render_text=True)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "LoggingLevelEnum", "whole_func_string": "class LoggingLevelEnum(str, Enum):\n                                  \n\n    DEBUG = \"DEBUG\"\n    INFO = \"INFO\"\n    WARNING = \"WARNING\"\n    ERROR = \"ERROR\"\n    CRITICAL = \"CRITICAL\"", "func_code_string": "class LoggingLevelEnum(str, Enum):\n                                  \n\n    DEBUG = \"DEBUG\"\n    INFO = \"INFO\"\n    WARNING = \"WARNING\"\n    ERROR = \"ERROR\"\n    CRITICAL = \"CRITICAL\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "get_output_path", "whole_func_string": "def get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\n    assert '/' not in basename, \"basename must not contain '/'\"\n    if output_dir_year_month:\n        today = datetime.today()\n        output_directory_year_month = root / str(today.year) / f'{today.month:02d}'\n        if not output_directory_year_month.exists():\n            output_directory_year_month.mkdir(parents=True, exist_ok=True)\n        output_path = Path(output_directory_year_month) / Path(basename).with_suffix(\n            '.pdf'\n        )\n    else:\n        output_path = root / Path(basename).with_suffix('.pdf')\n    return output_path", "func_code_string": "def get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\n    assert '/' not in basename, \"basename must not contain '/'\"\n    if output_dir_year_month:\n        today = datetime.today()\n        output_directory_year_month = root / str(today.year) / f'{today.month:02d}'\n        if not output_directory_year_month.exists():\n            output_directory_year_month.mkdir(parents=True, exist_ok=True)\n        output_path = Path(output_directory_year_month) / Path(basename).with_suffix(\n            '.pdf'\n        )\n    else:\n        output_path = root / Path(basename).with_suffix('.pdf')\n    return output_path", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "wait_for_file_ready", "whole_func_string": "def wait_for_file_ready(\n    file_path: Path, poll_new_file_seconds: int, retries_loading_file: int\n):\n                                                                        \n                                                                       \n                                                                       \n                      \n\n    tries = retries_loading_file + 1\n    while tries:\n        try:\n            with pikepdf.Pdf.open(file_path) as pdf:\n                log.debug(f\"{file_path} ready with {pdf.pages} pages\")\n                return True\n        except (FileNotFoundError, OSError) as e:\n            log.info(f\"File {file_path} is not ready yet\")\n            log.debug(\"Exception was\", exc_info=e)\n            time.sleep(poll_new_file_seconds)\n            tries -= 1\n        except pikepdf.PdfError as e:\n            log.info(f\"File {file_path} is not full written yet\")\n            log.debug(\"Exception was\", exc_info=e)\n            time.sleep(poll_new_file_seconds)\n            tries -= 1\n\n    return False", "func_code_string": "def wait_for_file_ready(\n    file_path: Path, poll_new_file_seconds: int, retries_loading_file: int\n):\n                                                                        \n                                                                       \n                                                                       \n                      \n\n    tries = retries_loading_file + 1\n    while tries:\n        try:\n            with pikepdf.Pdf.open(file_path) as pdf:\n                log.debug(f\"{file_path} ready with {pdf.pages} pages\")\n                return True\n        except (FileNotFoundError, OSError) as e:\n            log.info(f\"File {file_path} is not ready yet\")\n            log.debug(\"Exception was\", exc_info=e)\n            time.sleep(poll_new_file_seconds)\n            tries -= 1\n        except pikepdf.PdfError as e:\n            log.info(f\"File {file_path} is not full written yet\")\n            log.debug(\"Exception was\", exc_info=e)\n            time.sleep(poll_new_file_seconds)\n            tries -= 1\n\n    return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "execute_ocrmypdf", "whole_func_string": "def execute_ocrmypdf(\n    *,\n    file_path: Path,\n    archive_dir: Path,\n    output_dir: Path,\n    ocrmypdf_kwargs: dict[str, Any],\n    on_success_delete: bool,\n    on_success_archive: bool,\n    poll_new_file_seconds: int,\n    retries_loading_file: int,\n    output_dir_year_month: bool,\n):\n    output_path = get_output_path(output_dir, file_path.name, output_dir_year_month)\n\n    log.info(\"-\" * 20)\n    log.info(f'New file: {file_path}. Waiting until fully written...')\n    if not wait_for_file_ready(file_path, poll_new_file_seconds, retries_loading_file):\n        log.info(f\"Gave up waiting for {file_path} to become ready\")\n        return\n    log.info(f'Attempting to OCRmyPDF to: {output_path}')\n\n    log.debug(\n        f'OCRmyPDF input_file={file_path} output_file={output_path} '\n        f'kwargs: {ocrmypdf_kwargs}'\n    )\n    exit_code = ocrmypdf.ocr(\n        input_file=file_path,\n        output_file=output_path,\n        **ocrmypdf_kwargs,\n    )\n    if exit_code == 0:\n        if on_success_delete:\n            log.info(f'OCR is done. Deleting: {file_path}')\n            file_path.unlink()\n        elif on_success_archive:\n            log.info(f'OCR is done. Archiving {file_path.name} to {archive_dir}')\n            shutil.move(file_path, f'{archive_dir}/{file_path.name}')\n        else:\n            log.info('OCR is done')\n    else:\n        log.info('OCR is done')", "func_code_string": "def execute_ocrmypdf(\n    *,\n    file_path: Path,\n    archive_dir: Path,\n    output_dir: Path,\n    ocrmypdf_kwargs: dict[str, Any],\n    on_success_delete: bool,\n    on_success_archive: bool,\n    poll_new_file_seconds: int,\n    retries_loading_file: int,\n    output_dir_year_month: bool,\n):\n    output_path = get_output_path(output_dir, file_path.name, output_dir_year_month)\n\n    log.info(\"-\" * 20)\n    log.info(f'New file: {file_path}. Waiting until fully written...')\n    if not wait_for_file_ready(file_path, poll_new_file_seconds, retries_loading_file):\n        log.info(f\"Gave up waiting for {file_path} to become ready\")\n        return\n    log.info(f'Attempting to OCRmyPDF to: {output_path}')\n\n    log.debug(\n        f'OCRmyPDF input_file={file_path} output_file={output_path} '\n        f'kwargs: {ocrmypdf_kwargs}'\n    )\n    exit_code = ocrmypdf.ocr(\n        input_file=file_path,\n        output_file=output_path,\n        **ocrmypdf_kwargs,\n    )\n    if exit_code == 0:\n        if on_success_delete:\n            log.info(f'OCR is done. Deleting: {file_path}')\n            file_path.unlink()\n        elif on_success_archive:\n            log.info(f'OCR is done. Archiving {file_path.name} to {archive_dir}')\n            shutil.move(file_path, f'{archive_dir}/{file_path.name}')\n        else:\n            log.info('OCR is done')\n    else:\n        log.info('OCR is done')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "HandleObserverEvent", "whole_func_string": "class HandleObserverEvent(PatternMatchingEventHandler):\n    def __init__(              \n        self,\n        patterns=None,\n        ignore_patterns=None,\n        ignore_directories=False,\n        case_sensitive=False,\n        settings={},\n    ):\n        super().__init__(\n            patterns=patterns,\n            ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories,\n            case_sensitive=case_sensitive,\n        )\n        self._settings = settings\n\n    def on_any_event(self, event):\n        if event.event_type in ['created']:\n            execute_ocrmypdf(file_path=Path(event.src_path), **self._settings)", "func_code_string": "class HandleObserverEvent(PatternMatchingEventHandler):\n    def __init__(              \n        self,\n        patterns=None,\n        ignore_patterns=None,\n        ignore_directories=False,\n        case_sensitive=False,\n        settings={},\n    ):\n        super().__init__(\n            patterns=patterns,\n            ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories,\n            case_sensitive=case_sensitive,\n        )\n        self._settings = settings\n\n    def on_any_event(self, event):\n        if event.event_type in ['created']:\n            execute_ocrmypdf(file_path=Path(event.src_path), **self._settings)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "main", "whole_func_string": "def main(\n    input_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_INPUT_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            readable=True,\n            resolve_path=True,\n        ),\n    ] = '/input',\n    output_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_OUTPUT_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n        ),\n    ] = '/output',\n    archive_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_ARCHIVE_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n        ),\n    ] = '/processed',\n    output_dir_year_month: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_OUTPUT_DIRECTORY_YEAR_MONTH',\n            help='Create a subdirectory in the output directory for each year/month',\n        ),\n    ] = False,\n    on_success_delete: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_ON_SUCCESS_DELETE',\n            help='Delete the input file after successful OCR',\n        ),\n    ] = False,\n    on_success_archive: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_ON_SUCCESS_ARCHIVE',\n            help='Archive the input file after successful OCR',\n        ),\n    ] = False,\n    deskew: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_DESKEW',\n            help='Deskew the input file before OCR',\n        ),\n    ] = False,\n    ocr_json_settings: Annotated[\n        str,\n        typer.Option(\n            envvar='OCR_JSON_SETTINGS',\n            help='JSON settings to pass to OCRmyPDF (JSON string or file path)',\n        ),\n    ] = None,\n    poll_new_file_seconds: Annotated[\n        int,\n        typer.Option(\n            envvar='OCR_POLL_NEW_FILE_SECONDS',\n            help='Seconds to wait before polling a new file',\n            min=0,\n        ),\n    ] = 1,\n    use_polling: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_USE_POLLING',\n            help='Use polling instead of filesystem events',\n        ),\n    ] = False,\n    retries_loading_file: Annotated[\n        int,\n        typer.Option(\n            envvar='OCR_RETRIES_LOADING_FILE',\n            help='Number of times to retry loading a file before giving up',\n            min=0,\n        ),\n    ] = 5,\n    loglevel: Annotated[\n        LoggingLevelEnum,\n        typer.Option(\n            envvar='OCR_LOGLEVEL',\n            help='Logging level',\n        ),\n    ] = LoggingLevelEnum.INFO,\n    patterns: Annotated[\n        str,\n        typer.Option(\n            envvar='OCR_PATTERNS',\n            help='File patterns to watch',\n        ),\n    ] = '*.pdf,*.PDF',\n):\n    ocrmypdf.configure_logging(\n        verbosity=(\n            ocrmypdf.Verbosity.default\n            if loglevel != LoggingLevelEnum.DEBUG\n            else ocrmypdf.Verbosity.debug\n        ),\n        manage_root_logger=True,\n    )\n    log.setLevel(loglevel.value)\n    log.info(\n        f\"Starting OCRmyPDF watcher with config:\\n\"\n        f\"Input Directory: {input_dir}\\n\"\n        f\"Output Directory: {output_dir}\\n\"\n        f\"Output Directory Year & Month: {output_dir_year_month}\\n\"\n        f\"Archive Directory: {archive_dir}\"\n    )\n    log.debug(\n        f\"INPUT_DIRECTORY: {input_dir}\\n\"\n        f\"OUTPUT_DIRECTORY: {output_dir}\\n\"\n        f\"OUTPUT_DIRECTORY_YEAR_MONTH: {output_dir_year_month}\\n\"\n        f\"ARCHIVE_DIRECTORY: {archive_dir}\\n\"\n        f\"ON_SUCCESS_DELETE: {on_success_delete}\\n\"\n        f\"ON_SUCCESS_ARCHIVE: {on_success_archive}\\n\"\n        f\"DESKEW: {deskew}\\n\"\n        f\"ARGS: {ocr_json_settings}\\n\"\n        f\"POLL_NEW_FILE_SECONDS: {poll_new_file_seconds}\\n\"\n        f\"RETRIES_LOADING_FILE: {retries_loading_file}\\n\"\n        f\"USE_POLLING: {use_polling}\\n\"\n        f\"LOGLEVEL: {loglevel.value}\"\n    )\n\n    if ocr_json_settings and Path(ocr_json_settings).exists():\n        json_settings = json.loads(Path(ocr_json_settings).read_text())\n    else:\n        json_settings = json.loads(ocr_json_settings or '{}')\n\n    if 'input_file' in json_settings or 'output_file' in json_settings:\n        log.error(\n            'OCR_JSON_SETTINGS (--ocr-json-settings) may not specify input/output file'\n        )\n        sys.exit(1)\n\n    handler = HandleObserverEvent(\n        patterns=patterns.split(','),\n        settings={\n            'archive_dir': archive_dir,\n            'output_dir': output_dir,\n            'ocrmypdf_kwargs': json_settings | {'deskew': deskew},\n            'on_success_delete': on_success_delete,\n            'on_success_archive': on_success_archive,\n            'poll_new_file_seconds': poll_new_file_seconds,\n            'retries_loading_file': retries_loading_file,\n            'output_dir_year_month': output_dir_year_month,\n        },\n    )\n    if use_polling:\n        observer = PollingObserver()\n    else:\n        observer = Observer()\n    observer.schedule(handler, input_dir, recursive=True)\n    observer.start()\n    typer.echo(f\"Watching {input_dir} for new PDFs. Press Ctrl+C to exit.\")\n    try:\n        while True:\n            time.sleep(30)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()", "func_code_string": "def main(\n    input_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_INPUT_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            readable=True,\n            resolve_path=True,\n        ),\n    ] = '/input',\n    output_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_OUTPUT_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n        ),\n    ] = '/output',\n    archive_dir: Annotated[\n        Path,\n        typer.Argument(\n            envvar='OCR_ARCHIVE_DIRECTORY',\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n        ),\n    ] = '/processed',\n    output_dir_year_month: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_OUTPUT_DIRECTORY_YEAR_MONTH',\n            help='Create a subdirectory in the output directory for each year/month',\n        ),\n    ] = False,\n    on_success_delete: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_ON_SUCCESS_DELETE',\n            help='Delete the input file after successful OCR',\n        ),\n    ] = False,\n    on_success_archive: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_ON_SUCCESS_ARCHIVE',\n            help='Archive the input file after successful OCR',\n        ),\n    ] = False,\n    deskew: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_DESKEW',\n            help='Deskew the input file before OCR',\n        ),\n    ] = False,\n    ocr_json_settings: Annotated[\n        str,\n        typer.Option(\n            envvar='OCR_JSON_SETTINGS',\n            help='JSON settings to pass to OCRmyPDF (JSON string or file path)',\n        ),\n    ] = None,\n    poll_new_file_seconds: Annotated[\n        int,\n        typer.Option(\n            envvar='OCR_POLL_NEW_FILE_SECONDS',\n            help='Seconds to wait before polling a new file',\n            min=0,\n        ),\n    ] = 1,\n    use_polling: Annotated[\n        bool,\n        typer.Option(\n            envvar='OCR_USE_POLLING',\n            help='Use polling instead of filesystem events',\n        ),\n    ] = False,\n    retries_loading_file: Annotated[\n        int,\n        typer.Option(\n            envvar='OCR_RETRIES_LOADING_FILE',\n            help='Number of times to retry loading a file before giving up',\n            min=0,\n        ),\n    ] = 5,\n    loglevel: Annotated[\n        LoggingLevelEnum,\n        typer.Option(\n            envvar='OCR_LOGLEVEL',\n            help='Logging level',\n        ),\n    ] = LoggingLevelEnum.INFO,\n    patterns: Annotated[\n        str,\n        typer.Option(\n            envvar='OCR_PATTERNS',\n            help='File patterns to watch',\n        ),\n    ] = '*.pdf,*.PDF',\n):\n    ocrmypdf.configure_logging(\n        verbosity=(\n            ocrmypdf.Verbosity.default\n            if loglevel != LoggingLevelEnum.DEBUG\n            else ocrmypdf.Verbosity.debug\n        ),\n        manage_root_logger=True,\n    )\n    log.setLevel(loglevel.value)\n    log.info(\n        f\"Starting OCRmyPDF watcher with config:\\n\"\n        f\"Input Directory: {input_dir}\\n\"\n        f\"Output Directory: {output_dir}\\n\"\n        f\"Output Directory Year & Month: {output_dir_year_month}\\n\"\n        f\"Archive Directory: {archive_dir}\"\n    )\n    log.debug(\n        f\"INPUT_DIRECTORY: {input_dir}\\n\"\n        f\"OUTPUT_DIRECTORY: {output_dir}\\n\"\n        f\"OUTPUT_DIRECTORY_YEAR_MONTH: {output_dir_year_month}\\n\"\n        f\"ARCHIVE_DIRECTORY: {archive_dir}\\n\"\n        f\"ON_SUCCESS_DELETE: {on_success_delete}\\n\"\n        f\"ON_SUCCESS_ARCHIVE: {on_success_archive}\\n\"\n        f\"DESKEW: {deskew}\\n\"\n        f\"ARGS: {ocr_json_settings}\\n\"\n        f\"POLL_NEW_FILE_SECONDS: {poll_new_file_seconds}\\n\"\n        f\"RETRIES_LOADING_FILE: {retries_loading_file}\\n\"\n        f\"USE_POLLING: {use_polling}\\n\"\n        f\"LOGLEVEL: {loglevel.value}\"\n    )\n\n    if ocr_json_settings and Path(ocr_json_settings).exists():\n        json_settings = json.loads(Path(ocr_json_settings).read_text())\n    else:\n        json_settings = json.loads(ocr_json_settings or '{}')\n\n    if 'input_file' in json_settings or 'output_file' in json_settings:\n        log.error(\n            'OCR_JSON_SETTINGS (--ocr-json-settings) may not specify input/output file'\n        )\n        sys.exit(1)\n\n    handler = HandleObserverEvent(\n        patterns=patterns.split(','),\n        settings={\n            'archive_dir': archive_dir,\n            'output_dir': output_dir,\n            'ocrmypdf_kwargs': json_settings | {'deskew': deskew},\n            'on_success_delete': on_success_delete,\n            'on_success_archive': on_success_archive,\n            'poll_new_file_seconds': poll_new_file_seconds,\n            'retries_loading_file': retries_loading_file,\n            'output_dir_year_month': output_dir_year_month,\n        },\n    )\n    if use_polling:\n        observer = PollingObserver()\n    else:\n        observer = Observer()\n    observer.schedule(handler, input_dir, recursive=True)\n    observer.start()\n    typer.echo(f\"Watching {input_dir} for new PDFs. Press Ctrl+C to exit.\")\n    try:\n        while True:\n            time.sleep(30)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "__init__", "whole_func_string": "def __init__(              \n        self,\n        patterns=None,\n        ignore_patterns=None,\n        ignore_directories=False,\n        case_sensitive=False,\n        settings={},\n    ):\n        super().__init__(\n            patterns=patterns,\n            ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories,\n            case_sensitive=case_sensitive,\n        )\n        self._settings = settings", "func_code_string": "def __init__(              \n        self,\n        patterns=None,\n        ignore_patterns=None,\n        ignore_directories=False,\n        case_sensitive=False,\n        settings={},\n    ):\n        super().__init__(\n            patterns=patterns,\n            ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories,\n            case_sensitive=case_sensitive,\n        )\n        self._settings = settings", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "on_any_event", "whole_func_string": "def on_any_event(self, event):\n        if event.event_type in ['created']:\n            execute_ocrmypdf(file_path=Path(event.src_path), **self._settings)", "func_code_string": "def on_any_event(self, event):\n        if event.event_type in ['created']:\n            execute_ocrmypdf(file_path=Path(event.src_path), **self._settings)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/_webservice.py", "func_name": "get_host_url_with_port", "whole_func_string": "def get_host_url_with_port(port: int) -> str:\n                                                      \n    host_url = st.context.headers[\"host\"]\n    try:\n        host, _streamlit_port = host_url.split(\":\", maxsplit=1)\n    except ValueError:\n        host = host_url\n    return f\"//{host}:{port}\"", "func_code_string": "def get_host_url_with_port(port: int) -> str:\n                                                      \n    host_url = st.context.headers[\"host\"]\n    try:\n        host, _streamlit_port = host_url.split(\":\", maxsplit=1)\n    except ValueError:\n        host = host_url\n    return f\"//{host}:{port}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/ocrmypdf_compare.py", "func_name": "do_column", "whole_func_string": "def do_column(label, suffix, d):\n    cli = st.text_area(\n        f\"Command line arguments for {label}\",\n        key=f\"args{suffix}\",\n        value=\"ocrmypdf {in_} {out}\",\n    )\n    env_text = st.text_area(f\"Environment variables for {label}\", key=f\"env{suffix}\")\n    env = os.environ.copy()\n    for line in env_text.splitlines():\n        if line:\n            try:\n                k, v = line.split(\"=\", 1)\n            except ValueError:\n                st.error(f\"Invalid environment variable: {line}\")\n                break\n            env[k] = v\n    args = shlex.split(\n        cli.format(\n            in_=os.path.join(d, \"input.pdf\"),\n            out=os.path.join(d, f\"output{suffix}.pdf\"),\n        )\n    )\n    with st.expander(\"Environment variables\", expanded=bool(env_text.strip())):\n        st.code('\\n'.join(f\"{k}={v}\" for k, v in env.items()))\n    st.code(shlex.join(args))\n    return env, args", "func_code_string": "def do_column(label, suffix, d):\n    cli = st.text_area(\n        f\"Command line arguments for {label}\",\n        key=f\"args{suffix}\",\n        value=\"ocrmypdf {in_} {out}\",\n    )\n    env_text = st.text_area(f\"Environment variables for {label}\", key=f\"env{suffix}\")\n    env = os.environ.copy()\n    for line in env_text.splitlines():\n        if line:\n            try:\n                k, v = line.split(\"=\", 1)\n            except ValueError:\n                st.error(f\"Invalid environment variable: {line}\")\n                break\n            env[k] = v\n    args = shlex.split(\n        cli.format(\n            in_=os.path.join(d, \"input.pdf\"),\n            out=os.path.join(d, f\"output{suffix}.pdf\"),\n        )\n    )\n    with st.expander(\"Environment variables\", expanded=bool(env_text.strip())):\n        st.code('\\n'.join(f\"{k}={v}\" for k, v in env.items()))\n    st.code(shlex.join(args))\n    return env, args", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/ocrmypdf_compare.py", "func_name": "main", "whole_func_string": "def main():\n    st.set_page_config(layout=\"wide\")\n\n    st.title(\"OCRmyPDF Compare\")\n    st.write(\"Run OCRmyPDF on the same PDF with different options.\")\n    st.warning(\"This is a testing tool and is not intended for production use.\")\n\n    uploaded_pdf = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"])\n    if uploaded_pdf is None:\n        return\n\n    pdf_bytes = uploaded_pdf.read()\n\n    with pikepdf.open(BytesIO(pdf_bytes)) as p, TemporaryDirectory() as d:\n        with st.expander(\"PDF Metadata\"):\n            with p.open_metadata() as meta:\n                xml_txt = str(meta)\n                parser = etree.XMLParser(remove_blank_text=True)\n                tree = etree.fromstring(xml_txt, parser=parser)\n                st.code(\n                    etree.tostring(tree, pretty_print=True).decode(\"utf-8\"),\n                    language=\"xml\",\n                )\n            st.write(p.docinfo)\n            st.write(\"Number of pages:\", len(p.pages))\n\n        col1, col2 = st.columns(2)\n        with col1:\n            env1, args1 = do_column(\"A\", \"1\", d)\n        with col2:\n            env2, args2 = do_column(\"B\", \"2\", d)\n\n        if not st.button(\"Execute and Compare\"):\n            return\n        with st.spinner(\"Executing...\"):\n            Path(d, \"input.pdf\").write_bytes(pdf_bytes)\n            run(args1, env=env1)\n            run(args2, env=env2)\n\n            col1, col2 = st.columns(2)\n            with col1:\n                st.text(\n                    \"Ghostscript version A: \"\n                    + check_output(\n                        [\"gs\", \"--version\"],\n                        env=env1,\n                        text=True,\n                    )\n                )\n            with col2:\n                st.text(\n                    \"Ghostscript version B: \"\n                    + check_output(\n                        [\"gs\", \"--version\"],\n                        env=env2,\n                        text=True,\n                    )\n                )\n\n            doc1 = pymupdf.open(os.path.join(d, \"output1.pdf\"))\n            doc2 = pymupdf.open(os.path.join(d, \"output2.pdf\"))\n            for i, page1_2 in enumerate(zip(doc1, doc2)):\n                st.write(f\"Page {i+1}\")\n                page1, page2 = page1_2\n                col1, col2 = st.columns(2)\n                with col1, st.container(border=True):\n                    st.write(page1.get_text())\n                with col2, st.container(border=True):\n                    st.write(page2.get_text())\n\n            col1, col2 = st.columns(2)\n            with col1, st.expander(\"PDF Viewer\"):\n                pdf_viewer(Path(d, \"output1.pdf\"))\n            with col2, st.expander(\"PDF Viewer\"):\n                pdf_viewer(Path(d, \"output2.pdf\"))", "func_code_string": "def main():\n    st.set_page_config(layout=\"wide\")\n\n    st.title(\"OCRmyPDF Compare\")\n    st.write(\"Run OCRmyPDF on the same PDF with different options.\")\n    st.warning(\"This is a testing tool and is not intended for production use.\")\n\n    uploaded_pdf = st.file_uploader(\"Upload a PDF\", type=[\"pdf\"])\n    if uploaded_pdf is None:\n        return\n\n    pdf_bytes = uploaded_pdf.read()\n\n    with pikepdf.open(BytesIO(pdf_bytes)) as p, TemporaryDirectory() as d:\n        with st.expander(\"PDF Metadata\"):\n            with p.open_metadata() as meta:\n                xml_txt = str(meta)\n                parser = etree.XMLParser(remove_blank_text=True)\n                tree = etree.fromstring(xml_txt, parser=parser)\n                st.code(\n                    etree.tostring(tree, pretty_print=True).decode(\"utf-8\"),\n                    language=\"xml\",\n                )\n            st.write(p.docinfo)\n            st.write(\"Number of pages:\", len(p.pages))\n\n        col1, col2 = st.columns(2)\n        with col1:\n            env1, args1 = do_column(\"A\", \"1\", d)\n        with col2:\n            env2, args2 = do_column(\"B\", \"2\", d)\n\n        if not st.button(\"Execute and Compare\"):\n            return\n        with st.spinner(\"Executing...\"):\n            Path(d, \"input.pdf\").write_bytes(pdf_bytes)\n            run(args1, env=env1)\n            run(args2, env=env2)\n\n            col1, col2 = st.columns(2)\n            with col1:\n                st.text(\n                    \"Ghostscript version A: \"\n                    + check_output(\n                        [\"gs\", \"--version\"],\n                        env=env1,\n                        text=True,\n                    )\n                )\n            with col2:\n                st.text(\n                    \"Ghostscript version B: \"\n                    + check_output(\n                        [\"gs\", \"--version\"],\n                        env=env2,\n                        text=True,\n                    )\n                )\n\n            doc1 = pymupdf.open(os.path.join(d, \"output1.pdf\"))\n            doc2 = pymupdf.open(os.path.join(d, \"output2.pdf\"))\n            for i, page1_2 in enumerate(zip(doc1, doc2)):\n                st.write(f\"Page {i+1}\")\n                page1, page2 = page1_2\n                col1, col2 = st.columns(2)\n                with col1, st.container(border=True):\n                    st.write(page1.get_text())\n                with col2, st.container(border=True):\n                    st.write(page2.get_text())\n\n            col1, col2 = st.columns(2)\n            with col1, st.expander(\"PDF Viewer\"):\n                pdf_viewer(Path(d, \"output1.pdf\"))\n            with col2, st.expander(\"PDF Viewer\"):\n                pdf_viewer(Path(d, \"output2.pdf\"))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_concurrency.py", "func_name": "test_simulate_oom_killer", "whole_func_string": "def test_simulate_oom_killer(multipage, no_outpdf):\n    exitcode = run_ocrmypdf_api(\n        multipage,\n        no_outpdf,\n        '--force-ocr',\n        '--no-use-threads',\n        '--plugin',\n        'tests/plugins/tesseract_simulate_oom_killer.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_simulate_oom_killer(multipage, no_outpdf):\n    exitcode = run_ocrmypdf_api(\n        multipage,\n        no_outpdf,\n        '--force-ocr',\n        '--no-use-threads',\n        '--plugin',\n        'tests/plugins/tesseract_simulate_oom_killer.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "is_linux", "whole_func_string": "def is_linux():\n    return platform.system() == 'Linux'", "func_code_string": "def is_linux():\n    return platform.system() == 'Linux'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "is_macos", "whole_func_string": "def is_macos():\n    return platform.system() == 'Darwin'", "func_code_string": "def is_macos():\n    return platform.system() == 'Darwin'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "have_unpaper", "whole_func_string": "def have_unpaper():\n    try:\n        unpaper.version()\n    except Exception:                                \n        return False\n    return True", "func_code_string": "def have_unpaper():\n    try:\n        unpaper.version()\n    except Exception:                                \n        return False\n    return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "resources", "whole_func_string": "def resources() -> Path:\n    return Path(TESTS_ROOT) / 'resources'", "func_code_string": "def resources() -> Path:\n    return Path(TESTS_ROOT) / 'resources'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "ocrmypdf_exec", "whole_func_string": "def ocrmypdf_exec() -> list[str]:\n    return [sys.executable, '-m', 'ocrmypdf']", "func_code_string": "def ocrmypdf_exec() -> list[str]:\n    return [sys.executable, '-m', 'ocrmypdf']", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "outdir", "whole_func_string": "def outdir(tmp_path) -> Path:\n    return tmp_path", "func_code_string": "def outdir(tmp_path) -> Path:\n    return tmp_path", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "outpdf", "whole_func_string": "def outpdf(tmp_path) -> Path:\n    return tmp_path / 'out.pdf'", "func_code_string": "def outpdf(tmp_path) -> Path:\n    return tmp_path / 'out.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "outtxt", "whole_func_string": "def outtxt(tmp_path) -> Path:\n    return tmp_path / 'out.txt'", "func_code_string": "def outtxt(tmp_path) -> Path:\n    return tmp_path / 'out.txt'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "no_outpdf", "whole_func_string": "def no_outpdf(tmp_path) -> Path:\n           \n    return tmp_path / 'no_output.pdf'", "func_code_string": "def no_outpdf(tmp_path) -> Path:\n           \n    return tmp_path / 'no_output.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "multipage", "whole_func_string": "def multipage(resources):\n    return resources / 'multipage.pdf'", "func_code_string": "def multipage(resources):\n    return resources / 'multipage.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "check_ocrmypdf", "whole_func_string": "def check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\n                                                                          \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n    api.check_options(options, plugin_manager)\n    result = api.run_pipeline(options, plugin_manager=plugin_manager)\n\n    assert result == 0\n    assert output_file.exists(), \"Output file not created\"\n    assert output_file.stat().st_size > 100, \"PDF too small or empty\"\n\n    return output_file", "func_code_string": "def check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\n                                                                          \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n    api.check_options(options, plugin_manager)\n    result = api.run_pipeline(options, plugin_manager=plugin_manager)\n\n    assert result == 0\n    assert output_file.exists(), \"Output file not created\"\n    assert output_file.stat().st_size > 100, \"PDF too small or empty\"\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "run_ocrmypdf_api", "whole_func_string": "def run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\n           \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n\n    api.check_options(options, plugin_manager)\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)", "func_code_string": "def run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\n           \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n\n    api.check_options(options, plugin_manager)\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "run_ocrmypdf", "whole_func_string": "def run_ocrmypdf(\n    input_file: Path, output_file: Path, *args, text: bool = True\n) -> CompletedProcess:\n           \n    p_args = (\n        [sys.executable, '-m', 'ocrmypdf']\n        + [str(arg) for arg in args if arg is not None]\n        + [str(input_file), str(output_file)]\n    )\n\n    p = run(\n        p_args,\n        capture_output=True,\n        text=text,\n        check=False,\n    )\n                     \n    return p", "func_code_string": "def run_ocrmypdf(\n    input_file: Path, output_file: Path, *args, text: bool = True\n) -> CompletedProcess:\n           \n    p_args = (\n        [sys.executable, '-m', 'ocrmypdf']\n        + [str(arg) for arg in args if arg is not None]\n        + [str(input_file), str(output_file)]\n    )\n\n    p = run(\n        p_args,\n        capture_output=True,\n        text=text,\n        check=False,\n    )\n                     \n    return p", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "first_page_dimensions", "whole_func_string": "def first_page_dimensions(pdf: Path):\n    info = pdfinfo.PdfInfo(pdf)\n    page0 = info[0]\n    return (page0.width_inches, page0.height_inches)", "func_code_string": "def first_page_dimensions(pdf: Path):\n    info = pdfinfo.PdfInfo(pdf)\n    page0 = info[0]\n    return (page0.width_inches, page0.height_inches)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "pytest_addoption", "whole_func_string": "def pytest_addoption(parser):\n    parser.addoption(\n        \"--runslow\",\n        action=\"store_true\",\n        default=False,\n        help=(\n            \"run slow tests only useful for development (unlikely to be \"\n            \"useful for downstream packagers)\"\n        ),\n    )", "func_code_string": "def pytest_addoption(parser):\n    parser.addoption(\n        \"--runslow\",\n        action=\"store_true\",\n        default=False,\n        help=(\n            \"run slow tests only useful for development (unlikely to be \"\n            \"useful for downstream packagers)\"\n        ),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "pytest_collection_modifyitems", "whole_func_string": "def pytest_collection_modifyitems(config, items):\n    if config.getoption(\"--runslow\"):\n                                                        \n        return\n    skip_slow = pytest.mark.skip(reason=\"need --runslow option to run\")\n    for item in items:\n        if \"slow\" in item.keywords:\n            item.add_marker(skip_slow)", "func_code_string": "def pytest_collection_modifyitems(config, items):\n    if config.getoption(\"--runslow\"):\n                                                        \n        return\n    skip_slow = pytest.mark.skip(reason=\"need --runslow option to run\")\n    for item in items:\n        if \"slow\" in item.keywords:\n            item.add_marker(skip_slow)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "make_opts_pm", "whole_func_string": "def make_opts_pm(input_file='a.pdf', output_file='b.pdf', language='eng', **kwargs):\n    if language is not None:\n        kwargs['language'] = language\n    parser = get_parser()\n    pm = get_plugin_manager(kwargs.get('plugins', []))\n    pm.hook.add_options(parser=parser)                             \n    return (\n        create_options(\n            input_file=input_file, output_file=output_file, parser=parser, **kwargs\n        ),\n        pm,\n    )", "func_code_string": "def make_opts_pm(input_file='a.pdf', output_file='b.pdf', language='eng', **kwargs):\n    if language is not None:\n        kwargs['language'] = language\n    parser = get_parser()\n    pm = get_plugin_manager(kwargs.get('plugins', []))\n    pm.hook.add_options(parser=parser)                             \n    return (\n        create_options(\n            input_file=input_file, output_file=output_file, parser=parser, **kwargs\n        ),\n        pm,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "make_opts", "whole_func_string": "def make_opts(*args, **kwargs):\n    opts, _pm = make_opts_pm(*args, **kwargs)\n    return opts", "func_code_string": "def make_opts(*args, **kwargs):\n    opts, _pm = make_opts_pm(*args, **kwargs)\n    return opts", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_old_tesseract_error", "whole_func_string": "def test_old_tesseract_error():\n    with patch(\n        'ocrmypdf._exec.tesseract.version',\n        return_value=TesseractVersion('4.00.00alpha'),\n    ):\n        with pytest.raises(MissingDependencyError):\n            vd.check_options(*make_opts_pm(pdf_renderer='sandwich', language='eng'))", "func_code_string": "def test_old_tesseract_error():\n    with patch(\n        'ocrmypdf._exec.tesseract.version',\n        return_value=TesseractVersion('4.00.00alpha'),\n    ):\n        with pytest.raises(MissingDependencyError):\n            vd.check_options(*make_opts_pm(pdf_renderer='sandwich', language='eng'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_tesseract_not_installed", "whole_func_string": "def test_tesseract_not_installed(caplog):\n    with patch('ocrmypdf.subprocess.run') as not_found:\n        not_found.side_effect = FileNotFoundError('tesseract')\n        with pytest.raises(MissingDependencyError, match=\"Could not find program\"):\n            vd.check_options(*make_opts_pm())\n            assert (\n                \"'tesseract' could not be executed\" in caplog.text\n            ), \"Error message not printed\"\n            assert 'install' in caplog.text, \"Install advice not printed\"\n        not_found.assert_called()", "func_code_string": "def test_tesseract_not_installed(caplog):\n    with patch('ocrmypdf.subprocess.run') as not_found:\n        not_found.side_effect = FileNotFoundError('tesseract')\n        with pytest.raises(MissingDependencyError, match=\"Could not find program\"):\n            vd.check_options(*make_opts_pm())\n            assert (\n                \"'tesseract' could not be executed\" in caplog.text\n            ), \"Error message not printed\"\n            assert 'install' in caplog.text, \"Install advice not printed\"\n        not_found.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_lossless_redo", "whole_func_string": "def test_lossless_redo():\n    with pytest.raises(BadArgsError):\n        options = make_opts(redo_ocr=True, deskew=True)\n        vd.check_options_output(options)\n        vd.set_lossless_reconstruction(options)", "func_code_string": "def test_lossless_redo():\n    with pytest.raises(BadArgsError):\n        options = make_opts(redo_ocr=True, deskew=True)\n        vd.check_options_output(options)\n        vd.set_lossless_reconstruction(options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_mutex_options", "whole_func_string": "def test_mutex_options():\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(force_ocr=True, skip_text=True))\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(redo_ocr=True, skip_text=True))\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(redo_ocr=True, force_ocr=True))", "func_code_string": "def test_mutex_options():\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(force_ocr=True, skip_text=True))\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(redo_ocr=True, skip_text=True))\n    with pytest.raises(BadArgsError):\n        vd.check_options_ocr_behavior(make_opts(redo_ocr=True, force_ocr=True))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_optimizing", "whole_func_string": "def test_optimizing(caplog):\n    vd.check_options(\n        *make_opts_pm(optimize=0, jbig2_lossy=True, png_quality=18, jpeg_quality=10)\n    )\n    assert 'will be ignored because' in caplog.text", "func_code_string": "def test_optimizing(caplog):\n    vd.check_options(\n        *make_opts_pm(optimize=0, jbig2_lossy=True, png_quality=18, jpeg_quality=10)\n    )\n    assert 'will be ignored because' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_pillow_options", "whole_func_string": "def test_pillow_options():\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))", "func_code_string": "def test_pillow_options():\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_output_tty", "whole_func_string": "def test_output_tty():\n    with patch('sys.stdout.isatty', return_value=True):\n        with pytest.raises(BadArgsError):\n            vd.check_requested_output_file(make_opts(output_file='-'))", "func_code_string": "def test_output_tty():\n    with patch('sys.stdout.isatty', return_value=True):\n        with pytest.raises(BadArgsError):\n            vd.check_requested_output_file(make_opts(output_file='-'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_report_file_size", "whole_func_string": "def test_report_file_size(tmp_path, caplog):\n    logging.getLogger('pikepdf._qpdf').setLevel(logging.CRITICAL)                    \n\n    in_ = tmp_path / 'a.pdf'\n    out = tmp_path / 'b.pdf'\n    pdf = pikepdf.new()\n    pdf.save(in_)\n    pdf.save(out)\n    opts = make_opts(output_type='pdf')\n    vd.report_output_file_size(opts, in_, out)\n    assert caplog.text == ''\n    caplog.clear()\n\n    waste_of_space = b'Dummy' * 5000\n    pdf.Root.Dummy = waste_of_space\n    pdf.save(in_)\n    pdf.Root.Dummy2 = waste_of_space + waste_of_space\n    pdf.save(out)\n\n    vd.report_output_file_size(opts, in_, out, ['The optional dependency...'])\n    assert 'optional dependency' in caplog.text\n    caplog.clear()\n\n    vd.report_output_file_size(opts, in_, out, [])\n    assert 'No reason' in caplog.text\n    caplog.clear()\n\n    opts = make_opts(in_, out, optimize=0, output_type='pdf')\n    vd.report_output_file_size(opts, in_, out, [\"Optimization was disabled.\"])\n    assert 'disabled' in caplog.text\n    caplog.clear()", "func_code_string": "def test_report_file_size(tmp_path, caplog):\n    logging.getLogger('pikepdf._qpdf').setLevel(logging.CRITICAL)                    \n\n    in_ = tmp_path / 'a.pdf'\n    out = tmp_path / 'b.pdf'\n    pdf = pikepdf.new()\n    pdf.save(in_)\n    pdf.save(out)\n    opts = make_opts(output_type='pdf')\n    vd.report_output_file_size(opts, in_, out)\n    assert caplog.text == ''\n    caplog.clear()\n\n    waste_of_space = b'Dummy' * 5000\n    pdf.Root.Dummy = waste_of_space\n    pdf.save(in_)\n    pdf.Root.Dummy2 = waste_of_space + waste_of_space\n    pdf.save(out)\n\n    vd.report_output_file_size(opts, in_, out, ['The optional dependency...'])\n    assert 'optional dependency' in caplog.text\n    caplog.clear()\n\n    vd.report_output_file_size(opts, in_, out, [])\n    assert 'No reason' in caplog.text\n    caplog.clear()\n\n    opts = make_opts(in_, out, optimize=0, output_type='pdf')\n    vd.report_output_file_size(opts, in_, out, [\"Optimization was disabled.\"])\n    assert 'disabled' in caplog.text\n    caplog.clear()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_false_action_store_true", "whole_func_string": "def test_false_action_store_true():\n    opts = make_opts(keep_temporary_files=True)\n    assert opts.keep_temporary_files\n    opts = make_opts(keep_temporary_files=False)\n    assert not opts.keep_temporary_files", "func_code_string": "def test_false_action_store_true():\n    opts = make_opts(keep_temporary_files=True)\n    assert opts.keep_temporary_files\n    opts = make_opts(keep_temporary_files=False)\n    assert not opts.keep_temporary_files", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_no_progress_bar", "whole_func_string": "def test_no_progress_bar(progress_bar, resources):\n    opts, pm = make_opts_pm(\n        progress_bar=progress_bar, input_file=(resources / 'trivial.pdf')\n    )\n    vd.check_options(opts, pm)\n\n    pbar_disabled = None\n\n    class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)\n\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\n\n    assert pdfinfo is not None\n    assert pbar_disabled is not None and pbar_disabled != progress_bar", "func_code_string": "def test_no_progress_bar(progress_bar, resources):\n    opts, pm = make_opts_pm(\n        progress_bar=progress_bar, input_file=(resources / 'trivial.pdf')\n    )\n    vd.check_options(opts, pm)\n\n    pbar_disabled = None\n\n    class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)\n\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\n\n    assert pdfinfo is not None\n    assert pbar_disabled is not None and pbar_disabled != progress_bar", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_language_warning", "whole_func_string": "def test_language_warning(caplog):\n    opts = make_opts(language=None)\n    _plugin_manager = get_plugin_manager(opts.plugins)\n    caplog.set_level(logging.DEBUG)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('en_US', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert '' in caplog.text\n        mock.assert_called_once()\n\n    opts = make_opts(language=None)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('fr_FR', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert 'assuming --language' in caplog.text\n        mock.assert_called_once()", "func_code_string": "def test_language_warning(caplog):\n    opts = make_opts(language=None)\n    _plugin_manager = get_plugin_manager(opts.plugins)\n    caplog.set_level(logging.DEBUG)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('en_US', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert '' in caplog.text\n        mock.assert_called_once()\n\n    opts = make_opts(language=None)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('fr_FR', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert 'assuming --language' in caplog.text\n        mock.assert_called_once()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "make_version", "whole_func_string": "def make_version(version):\n    def _make_version():\n        return TesseractVersion(version)\n\n    return _make_version", "func_code_string": "def make_version(version):\n    def _make_version():\n        return TesseractVersion(version)\n\n    return _make_version", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_version_comparison", "whole_func_string": "def test_version_comparison():\n    vd.check_external_program(\n        program=\"dummy_basic\",\n        package=\"dummy\",\n        version_checker=make_version('9.0'),\n        need_version='8.0.2',\n    )\n    vd.check_external_program(\n        program=\"dummy_doubledigit\",\n        package=\"dummy\",\n        version_checker=make_version('10.0'),\n        need_version='8.0.2',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.0.0-beta.1'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v5.0.0-alpha.20200201'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('5.0.0-rc1.20211030'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v4.1.1.20181030'),                               \n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"gs\",\n        package=\"ghostscript\",\n        version_checker=make_version('10.0'),\n        need_version='9.50',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.1.1-rc2-25-g9707'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"dummy_fails\",\n            package=\"dummy\",\n            version_checker=make_version('1.0'),\n            need_version='2.0',\n        )", "func_code_string": "def test_version_comparison():\n    vd.check_external_program(\n        program=\"dummy_basic\",\n        package=\"dummy\",\n        version_checker=make_version('9.0'),\n        need_version='8.0.2',\n    )\n    vd.check_external_program(\n        program=\"dummy_doubledigit\",\n        package=\"dummy\",\n        version_checker=make_version('10.0'),\n        need_version='8.0.2',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.0.0-beta.1'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v5.0.0-alpha.20200201'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('5.0.0-rc1.20211030'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v4.1.1.20181030'),                               \n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"gs\",\n        package=\"ghostscript\",\n        version_checker=make_version('10.0'),\n        need_version='9.50',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.1.1-rc2-25-g9707'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"dummy_fails\",\n            package=\"dummy\",\n            version_checker=make_version('1.0'),\n            need_version='2.0',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_optional_program_recommended", "whole_func_string": "def test_optional_program_recommended(caplog):\n    caplog.clear()\n\n    def raiser():\n        raise FileNotFoundError('jbig2')\n\n    with caplog.at_level(logging.WARNING):\n        vd.check_external_program(\n            program=\"jbig2\",\n            package=\"jbig2enc\",\n            version_checker=raiser,\n            need_version='42',\n            required_for='this test case',\n            recommended=True,\n        )\n        assert any(\n            (loglevel == logging.WARNING and \"recommended\" in msg)\n            for _logger_name, loglevel, msg in caplog.record_tuples\n        )", "func_code_string": "def test_optional_program_recommended(caplog):\n    caplog.clear()\n\n    def raiser():\n        raise FileNotFoundError('jbig2')\n\n    with caplog.at_level(logging.WARNING):\n        vd.check_external_program(\n            program=\"jbig2\",\n            package=\"jbig2enc\",\n            version_checker=raiser,\n            need_version='42',\n            required_for='this test case',\n            recommended=True,\n        )\n        assert any(\n            (loglevel == logging.WARNING and \"recommended\" in msg)\n            for _logger_name, loglevel, msg in caplog.record_tuples\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_pagesegmode_warning", "whole_func_string": "def test_pagesegmode_warning(caplog):\n    opts = make_opts(tesseract_pagesegmode='0')\n    plugin_manager = get_plugin_manager(opts.plugins)\n    vd.check_options(opts, plugin_manager)\n    assert 'disable OCR' in caplog.text", "func_code_string": "def test_pagesegmode_warning(caplog):\n    opts = make_opts(tesseract_pagesegmode='0')\n    plugin_manager = get_plugin_manager(opts.plugins)\n    vd.check_options(opts, plugin_manager)\n    assert 'disable OCR' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_two_languages", "whole_func_string": "def test_two_languages():\n    vd.check_options_languages(\n        create_options(\n            input_file='a.pdf',\n            output_file='b.pdf',\n            parser=get_parser(),\n            language='fakelang1+fakelang2',\n        ),\n        ['fakelang1', 'fakelang2'],\n    )", "func_code_string": "def test_two_languages():\n    vd.check_options_languages(\n        create_options(\n            input_file='a.pdf',\n            output_file='b.pdf',\n            parser=get_parser(),\n            language='fakelang1+fakelang2',\n        ),\n        ['fakelang1', 'fakelang2'],\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_sidecar_equals_output", "whole_func_string": "def test_sidecar_equals_output(resources, no_outpdf):\n    op = no_outpdf\n    with pytest.raises(BadArgsError, match=r'--sidecar'):\n        run_ocrmypdf_api(resources / 'trivial.pdf', op, '--sidecar', op)", "func_code_string": "def test_sidecar_equals_output(resources, no_outpdf):\n    op = no_outpdf\n    with pytest.raises(BadArgsError, match=r'--sidecar'):\n        run_ocrmypdf_api(resources / 'trivial.pdf', op, '--sidecar', op)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_devnull_sidecar", "whole_func_string": "def test_devnull_sidecar(resources):\n    with pytest.raises(BadArgsError, match=r'--sidecar.*NUL'):\n        run_ocrmypdf_api(resources / 'trivial.pdf', os.devnull, '--sidecar')", "func_code_string": "def test_devnull_sidecar(resources):\n    with pytest.raises(BadArgsError, match=r'--sidecar.*NUL'):\n        run_ocrmypdf_api(resources / 'trivial.pdf', os.devnull, '--sidecar')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "CheckProgressBar", "whole_func_string": "class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)", "func_code_string": "class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "_make_version", "whole_func_string": "def _make_version():\n        return TesseractVersion(version)", "func_code_string": "def _make_version():\n        return TesseractVersion(version)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "raiser", "whole_func_string": "def raiser():\n        raise FileNotFoundError('jbig2')", "func_code_string": "def raiser():\n        raise FileNotFoundError('jbig2')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "__init__", "whole_func_string": "def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)", "func_code_string": "def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_logging.py", "func_name": "test_debug_logging", "whole_func_string": "def test_debug_logging(tmp_path):\n                                                          \n                                                                                    \n    prefix = 'test_debug_logging'\n    log = logging.getLogger(prefix)\n    _handler, remover = configure_debug_logging(tmp_path / 'test.log', prefix)\n    log.info(\"test message\")\n    remover()", "func_code_string": "def test_debug_logging(tmp_path):\n                                                          \n                                                                                    \n    prefix = 'test_debug_logging'\n    log = logging.getLogger(prefix)\n    _handler, remover = configure_debug_logging(tmp_path / 'test.log', prefix)\n    log.info(\"test message\")\n    remover()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_check_pdf.py", "func_name": "test_pdf_error", "whole_func_string": "def test_pdf_error(resources):\n    assert check_pdf(resources / 'blank.pdf')\n    assert not check_pdf(__file__)", "func_code_string": "def test_pdf_error(resources):\n    assert check_pdf(resources / 'blank.pdf')\n    assert not check_pdf(__file__)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tagged.py", "func_name": "test_block_tagged", "whole_func_string": "def test_block_tagged(resources):\n    with pytest.raises(ocrmypdf.exceptions.TaggedPDFError):\n        ocrmypdf.ocr(resources / 'tagged.pdf', '_.pdf')", "func_code_string": "def test_block_tagged(resources):\n    with pytest.raises(ocrmypdf.exceptions.TaggedPDFError):\n        ocrmypdf.ocr(resources / 'tagged.pdf', '_.pdf')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tagged.py", "func_name": "test_force_tagged_warns", "whole_func_string": "def test_force_tagged_warns(resources, outpdf, caplog):\n    caplog.set_level('WARNING')\n    ocrmypdf.ocr(\n        resources / 'tagged.pdf',\n        outpdf,\n        force_ocr=True,\n        plugins=['tests/plugins/tesseract_noop.py'],\n    )\n    assert 'marked as a Tagged PDF' in caplog.text", "func_code_string": "def test_force_tagged_warns(resources, outpdf, caplog):\n    caplog.set_level('WARNING')\n    ocrmypdf.ocr(\n        resources / 'tagged.pdf',\n        outpdf,\n        force_ocr=True,\n        plugins=['tests/plugins/tesseract_noop.py'],\n    )\n    assert 'marked as a Tagged PDF' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "palette", "whole_func_string": "def palette(resources):\n    return resources / 'palette.pdf'", "func_code_string": "def palette(resources):\n    return resources / 'palette.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_basic", "whole_func_string": "def test_basic(multipage, palette, pdf, outpdf):\n    infile = multipage if pdf == 'multipage' else palette\n    opt.main(infile, outpdf, level=3)\n\n    assert 0.98 * Path(outpdf).stat().st_size <= Path(infile).stat().st_size", "func_code_string": "def test_basic(multipage, palette, pdf, outpdf):\n    infile = multipage if pdf == 'multipage' else palette\n    opt.main(infile, outpdf, level=3)\n\n    assert 0.98 * Path(outpdf).stat().st_size <= Path(infile).stat().st_size", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_mono_not_inverted", "whole_func_string": "def test_mono_not_inverted(resources, outdir):\n    infile = resources / '2400dpi.pdf'\n    opt.main(infile, outdir / 'out.pdf', level=3)\n\n    rasterize_pdf(\n        outdir / 'out.pdf',\n        outdir / 'im.png',\n        raster_device='pnggray',\n        raster_dpi=Resolution(10, 10),\n    )\n\n    with Image.open(fspath(outdir / 'im.png')) as im:\n        assert im.getpixel((0, 0)) > 240, \"Expected white background\"", "func_code_string": "def test_mono_not_inverted(resources, outdir):\n    infile = resources / '2400dpi.pdf'\n    opt.main(infile, outdir / 'out.pdf', level=3)\n\n    rasterize_pdf(\n        outdir / 'out.pdf',\n        outdir / 'im.png',\n        raster_device='pnggray',\n        raster_dpi=Resolution(10, 10),\n    )\n\n    with Image.open(fspath(outdir / 'im.png')) as im:\n        assert im.getpixel((0, 0)) > 240, \"Expected white background\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_jpg_png_params", "whole_func_string": "def test_jpg_png_params(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--optimize',\n        '3',\n        '--jpg-quality',\n        '50',\n        '--png-quality',\n        '20',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_jpg_png_params(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--optimize',\n        '3',\n        '--jpg-quality',\n        '50',\n        '--png-quality',\n        '20',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_jbig2_lossy", "whole_func_string": "def test_jbig2_lossy(lossy, resources, outpdf):\n    args = [\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--optimize',\n        '3',\n        '--jpg-quality',\n        '50',\n        '--png-quality',\n        '20',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--jbig2-threshold',\n        '0.7',\n    ]\n    if lossy:\n        args.append('--jbig2-lossy')\n\n    check_ocrmypdf(*args)\n\n    with pikepdf.open(outpdf) as pdf:\n        pim = pikepdf.PdfImage(next(iter(pdf.pages[0].images.values())))\n        assert pim.filters[0] == '/JBIG2Decode'\n\n        if lossy:\n            assert '/JBIG2Globals' in pim.decode_parms[0]\n        else:\n            assert len(pim.decode_parms) == 0", "func_code_string": "def test_jbig2_lossy(lossy, resources, outpdf):\n    args = [\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--optimize',\n        '3',\n        '--jpg-quality',\n        '50',\n        '--png-quality',\n        '20',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--jbig2-threshold',\n        '0.7',\n    ]\n    if lossy:\n        args.append('--jbig2-lossy')\n\n    check_ocrmypdf(*args)\n\n    with pikepdf.open(outpdf) as pdf:\n        pim = pikepdf.PdfImage(next(iter(pdf.pages[0].images.values())))\n        assert pim.filters[0] == '/JBIG2Decode'\n\n        if lossy:\n            assert '/JBIG2Globals' in pim.decode_parms[0]\n        else:\n            assert len(pim.decode_parms) == 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_flate_to_jbig2", "whole_func_string": "def test_flate_to_jbig2(resources, outdir):\n                                                                           \n                                                                         \n                  \n    with Image.open(fspath(resources / 'typewriter.png')) as im:\n        assert im.mode in ('1', 'P')\n        im = im.convert('L')\n        im.save(fspath(outdir / 'type8.png'))\n\n    check_ocrmypdf(\n        outdir / 'type8.png',\n        outdir / 'out.pdf',\n        '--image-dpi',\n        '100',\n        '--png-quality',\n        '50',\n        '--optimize',\n        '3',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outdir / 'out.pdf') as pdf:\n        pim = pikepdf.PdfImage(next(iter(pdf.pages[0].images.values())))\n        assert pim.filters[0] == '/JBIG2Decode'", "func_code_string": "def test_flate_to_jbig2(resources, outdir):\n                                                                           \n                                                                         \n                  \n    with Image.open(fspath(resources / 'typewriter.png')) as im:\n        assert im.mode in ('1', 'P')\n        im = im.convert('L')\n        im.save(fspath(outdir / 'type8.png'))\n\n    check_ocrmypdf(\n        outdir / 'type8.png',\n        outdir / 'out.pdf',\n        '--image-dpi',\n        '100',\n        '--png-quality',\n        '50',\n        '--optimize',\n        '3',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outdir / 'out.pdf') as pdf:\n        pim = pikepdf.PdfImage(next(iter(pdf.pages[0].images.values())))\n        assert pim.filters[0] == '/JBIG2Decode'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_multiple_pngs", "whole_func_string": "def test_multiple_pngs(resources, outdir):\n    with Path.open(outdir / 'in.pdf', 'wb') as inpdf:\n        img2pdf.convert(\n            fspath(resources / 'baiona_colormapped.png'),\n            fspath(resources / 'baiona_gray.png'),\n            outputstream=inpdf,\n            **IMG2PDF_KWARGS,\n        )\n\n    def mockquant(input_file, output_file, *_args):\n        with Image.open(input_file) as im:\n            draw = ImageDraw.Draw(im)\n            draw.rectangle((0, 0, im.width, im.height), fill=128)\n            im.save(output_file)\n\n    with patch('ocrmypdf.optimize.pngquant.quantize') as mock:\n        mock.side_effect = mockquant\n        check_ocrmypdf(\n            outdir / 'in.pdf',\n            outdir / 'out.pdf',\n            '--optimize',\n            '3',\n            '--jobs',\n            '1',\n            '--use-threads',\n            '--output-type',\n            'pdf',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n        mock.assert_called()\n\n    with (\n        pikepdf.open(outdir / 'in.pdf') as inpdf,\n        pikepdf.open(outdir / 'out.pdf') as outpdf,\n    ):\n        for n in range(len(inpdf.pages)):\n            inim = next(iter(inpdf.pages[n].images.values()))\n            outim = next(iter(outpdf.pages[n].images.values()))\n            assert len(outim.read_raw_bytes()) < len(inim.read_raw_bytes()), n", "func_code_string": "def test_multiple_pngs(resources, outdir):\n    with Path.open(outdir / 'in.pdf', 'wb') as inpdf:\n        img2pdf.convert(\n            fspath(resources / 'baiona_colormapped.png'),\n            fspath(resources / 'baiona_gray.png'),\n            outputstream=inpdf,\n            **IMG2PDF_KWARGS,\n        )\n\n    def mockquant(input_file, output_file, *_args):\n        with Image.open(input_file) as im:\n            draw = ImageDraw.Draw(im)\n            draw.rectangle((0, 0, im.width, im.height), fill=128)\n            im.save(output_file)\n\n    with patch('ocrmypdf.optimize.pngquant.quantize') as mock:\n        mock.side_effect = mockquant\n        check_ocrmypdf(\n            outdir / 'in.pdf',\n            outdir / 'out.pdf',\n            '--optimize',\n            '3',\n            '--jobs',\n            '1',\n            '--use-threads',\n            '--output-type',\n            'pdf',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n        mock.assert_called()\n\n    with (\n        pikepdf.open(outdir / 'in.pdf') as inpdf,\n        pikepdf.open(outdir / 'out.pdf') as outpdf,\n    ):\n        for n in range(len(inpdf.pages)):\n            inim = next(iter(inpdf.pages[n].images.values()))\n            outim = next(iter(outpdf.pages[n].images.values()))\n            assert len(outim.read_raw_bytes()) < len(inim.read_raw_bytes()), n", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_optimize_off", "whole_func_string": "def test_optimize_off(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--optimize=0',\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_optimize_off(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--optimize=0',\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_group3", "whole_func_string": "def test_group3(resources):\n    with pikepdf.open(resources / 'ccitt.pdf') as pdf:\n        im = pdf.pages[0].Resources.XObject['/Im1']\n        assert (\n            opt.extract_image_filter(im, im.objgen[0]) is not None\n        ), \"Group 4 should be allowed\"\n\n        im.DecodeParms['/K'] = 0\n        assert (\n            opt.extract_image_filter(im, im.objgen[0]) is None\n        ), \"Group 3 should be disallowed\"", "func_code_string": "def test_group3(resources):\n    with pikepdf.open(resources / 'ccitt.pdf') as pdf:\n        im = pdf.pages[0].Resources.XObject['/Im1']\n        assert (\n            opt.extract_image_filter(im, im.objgen[0]) is not None\n        ), \"Group 4 should be allowed\"\n\n        im.DecodeParms['/K'] = 0\n        assert (\n            opt.extract_image_filter(im, im.objgen[0]) is None\n        ), \"Group 3 should be disallowed\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_find_formx", "whole_func_string": "def test_find_formx(resources):\n    with pikepdf.open(resources / 'formxobject.pdf') as pdf:\n        working, pagenos = opt._find_image_xrefs(pdf)\n        assert len(working) == 1\n        xref = next(iter(working))\n        assert pagenos[xref] == 0", "func_code_string": "def test_find_formx(resources):\n    with pikepdf.open(resources / 'formxobject.pdf') as pdf:\n        working, pagenos = opt._find_image_xrefs(pdf)\n        assert len(working) == 1\n        xref = next(iter(working))\n        assert pagenos[xref] == 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_pdf_image", "whole_func_string": "def test_extract_image_filter_with_pdf_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.Filter = [Name.FlateDecode, Name.DCTDecode]\n    pdf_image = PdfImage(image)\n    image.BitsPerComponent = 8\n    assert extract_image_filter(image, None) == (\n        pdf_image,\n        pdf_image.filter_decodeparms[1],\n    )", "func_code_string": "def test_extract_image_filter_with_pdf_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.Filter = [Name.FlateDecode, Name.DCTDecode]\n    pdf_image = PdfImage(image)\n    image.BitsPerComponent = 8\n    assert extract_image_filter(image, None) == (\n        pdf_image,\n        pdf_image.filter_decodeparms[1],\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_non_image", "whole_func_string": "def test_extract_image_filter_with_non_image():\n    image = MagicMock()\n    image.Subtype = Name.Form\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_non_image():\n    image = MagicMock()\n    image.Subtype = Name.Form\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_small_stream_size", "whole_func_string": "def test_extract_image_filter_with_small_stream_size():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 50\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_small_stream_size():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 50\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_small_dimensions", "whole_func_string": "def test_extract_image_filter_with_small_dimensions():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 5\n    image.Height = 5\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_small_dimensions():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 5\n    image.Height = 5\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_multiple_compression_filters", "whole_func_string": "def test_extract_image_filter_with_multiple_compression_filters():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 8\n    image.Filter = [Name.ASCII85Decode, Name.FlateDecode, Name.DCTDecode]\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_multiple_compression_filters():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 8\n    image.Filter = [Name.ASCII85Decode, Name.FlateDecode, Name.DCTDecode]\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_wide_gamut_image", "whole_func_string": "def test_extract_image_filter_with_wide_gamut_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 16\n    image.Filter = Name.FlateDecode\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_wide_gamut_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 16\n    image.Filter = Name.FlateDecode\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_jpeg2000_image", "whole_func_string": "def test_extract_image_filter_with_jpeg2000_image():\n    im = Image.new('RGB', (10, 10))\n    bio = BytesIO()\n    im.save(bio, format='JPEG2000')\n    pdf = pikepdf.new()\n    stream = pdf.make_stream(\n        data=bio.getvalue(),\n        Subtype=Name.Image,\n        Length=200,\n        Width=10,\n        Height=10,\n        BitsPerComponent=8,\n        Filter=Name.JPXDecode,\n    )\n    assert extract_image_filter(stream, None) is None", "func_code_string": "def test_extract_image_filter_with_jpeg2000_image():\n    im = Image.new('RGB', (10, 10))\n    bio = BytesIO()\n    im.save(bio, format='JPEG2000')\n    pdf = pikepdf.new()\n    stream = pdf.make_stream(\n        data=bio.getvalue(),\n        Subtype=Name.Image,\n        Length=200,\n        Width=10,\n        Height=10,\n        BitsPerComponent=8,\n        Filter=Name.JPXDecode,\n    )\n    assert extract_image_filter(stream, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_ccitt_group_3_image", "whole_func_string": "def test_extract_image_filter_with_ccitt_group_3_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 1\n    image.Filter = Name.CCITTFaxDecode\n    image.DecodeParms = Array([Dictionary(K=1)])\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_ccitt_group_3_image():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 200\n    image.Width = 10\n    image.Height = 10\n    image.BitsPerComponent = 1\n    image.Filter = Name.CCITTFaxDecode\n    image.DecodeParms = Array([Dictionary(K=1)])\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "mockquant", "whole_func_string": "def mockquant(input_file, output_file, *_args):\n        with Image.open(input_file) as im:\n            draw = ImageDraw.Draw(im)\n            draw.rectangle((0, 0, im.width, im.height), fill=128)\n            im.save(output_file)", "func_code_string": "def mockquant(input_file, output_file, *_args):\n        with Image.open(input_file) as im:\n            draw = ImageDraw.Draw(im)\n            draw.rectangle((0, 0, im.width, im.height), fill=128)\n            im.save(output_file)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_stdio.py", "func_name": "test_stdin", "whole_func_string": "def test_stdin(ocrmypdf_exec, resources, outpdf):\n    input_file = str(resources / 'francais.pdf')\n    output_file = str(outpdf)\n\n                                                \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '-',\n            output_file,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        ]\n        run(p_args, capture_output=True, stdin=input_stream, check=True)", "func_code_string": "def test_stdin(ocrmypdf_exec, resources, outpdf):\n    input_file = str(resources / 'francais.pdf')\n    output_file = str(outpdf)\n\n                                                \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '-',\n            output_file,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        ]\n        run(p_args, capture_output=True, stdin=input_stream, check=True)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_stdio.py", "func_name": "test_stdout", "whole_func_string": "def test_stdout(ocrmypdf_exec, resources, outpdf):\n    if 'COV_CORE_DATAFILE' in os.environ:\n        pytest.skip(\"Coverage uses stdout\")\n\n    input_file = str(resources / 'francais.pdf')\n    output_file = str(outpdf)\n\n                                                     \n    with open(output_file, 'wb') as output_stream:\n        p_args = ocrmypdf_exec + [\n            input_file,\n            '-',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        ]\n        run(p_args, stdout=output_stream, stderr=PIPE, stdin=DEVNULL, check=True)\n\n    assert check_pdf(output_file)", "func_code_string": "def test_stdout(ocrmypdf_exec, resources, outpdf):\n    if 'COV_CORE_DATAFILE' in os.environ:\n        pytest.skip(\"Coverage uses stdout\")\n\n    input_file = str(resources / 'francais.pdf')\n    output_file = str(outpdf)\n\n                                                     \n    with open(output_file, 'wb') as output_stream:\n        p_args = ocrmypdf_exec + [\n            input_file,\n            '-',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        ]\n        run(p_args, stdout=output_stream, stderr=PIPE, stdin=DEVNULL, check=True)\n\n    assert check_pdf(output_file)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_stdio.py", "func_name": "test_dev_null", "whole_func_string": "def test_dev_null(resources):\n    if 'COV_CORE_DATAFILE' in os.environ:\n        pytest.skip(\"Coverage uses stdout\")\n\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        os.devnull,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == 0, \"could not send output to /dev/null\"\n    assert len(p.stdout) == 0, \"wrote to stdout\"", "func_code_string": "def test_dev_null(resources):\n    if 'COV_CORE_DATAFILE' in os.environ:\n        pytest.skip(\"Coverage uses stdout\")\n\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        os.devnull,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == 0, \"could not send output to /dev/null\"\n    assert len(p.stdout) == 0, \"wrote to stdout\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "baiona", "whole_func_string": "def baiona(resources):\n    return Image.open(resources / 'baiona_gray.png')", "func_code_string": "def baiona(resources):\n    return Image.open(resources / 'baiona_gray.png')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_image_to_pdf", "whole_func_string": "def test_image_to_pdf(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_image_to_pdf(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outpdf,\n        '--image-dpi',\n        '200',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_no_dpi_info", "whole_func_string": "def test_no_dpi_info(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image)\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"--image-dpi\" in caplog.text", "func_code_string": "def test_no_dpi_info(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image)\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"--image-dpi\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_dpi_not_credible", "whole_func_string": "def test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image, dpi=(30, 30))\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"not credible\" in caplog.text", "func_code_string": "def test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image, dpi=(30, 30))\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"not credible\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_cmyk_no_icc", "whole_func_string": "def test_cmyk_no_icc(caplog, resources, no_outpdf):\n    rc = run_ocrmypdf_api(resources / 'baiona_cmyk.jpg', no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"no ICC profile\" in caplog.text", "func_code_string": "def test_cmyk_no_icc(caplog, resources, no_outpdf):\n    rc = run_ocrmypdf_api(resources / 'baiona_cmyk.jpg', no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"no ICC profile\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_img2pdf_fails", "whole_func_string": "def test_img2pdf_fails(resources, no_outpdf):\n    with patch(\n        'ocrmypdf._pipeline.img2pdf.convert', side_effect=img2pdf.ImageOpenError()\n    ) as mock:\n        rc = run_ocrmypdf_api(\n            resources / 'baiona_gray.png', no_outpdf, '--image-dpi', '200'\n        )\n        assert rc == ocrmypdf.ExitCode.input_file\n        mock.assert_called()", "func_code_string": "def test_img2pdf_fails(resources, no_outpdf):\n    with patch(\n        'ocrmypdf._pipeline.img2pdf.convert', side_effect=img2pdf.ImageOpenError()\n    ) as mock:\n        rc = run_ocrmypdf_api(\n            resources / 'baiona_gray.png', no_outpdf, '--image-dpi', '200'\n        )\n        assert rc == ocrmypdf.ExitCode.input_file\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_jpeg_in_jpeg_out", "whole_func_string": "def test_jpeg_in_jpeg_out(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'baiona_color.jpg',\n        outpdf,\n        '--image-dpi',\n        '100',\n        '--output-type',\n        'pdf',                                                                  \n        '--remove-background',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with pikepdf.open(outpdf) as pdf:\n        assert next(iter(pdf.pages[0].images.values())).Filter == pikepdf.Name.DCTDecode", "func_code_string": "def test_jpeg_in_jpeg_out(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'baiona_color.jpg',\n        outpdf,\n        '--image-dpi',\n        '100',\n        '--output-type',\n        'pdf',                                                                  \n        '--remove-background',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with pikepdf.open(outpdf) as pdf:\n        assert next(iter(pdf.pages[0].images.values())).Filter == pikepdf.Name.DCTDecode", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_preserve_docinfo", "whole_func_string": "def test_preserve_docinfo(output_type, resources, outpdf):\n    output = check_ocrmypdf(\n        resources / 'graph.pdf',\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with (\n        pikepdf.open(resources / 'graph.pdf') as pdf_before,\n        pikepdf.open(output) as pdf_after,\n    ):\n        for key in ('/Title', '/Author'):\n            assert pdf_before.docinfo[key] == pdf_after.docinfo[key]\n        pdfa_info = file_claims_pdfa(str(output))\n        assert pdfa_info['output'] == output_type", "func_code_string": "def test_preserve_docinfo(output_type, resources, outpdf):\n    output = check_ocrmypdf(\n        resources / 'graph.pdf',\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with (\n        pikepdf.open(resources / 'graph.pdf') as pdf_before,\n        pikepdf.open(output) as pdf_after,\n    ):\n        for key in ('/Title', '/Author'):\n            assert pdf_before.docinfo[key] == pdf_after.docinfo[key]\n        pdfa_info = file_claims_pdfa(str(output))\n        assert pdfa_info['output'] == output_type", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_override_metadata", "whole_func_string": "def test_override_metadata(output_type, resources, outpdf, caplog):\n    input_file = resources / 'c02-22.pdf'\n    german = 'Du siehst den Wald vor lauter B\u00e4umen nicht.'\n    chinese = '\u5b54\u5b50'\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        '--title',\n        german,\n        '--author',\n        chinese,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n    with pikepdf.open(input_file) as before, pikepdf.open(outpdf) as after:\n        assert after.docinfo.Title == german, after.docinfo\n        assert after.docinfo.Author == chinese, after.docinfo\n        assert after.docinfo.get('/Keywords', '') == ''\n\n        before_date = decode_pdf_date(str(before.docinfo.CreationDate))\n        after_date = decode_pdf_date(str(after.docinfo.CreationDate))\n        assert before_date == after_date\n\n        pdfa_info = file_claims_pdfa(outpdf)\n        assert pdfa_info['output'] == output_type", "func_code_string": "def test_override_metadata(output_type, resources, outpdf, caplog):\n    input_file = resources / 'c02-22.pdf'\n    german = 'Du siehst den Wald vor lauter B\u00e4umen nicht.'\n    chinese = '\u5b54\u5b50'\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        '--title',\n        german,\n        '--author',\n        chinese,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n    with pikepdf.open(input_file) as before, pikepdf.open(outpdf) as after:\n        assert after.docinfo.Title == german, after.docinfo\n        assert after.docinfo.Author == chinese, after.docinfo\n        assert after.docinfo.get('/Keywords', '') == ''\n\n        before_date = decode_pdf_date(str(before.docinfo.CreationDate))\n        after_date = decode_pdf_date(str(after.docinfo.CreationDate))\n        assert before_date == after_date\n\n        pdfa_info = file_claims_pdfa(outpdf)\n        assert pdfa_info['output'] == output_type", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_unset_metadata", "whole_func_string": "def test_unset_metadata(output_type, field, resources, outpdf, caplog):\n    input_file = resources / 'meta.pdf'\n\n                                                       \n    meta = {\n        'title': b'NFY5f7Ft2DWMkxLhXwxvFf7eWR2KeK3vEDcd',\n        'author': b'yXaryipxyRk9dVjWjSSaVaNCKeLRgEVzPRMp',\n        'subject': b't49vimctvnuH7ZeAjAkv52ACvWFjcnm5MPJr',\n        'keywords': b's9EeALwUg7urA7fnnhm5EtUyC54sW2WPUzqh',\n    }\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        f'--{field}',\n        '',\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n                                                                        \n                                                                            \n                                                                     \n                                                                       \n                                                                            \n                                                                          \n                 \n    with open(input_file, 'rb') as before, open(outpdf, 'rb') as after:\n        before_data = before.read()\n        after_data = after.read()\n\n    for k, v in meta.items():\n        assert v in before_data\n        if k == field:\n            assert v not in after_data\n        else:\n            assert v in after_data", "func_code_string": "def test_unset_metadata(output_type, field, resources, outpdf, caplog):\n    input_file = resources / 'meta.pdf'\n\n                                                       \n    meta = {\n        'title': b'NFY5f7Ft2DWMkxLhXwxvFf7eWR2KeK3vEDcd',\n        'author': b'yXaryipxyRk9dVjWjSSaVaNCKeLRgEVzPRMp',\n        'subject': b't49vimctvnuH7ZeAjAkv52ACvWFjcnm5MPJr',\n        'keywords': b's9EeALwUg7urA7fnnhm5EtUyC54sW2WPUzqh',\n    }\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        f'--{field}',\n        '',\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n                                                                        \n                                                                            \n                                                                     \n                                                                       \n                                                                            \n                                                                          \n                 \n    with open(input_file, 'rb') as before, open(outpdf, 'rb') as after:\n        before_data = before.read()\n        after_data = after.read()\n\n    for k, v in meta.items():\n        assert v in before_data\n        if k == field:\n            assert v not in after_data\n        else:\n            assert v in after_data", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_high_unicode", "whole_func_string": "def test_high_unicode(resources, no_outpdf):\n                                                                       \n          \n    input_file = resources / 'c02-22.pdf'\n    high_unicode = 'U+1030C is: \ud800\udf0c'\n\n    p = run_ocrmypdf(\n        input_file,\n        no_outpdf,\n        '--subject',\n        high_unicode,\n        '--output-type',\n        'pdfa',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert p.returncode == ExitCode.bad_args, p.stderr", "func_code_string": "def test_high_unicode(resources, no_outpdf):\n                                                                       \n          \n    input_file = resources / 'c02-22.pdf'\n    high_unicode = 'U+1030C is: \ud800\udf0c'\n\n    p = run_ocrmypdf(\n        input_file,\n        no_outpdf,\n        '--subject',\n        high_unicode,\n        '--output-type',\n        'pdfa',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert p.returncode == ExitCode.bad_args, p.stderr", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_bookmarks_preserved", "whole_func_string": "def test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\n    fitz = pytest.importorskip('fitz')\n    input_file = resources / 'toc.pdf'\n    before_toc = fitz.Document(str(input_file)).get_toc()\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        ocr_option,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after_toc = fitz.Document(str(outpdf)).get_toc()\n    print(before_toc)\n    print(after_toc)\n    assert before_toc == after_toc", "func_code_string": "def test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\n    fitz = pytest.importorskip('fitz')\n    input_file = resources / 'toc.pdf'\n    before_toc = fitz.Document(str(input_file)).get_toc()\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        ocr_option,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after_toc = fitz.Document(str(outpdf)).get_toc()\n    print(before_toc)\n    print(after_toc)\n    assert before_toc == after_toc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "seconds_between_dates", "whole_func_string": "def seconds_between_dates(date1, date2):\n    return (date2 - date1).total_seconds()", "func_code_string": "def seconds_between_dates(date1, date2):\n    return (date2 - date1).total_seconds()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_creation_date_preserved", "whole_func_string": "def test_creation_date_preserved(output_type, resources, infile, outpdf):\n    input_file = resources / infile\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(input_file) as pdf_before, pikepdf.open(outpdf) as pdf_after:\n        before = pdf_before.trailer.get('/Info', {})\n        after = pdf_after.trailer.get('/Info', {})\n\n        if not before:\n            assert after.get('/CreationDate', '') != ''\n        else:\n                                                              \n            date_before = decode_pdf_date(str(before['/CreationDate']))\n            date_after = decode_pdf_date(str(after['/CreationDate']))\n            assert seconds_between_dates(date_before, date_after) < 1000\n\n                                                          \n        date_after = decode_pdf_date(str(after['/ModDate']))\n        assert (\n            seconds_between_dates(date_after, datetime.datetime.now(timezone.utc))\n            < 1000\n        )", "func_code_string": "def test_creation_date_preserved(output_type, resources, infile, outpdf):\n    input_file = resources / infile\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(input_file) as pdf_before, pikepdf.open(outpdf) as pdf_after:\n        before = pdf_before.trailer.get('/Info', {})\n        after = pdf_after.trailer.get('/Info', {})\n\n        if not before:\n            assert after.get('/CreationDate', '') != ''\n        else:\n                                                              \n            date_before = decode_pdf_date(str(before['/CreationDate']))\n            date_after = decode_pdf_date(str(after['/CreationDate']))\n            assert seconds_between_dates(date_before, date_after) < 1000\n\n                                                          \n        date_after = decode_pdf_date(str(after['/ModDate']))\n        assert (\n            seconds_between_dates(date_after, datetime.datetime.now(timezone.utc))\n            < 1000\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "libxmp_file_to_dict", "whole_func_string": "def libxmp_file_to_dict():\n    try:\n        with warnings.catch_warnings():\n                                                                   \n            warnings.filterwarnings(\n                \"ignore\",\n                category=DeprecationWarning,\n                message=r\".*distutils Version classes are deprecated.*\",\n            )\n            from libxmp.utils import (\n                file_to_dict,                                           \n            )\n    except Exception:                                \n        pytest.skip(\"libxmp not available or libexempi3 not installed\")\n    return file_to_dict", "func_code_string": "def libxmp_file_to_dict():\n    try:\n        with warnings.catch_warnings():\n                                                                   \n            warnings.filterwarnings(\n                \"ignore\",\n                category=DeprecationWarning,\n                message=r\".*distutils Version classes are deprecated.*\",\n            )\n            from libxmp.utils import (\n                file_to_dict,                                           \n            )\n    except Exception:                                \n        pytest.skip(\"libxmp not available or libexempi3 not installed\")\n    return file_to_dict", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_xml_metadata_preserved", "whole_func_string": "def test_xml_metadata_preserved(\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\n):\n    input_file = resources / test_file\n\n    before = libxmp_file_to_dict(str(input_file))\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after = libxmp_file_to_dict(str(outpdf))\n\n    equal_properties = [\n        'dc:contributor',\n        'dc:coverage',\n        'dc:creator',\n        'dc:description',\n        'dc:format',\n        'dc:identifier',\n        'dc:language',\n        'dc:publisher',\n        'dc:relation',\n        'dc:rights',\n        'dc:source',\n        'dc:subject',\n        'dc:title',\n        'dc:type',\n        'pdf:keywords',\n    ]\n    acquired_properties = ['dc:format']\n\n                                  \n                                                                           \n                                                \n    def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries\n\n                                                                         \n                                               \n    def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v\n\n    before = dict(keyval_from_tuple(unify_namespaces(before)))\n    after = dict(keyval_from_tuple(unify_namespaces(after)))\n\n    for prop in equal_properties:\n        if prop in before:\n            assert prop in after, f'{prop} dropped from xmp'\n            assert before[prop] == after[prop]\n\n                                                                 \n                                           \n                                                       \n                                                               \n        propidx = f'{prop}[1]'\n        if propidx in before:\n            assert (\n                after.get(propidx) == before[propidx]\n                or after.get(prop) == before[propidx]\n            )\n\n        if prop in after and prop not in before:\n            assert prop in acquired_properties, (\n                f\"acquired unexpected property {prop} with value \"\n                f\"{after.get(propidx) or after.get(prop)}\"\n            )", "func_code_string": "def test_xml_metadata_preserved(\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\n):\n    input_file = resources / test_file\n\n    before = libxmp_file_to_dict(str(input_file))\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after = libxmp_file_to_dict(str(outpdf))\n\n    equal_properties = [\n        'dc:contributor',\n        'dc:coverage',\n        'dc:creator',\n        'dc:description',\n        'dc:format',\n        'dc:identifier',\n        'dc:language',\n        'dc:publisher',\n        'dc:relation',\n        'dc:rights',\n        'dc:source',\n        'dc:subject',\n        'dc:title',\n        'dc:type',\n        'pdf:keywords',\n    ]\n    acquired_properties = ['dc:format']\n\n                                  \n                                                                           \n                                                \n    def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries\n\n                                                                         \n                                               \n    def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v\n\n    before = dict(keyval_from_tuple(unify_namespaces(before)))\n    after = dict(keyval_from_tuple(unify_namespaces(after)))\n\n    for prop in equal_properties:\n        if prop in before:\n            assert prop in after, f'{prop} dropped from xmp'\n            assert before[prop] == after[prop]\n\n                                                                 \n                                           \n                                                       \n                                                               \n        propidx = f'{prop}[1]'\n        if propidx in before:\n            assert (\n                after.get(propidx) == before[propidx]\n                or after.get(prop) == before[propidx]\n            )\n\n        if prop in after and prop not in before:\n            assert prop in acquired_properties, (\n                f\"acquired unexpected property {prop} with value \"\n                f\"{after.get(propidx) or after.get(prop)}\"\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_kodak_toc", "whole_func_string": "def test_kodak_toc(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'kcs.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outpdf) as p:\n        if pikepdf.Name.First in p.Root.Outlines:\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)", "func_code_string": "def test_kodak_toc(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'kcs.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outpdf) as p:\n        if pikepdf.Name.First in p.Root.Outlines:\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_metadata_fixup_warning", "whole_func_string": "def test_metadata_fixup_warning(resources, outdir, caplog):\n    _parser, options, _pm = get_parser_options_plugins(\n        ['--output-type', 'pdfa-2', 'graph.pdf', 'out.pdf']\n    )\n\n    copyfile(resources / 'graph.pdf', outdir / 'graph.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    for record in caplog.records:\n        assert record.levelname != 'WARNING', \"Unexpected warning\"\n\n                                                     \n    with pikepdf.open(outdir / 'graph.pdf') as graph:\n        with graph.open_metadata() as meta:\n            meta['prism2:publicationName'] = 'OCRmyPDF Test'\n        graph.save(outdir / 'graph_mod.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph_mod.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    assert any(record.levelname == 'WARNING' for record in caplog.records)", "func_code_string": "def test_metadata_fixup_warning(resources, outdir, caplog):\n    _parser, options, _pm = get_parser_options_plugins(\n        ['--output-type', 'pdfa-2', 'graph.pdf', 'out.pdf']\n    )\n\n    copyfile(resources / 'graph.pdf', outdir / 'graph.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    for record in caplog.records:\n        assert record.levelname != 'WARNING', \"Unexpected warning\"\n\n                                                     \n    with pikepdf.open(outdir / 'graph.pdf') as graph:\n        with graph.open_metadata() as meta:\n            meta['prism2:publicationName'] = 'OCRmyPDF Test'\n        graph.save(outdir / 'graph_mod.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph_mod.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    assert any(record.levelname == 'WARNING' for record in caplog.records)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_prevent_gs_invalid_xml", "whole_func_string": "def test_prevent_gs_invalid_xml(resources, outdir):\n    generate_pdfa_ps(outdir / 'pdfa.ps')\n\n                                                                         \n                                                          \n    with pikepdf.open(resources / 'trivial.pdf') as pdf:\n        pdf.Root.DocumentInfo = pikepdf.Dictionary(\n            Title=b'String with trailing nul\\x00'\n        )\n        pdf.save(outdir / 'layers.rendered.pdf', fix_metadata_version=False)\n\n    _, options, _ = get_parser_options_plugins(\n        args=[\n            '-j',\n            '1',\n            '--output-type',\n            'pdfa-2',\n            'a.pdf',\n            'b.pdf',\n        ]\n    )\n    pdfinfo = PdfInfo(outdir / 'layers.rendered.pdf')\n    context = PdfContext(\n        options, outdir, outdir / 'layers.rendered.pdf', pdfinfo, get_plugin_manager([])\n    )\n\n    convert_to_pdfa(\n        str(outdir / 'layers.rendered.pdf'), str(outdir / 'pdfa.ps'), context\n    )\n\n    contents = (outdir / 'pdfa.pdf').read_bytes()\n                                                                          \n                  \n\n    xmp_start = contents.find(XMP_MAGIC)\n    xmp_end = contents.rfind(b'<?xpacket end', xmp_start)\n    assert 0 < xmp_start < xmp_end\n                                              \n    assert contents.find(b'&#0;', xmp_start, xmp_end) == -1, \"found escaped nul\"\n    assert contents.find(b'\\x00', xmp_start, xmp_end) == -1", "func_code_string": "def test_prevent_gs_invalid_xml(resources, outdir):\n    generate_pdfa_ps(outdir / 'pdfa.ps')\n\n                                                                         \n                                                          \n    with pikepdf.open(resources / 'trivial.pdf') as pdf:\n        pdf.Root.DocumentInfo = pikepdf.Dictionary(\n            Title=b'String with trailing nul\\x00'\n        )\n        pdf.save(outdir / 'layers.rendered.pdf', fix_metadata_version=False)\n\n    _, options, _ = get_parser_options_plugins(\n        args=[\n            '-j',\n            '1',\n            '--output-type',\n            'pdfa-2',\n            'a.pdf',\n            'b.pdf',\n        ]\n    )\n    pdfinfo = PdfInfo(outdir / 'layers.rendered.pdf')\n    context = PdfContext(\n        options, outdir, outdir / 'layers.rendered.pdf', pdfinfo, get_plugin_manager([])\n    )\n\n    convert_to_pdfa(\n        str(outdir / 'layers.rendered.pdf'), str(outdir / 'pdfa.ps'), context\n    )\n\n    contents = (outdir / 'pdfa.pdf').read_bytes()\n                                                                          \n                  \n\n    xmp_start = contents.find(XMP_MAGIC)\n    xmp_end = contents.rfind(b'<?xpacket end', xmp_start)\n    assert 0 < xmp_start < xmp_end\n                                              \n    assert contents.find(b'&#0;', xmp_start, xmp_end) == -1, \"found escaped nul\"\n    assert contents.find(b'\\x00', xmp_start, xmp_end) == -1", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "unify_namespaces", "whole_func_string": "def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries", "func_code_string": "def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "keyval_from_tuple", "whole_func_string": "def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v", "func_code_string": "def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_semfree.py", "func_name": "test_semfree", "whole_func_string": "def test_semfree(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'multipage.pdf',\n        outpdf,\n        '--skip-text',\n        '--skip-big',\n        '2',\n        '--plugin',\n        'ocrmypdf.extra_plugins.semfree',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode in (ExitCode.ok, ExitCode.pdfa_conversion_failed)", "func_code_string": "def test_semfree(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'multipage.pdf',\n        outpdf,\n        '--skip-text',\n        '--skip-big',\n        '2',\n        '--plugin',\n        'ocrmypdf.extra_plugins.semfree',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode in (ExitCode.ok, ExitCode.pdfa_conversion_failed)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_deskew", "whole_func_string": "def test_deskew(resources, outdir):\n                     \n    deskewed_pdf = check_ocrmypdf(resources / 'skew.pdf', outdir / 'skew.pdf', '-d')\n\n                                     \n    deskewed_png = outdir / 'deskewed.png'\n\n    ghostscript.rasterize_pdf(\n        deskewed_pdf,\n        deskewed_png,\n        raster_device='pngmono',\n        raster_dpi=Resolution(150, 150),\n        pageno=1,\n    )\n\n                                                                               \n    skew_angle = tesseract.get_deskew(deskewed_png, [], None, 5.0)\n    print(skew_angle)\n    assert -0.5 < skew_angle < 0.5, \"Deskewing failed\"", "func_code_string": "def test_deskew(resources, outdir):\n                     \n    deskewed_pdf = check_ocrmypdf(resources / 'skew.pdf', outdir / 'skew.pdf', '-d')\n\n                                     \n    deskewed_png = outdir / 'deskewed.png'\n\n    ghostscript.rasterize_pdf(\n        deskewed_pdf,\n        deskewed_png,\n        raster_device='pngmono',\n        raster_dpi=Resolution(150, 150),\n        pageno=1,\n    )\n\n                                                                               \n    skew_angle = tesseract.get_deskew(deskewed_png, [], None, 5.0)\n    print(skew_angle)\n    assert -0.5 < skew_angle < 0.5, \"Deskewing failed\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_deskew_blank_page", "whole_func_string": "def test_deskew_blank_page(resources, outpdf):\n                                                                       \n    check_ocrmypdf(resources / 'blank.pdf', outpdf, '--deskew')", "func_code_string": "def test_deskew_blank_page(resources, outpdf):\n                                                                       \n    check_ocrmypdf(resources / 'blank.pdf', outpdf, '--deskew')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_remove_background", "whole_func_string": "def test_remove_background(resources, outdir):\n                                                              \n    with Image.open(resources / 'baiona_color.jpg') as im:\n        assert im.getextrema() != ((0, 255), (0, 255), (0, 255))\n\n    output_pdf = check_ocrmypdf(\n        resources / 'baiona_color.jpg',\n        outdir / 'test_remove_bg.pdf',\n        '--remove-background',\n        '--image-dpi',\n        '150',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    output_png = outdir / 'remove_bg.png'\n\n    ghostscript.rasterize_pdf(\n        output_pdf,\n        output_png,\n        raster_device='png16m',\n        raster_dpi=Resolution(100, 100),\n        pageno=1,\n    )\n\n                                                          \n    with Image.open(output_png) as im:\n        assert im.getextrema() == ((0, 255), (0, 255), (0, 255))", "func_code_string": "def test_remove_background(resources, outdir):\n                                                              \n    with Image.open(resources / 'baiona_color.jpg') as im:\n        assert im.getextrema() != ((0, 255), (0, 255), (0, 255))\n\n    output_pdf = check_ocrmypdf(\n        resources / 'baiona_color.jpg',\n        outdir / 'test_remove_bg.pdf',\n        '--remove-background',\n        '--image-dpi',\n        '150',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    output_png = outdir / 'remove_bg.png'\n\n    ghostscript.rasterize_pdf(\n        output_pdf,\n        output_png,\n        raster_device='png16m',\n        raster_dpi=Resolution(100, 100),\n        pageno=1,\n    )\n\n                                                          \n    with Image.open(output_png) as im:\n        assert im.getextrema() == ((0, 255), (0, 255), (0, 255))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_exotic_image", "whole_func_string": "def test_exotic_image(pdf, renderer, output_type, resources, outdir):\n    outfile = outdir / f'test_{pdf}_{renderer}.pdf'\n    check_ocrmypdf(\n        resources / pdf,\n        outfile,\n        '-dc' if have_unpaper() else '-d',\n        '-v',\n        '1',\n        '--output-type',\n        output_type,\n        '--sidecar',\n        '--skip-text',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    assert outfile.with_suffix('.pdf.txt').exists()", "func_code_string": "def test_exotic_image(pdf, renderer, output_type, resources, outdir):\n    outfile = outdir / f'test_{pdf}_{renderer}.pdf'\n    check_ocrmypdf(\n        resources / pdf,\n        outfile,\n        '-dc' if have_unpaper() else '-d',\n        '-v',\n        '1',\n        '--output-type',\n        output_type,\n        '--sidecar',\n        '--skip-text',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    assert outfile.with_suffix('.pdf.txt').exists()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_non_square_resolution", "whole_func_string": "def test_non_square_resolution(renderer, resources, outpdf):\n                                                  \n    in_pageinfo = PdfInfo(resources / 'aspect.pdf')\n    assert in_pageinfo[0].dpi.x != in_pageinfo[0].dpi.y\n\n    proc = run_ocrmypdf(\n        resources / 'aspect.pdf',\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n                                                                                   \n                            \n    if proc.returncode != ExitCode.pdfa_conversion_failed:\n        proc.check_returncode()\n\n    out_pageinfo = PdfInfo(outpdf)\n\n                                          \n    assert in_pageinfo[0].dpi == out_pageinfo[0].dpi", "func_code_string": "def test_non_square_resolution(renderer, resources, outpdf):\n                                                  \n    in_pageinfo = PdfInfo(resources / 'aspect.pdf')\n    assert in_pageinfo[0].dpi.x != in_pageinfo[0].dpi.y\n\n    proc = run_ocrmypdf(\n        resources / 'aspect.pdf',\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n                                                                                   \n                            \n    if proc.returncode != ExitCode.pdfa_conversion_failed:\n        proc.check_returncode()\n\n    out_pageinfo = PdfInfo(outpdf)\n\n                                          \n    assert in_pageinfo[0].dpi == out_pageinfo[0].dpi", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_preprocessing.py", "func_name": "test_convert_to_square_resolution", "whole_func_string": "def test_convert_to_square_resolution(renderer, resources, outpdf):\n                                                  \n    in_pageinfo = PdfInfo(resources / 'aspect.pdf')\n    assert in_pageinfo[0].dpi.x != in_pageinfo[0].dpi.y\n\n                                                                       \n    check_ocrmypdf(\n        resources / 'aspect.pdf',\n        outpdf,\n        '--force-ocr',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    out_pageinfo = PdfInfo(outpdf)\n\n    in_p0, out_p0 = in_pageinfo[0], out_pageinfo[0]\n\n                                  \n    assert out_p0.dpi.x == out_p0.dpi.y\n\n                                            \n    assert isclose(in_p0.width_inches, out_p0.width_inches)\n    assert isclose(in_p0.height_inches, out_p0.height_inches)\n\n                                                                             \n                     \n    out_im_w = out_p0.images[0].width / out_p0.images[0].dpi.x\n    out_im_h = out_p0.images[0].height / out_p0.images[0].dpi.y\n    assert isclose(out_p0.width_inches, out_im_w)\n    assert isclose(out_p0.height_inches, out_im_h)", "func_code_string": "def test_convert_to_square_resolution(renderer, resources, outpdf):\n                                                  \n    in_pageinfo = PdfInfo(resources / 'aspect.pdf')\n    assert in_pageinfo[0].dpi.x != in_pageinfo[0].dpi.y\n\n                                                                       \n    check_ocrmypdf(\n        resources / 'aspect.pdf',\n        outpdf,\n        '--force-ocr',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    out_pageinfo = PdfInfo(outpdf)\n\n    in_p0, out_p0 = in_pageinfo[0], out_pageinfo[0]\n\n                                  \n    assert out_p0.dpi.x == out_p0.dpi.y\n\n                                            \n    assert isclose(in_p0.width_inches, out_p0.width_inches)\n    assert isclose(in_p0.height_inches, out_p0.height_inches)\n\n                                                                             \n                     \n    out_im_w = out_p0.images[0].width / out_p0.images[0].dpi.x\n    out_im_h = out_p0.images[0].height / out_p0.images[0].dpi.y\n    assert isclose(out_p0.width_inches, out_im_w)\n    assert isclose(out_p0.height_inches, out_im_h)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "compare_images_monochrome", "whole_func_string": "def compare_images_monochrome(\n    outdir, reference_pdf, reference_pageno, test_pdf, test_pageno\n):\n    reference_png = outdir / f'{reference_pdf.name}.ref{reference_pageno:04d}.png'\n    test_png = outdir / f'{test_pdf.name}.test{test_pageno:04d}.png'\n\n    def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )\n\n    rasterize(reference_pdf, reference_pageno, reference_png)\n    rasterize(test_pdf, test_pageno, test_png)\n\n    with Image.open(reference_png) as reference_im, Image.open(test_png) as test_im:\n        assert reference_im.mode == test_im.mode == '1'\n        difference = ImageChops.logical_xor(reference_im, test_im)\n        assert difference.mode == '1'\n\n        histogram = difference.histogram()\n        assert (\n            len(histogram) == 256\n        ), \"Expected Pillow to convert to grayscale for histogram\"\n\n                                                         \n        count_same = histogram[0]\n        count_different = histogram[-1]\n        total = count_same + count_different\n\n        return count_same / (total)", "func_code_string": "def compare_images_monochrome(\n    outdir, reference_pdf, reference_pageno, test_pdf, test_pageno\n):\n    reference_png = outdir / f'{reference_pdf.name}.ref{reference_pageno:04d}.png'\n    test_png = outdir / f'{test_pdf.name}.test{test_pageno:04d}.png'\n\n    def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )\n\n    rasterize(reference_pdf, reference_pageno, reference_png)\n    rasterize(test_pdf, test_pageno, test_png)\n\n    with Image.open(reference_png) as reference_im, Image.open(test_png) as test_im:\n        assert reference_im.mode == test_im.mode == '1'\n        difference = ImageChops.logical_xor(reference_im, test_im)\n        assert difference.mode == '1'\n\n        histogram = difference.histogram()\n        assert (\n            len(histogram) == 256\n        ), \"Expected Pillow to convert to grayscale for histogram\"\n\n                                                         \n        count_same = histogram[0]\n        count_different = histogram[-1]\n        total = count_same + count_different\n\n        return count_same / (total)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_monochrome_comparison", "whole_func_string": "def test_monochrome_comparison(resources, outdir):\n                                                               \n                               \n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=1,                     \n        test_pdf=resources / 'cardinal.pdf',\n        test_pageno=3,                     \n    )\n    assert cmp < 0.90\n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=2,\n        test_pdf=resources / 'cardinal.pdf',\n        test_pageno=2,\n    )\n    assert cmp > 0.95", "func_code_string": "def test_monochrome_comparison(resources, outdir):\n                                                               \n                               \n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=1,                     \n        test_pdf=resources / 'cardinal.pdf',\n        test_pageno=3,                     \n    )\n    assert cmp < 0.90\n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=2,\n        test_pdf=resources / 'cardinal.pdf',\n        test_pageno=2,\n    )\n    assert cmp > 0.95", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_autorotate", "whole_func_string": "def test_autorotate(renderer, resources, outdir):\n                                                                            \n                                                                    \n    check_ocrmypdf(\n        resources / 'cardinal.pdf',\n        outdir / 'out.pdf',\n        '-r',\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    for n in range(1, 4 + 1):\n        cmp = compare_images_monochrome(\n            outdir,\n            reference_pdf=resources / 'cardinal.pdf',\n            reference_pageno=1,\n            test_pdf=outdir / 'out.pdf',\n            test_pageno=n,\n        )\n        assert cmp > 0.95", "func_code_string": "def test_autorotate(renderer, resources, outdir):\n                                                                            \n                                                                    \n    check_ocrmypdf(\n        resources / 'cardinal.pdf',\n        outdir / 'out.pdf',\n        '-r',\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    for n in range(1, 4 + 1):\n        cmp = compare_images_monochrome(\n            outdir,\n            reference_pdf=resources / 'cardinal.pdf',\n            reference_pageno=1,\n            test_pdf=outdir / 'out.pdf',\n            test_pageno=n,\n        )\n        assert cmp > 0.95", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_autorotate_threshold", "whole_func_string": "def test_autorotate_threshold(threshold, op, comparison_threshold, resources, outdir):\n    check_ocrmypdf(\n        resources / 'cardinal.pdf',\n        outdir / 'out.pdf',\n        '--rotate-pages-threshold',\n        threshold,\n        '-r',\n               \n              \n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    cmp = compare_images_monochrome(                                   \n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=1,\n        test_pdf=outdir / 'out.pdf',\n        test_pageno=3,\n    )\n\n    assert op(cmp, comparison_threshold)", "func_code_string": "def test_autorotate_threshold(threshold, op, comparison_threshold, resources, outdir):\n    check_ocrmypdf(\n        resources / 'cardinal.pdf',\n        outdir / 'out.pdf',\n        '--rotate-pages-threshold',\n        threshold,\n        '-r',\n               \n              \n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    cmp = compare_images_monochrome(                                   \n        outdir,\n        reference_pdf=resources / 'cardinal.pdf',\n        reference_pageno=1,\n        test_pdf=outdir / 'out.pdf',\n        test_pageno=3,\n    )\n\n    assert op(cmp, comparison_threshold)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_rotated_skew_timeout", "whole_func_string": "def test_rotated_skew_timeout(resources, outpdf):\n           \n    input_file = resources / 'rotated_skew.pdf'\n    in_pageinfo = PdfInfo(input_file)[0]\n\n    assert (\n        in_pageinfo.height_pixels < in_pageinfo.width_pixels\n    ), \"Expected the input page to be landscape\"\n    assert in_pageinfo.rotation == 90, \"Expected a rotated page\"\n\n    out = check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--pdf-renderer',\n        'hocr',\n        '--deskew',\n        '--tesseract-timeout',\n        '0',\n    )\n\n    out_pageinfo = PdfInfo(out)[0]\n    w, h = out_pageinfo.width_pixels, out_pageinfo.height_pixels\n\n    assert h > w, \"Expected the output page to be portrait\"\n\n    assert out_pageinfo.rotation == 0, \"Expected no page rotation for output\"\n\n    assert (\n        in_pageinfo.width_pixels == h and in_pageinfo.height_pixels == w\n    ), \"Expected page rotation to be baked in\"", "func_code_string": "def test_rotated_skew_timeout(resources, outpdf):\n           \n    input_file = resources / 'rotated_skew.pdf'\n    in_pageinfo = PdfInfo(input_file)[0]\n\n    assert (\n        in_pageinfo.height_pixels < in_pageinfo.width_pixels\n    ), \"Expected the input page to be landscape\"\n    assert in_pageinfo.rotation == 90, \"Expected a rotated page\"\n\n    out = check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--pdf-renderer',\n        'hocr',\n        '--deskew',\n        '--tesseract-timeout',\n        '0',\n    )\n\n    out_pageinfo = PdfInfo(out)[0]\n    w, h = out_pageinfo.width_pixels, out_pageinfo.height_pixels\n\n    assert h > w, \"Expected the output page to be portrait\"\n\n    assert out_pageinfo.rotation == 0, \"Expected no page rotation for output\"\n\n    assert (\n        in_pageinfo.width_pixels == h and in_pageinfo.height_pixels == w\n    ), \"Expected page rotation to be baked in\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_rotate_deskew_ocr_timeout", "whole_func_string": "def test_rotate_deskew_ocr_timeout(resources, outdir):\n    check_ocrmypdf(\n        resources / 'rotated_skew.pdf',\n        outdir / 'deskewed.pdf',\n        '--rotate-pages',\n        '--rotate-pages-threshold',\n        '0',\n        '--deskew',\n        '--tesseract-timeout',\n        '0',\n        '--pdf-renderer',\n        'hocr',\n    )\n\n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'ccitt.pdf',\n        reference_pageno=1,\n        test_pdf=outdir / 'deskewed.pdf',\n        test_pageno=1,\n    )\n\n                                              \n    assert cmp > 0.95", "func_code_string": "def test_rotate_deskew_ocr_timeout(resources, outdir):\n    check_ocrmypdf(\n        resources / 'rotated_skew.pdf',\n        outdir / 'deskewed.pdf',\n        '--rotate-pages',\n        '--rotate-pages-threshold',\n        '0',\n        '--deskew',\n        '--tesseract-timeout',\n        '0',\n        '--pdf-renderer',\n        'hocr',\n    )\n\n    cmp = compare_images_monochrome(\n        outdir,\n        reference_pdf=resources / 'ccitt.pdf',\n        reference_pageno=1,\n        test_pdf=outdir / 'deskewed.pdf',\n        test_pageno=1,\n    )\n\n                                              \n    assert cmp > 0.95", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "make_rotate_test", "whole_func_string": "def make_rotate_test(imagefile, outdir, prefix, image_angle, page_angle):\n    memimg = BytesIO()\n    with Image.open(fspath(imagefile)) as im:\n        if image_angle != 0:\n            ccw_angle = -image_angle % 360\n            im = im.transpose(getattr(Image.Transpose, f'ROTATE_{ccw_angle}'))\n        im.save(memimg, format='PNG')\n    memimg.seek(0)\n    mempdf = BytesIO()\n    img2pdf.convert(\n        memimg.read(),\n        layout_fun=img2pdf.get_fixed_dpi_layout_fun((200, 200)),\n        outputstream=mempdf,\n        **IMG2PDF_KWARGS,\n    )\n    mempdf.seek(0)\n    with pikepdf.open(mempdf) as pdf:\n        pdf.pages[0].Rotate = page_angle\n        target = outdir / f'{prefix}_{image_angle}_{page_angle}.pdf'\n        pdf.save(target)\n        return target", "func_code_string": "def make_rotate_test(imagefile, outdir, prefix, image_angle, page_angle):\n    memimg = BytesIO()\n    with Image.open(fspath(imagefile)) as im:\n        if image_angle != 0:\n            ccw_angle = -image_angle % 360\n            im = im.transpose(getattr(Image.Transpose, f'ROTATE_{ccw_angle}'))\n        im.save(memimg, format='PNG')\n    memimg.seek(0)\n    mempdf = BytesIO()\n    img2pdf.convert(\n        memimg.read(),\n        layout_fun=img2pdf.get_fixed_dpi_layout_fun((200, 200)),\n        outputstream=mempdf,\n        **IMG2PDF_KWARGS,\n    )\n    mempdf.seek(0)\n    with pikepdf.open(mempdf) as pdf:\n        pdf.pages[0].Rotate = page_angle\n        target = outdir / f'{prefix}_{image_angle}_{page_angle}.pdf'\n        pdf.save(target)\n        return target", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_rotate_page_level", "whole_func_string": "def test_rotate_page_level(image_angle, page_angle, resources, outdir, caplog):\n    reference = make_rotate_test(resources / 'typewriter.png', outdir, 'ref', 0, 0)\n    test = make_rotate_test(\n        resources / 'typewriter.png', outdir, 'test', image_angle, page_angle\n    )\n    out = test.with_suffix('.out.pdf')\n\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n        '--rotate-pages',\n        '--rotate-pages-threshold',\n        '0.001',\n    )\n    assert exitcode == 0, caplog.text\n\n    assert compare_images_monochrome(outdir, reference, 1, out, 1) > 0.2", "func_code_string": "def test_rotate_page_level(image_angle, page_angle, resources, outdir, caplog):\n    reference = make_rotate_test(resources / 'typewriter.png', outdir, 'ref', 0, 0)\n    test = make_rotate_test(\n        resources / 'typewriter.png', outdir, 'test', image_angle, page_angle\n    )\n    out = test.with_suffix('.out.pdf')\n\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n        '--rotate-pages',\n        '--rotate-pages-threshold',\n        '0.001',\n    )\n    assert exitcode == 0, caplog.text\n\n    assert compare_images_monochrome(outdir, reference, 1, out, 1) > 0.2", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_page_rotate_tag", "whole_func_string": "def test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\n                                                                            \n                                                                               \n    test = make_rotate_test(\n        resources / 'crom.png', outdir, 'test', -page_rotate_angle, page_rotate_angle\n    )\n    out = test.with_suffix('.out.pdf')\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n    )\n    assert exitcode == 0, caplog.text\n\n    def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )\n\n    test_text = pdftotext(out)\n    assert 'is a' in test_text, test_text", "func_code_string": "def test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\n                                                                            \n                                                                               \n    test = make_rotate_test(\n        resources / 'crom.png', outdir, 'test', -page_rotate_angle, page_rotate_angle\n    )\n    out = test.with_suffix('.out.pdf')\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n    )\n    assert exitcode == 0, caplog.text\n\n    def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )\n\n    test_text = pdftotext(out)\n    assert 'is a' in test_text, test_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_rasterize_rotates", "whole_func_string": "def test_rasterize_rotates(resources, tmp_path):\n    pm = get_plugin_manager([])\n\n    img = tmp_path / 'img90.png'\n    pm.hook.rasterize_pdf_page(\n        input_file=resources / 'graph.pdf',\n        output_file=img,\n        raster_device='pngmono',\n        raster_dpi=Resolution(20, 20),\n        page_dpi=Resolution(20, 20),\n        pageno=1,\n        rotation=90,\n        filter_vector=False,\n        stop_on_soft_error=True,\n    )\n    with Image.open(img) as im:\n        assert im.size == (83, 200), \"Image not rotated\"\n\n    img = tmp_path / 'img180.png'\n    pm.hook.rasterize_pdf_page(\n        input_file=resources / 'graph.pdf',\n        output_file=img,\n        raster_device='pngmono',\n        raster_dpi=Resolution(20, 20),\n        page_dpi=Resolution(20, 20),\n        pageno=1,\n        rotation=180,\n        filter_vector=False,\n        stop_on_soft_error=True,\n    )\n    assert Image.open(img).size == (200, 83), \"Image not rotated\"", "func_code_string": "def test_rasterize_rotates(resources, tmp_path):\n    pm = get_plugin_manager([])\n\n    img = tmp_path / 'img90.png'\n    pm.hook.rasterize_pdf_page(\n        input_file=resources / 'graph.pdf',\n        output_file=img,\n        raster_device='pngmono',\n        raster_dpi=Resolution(20, 20),\n        page_dpi=Resolution(20, 20),\n        pageno=1,\n        rotation=90,\n        filter_vector=False,\n        stop_on_soft_error=True,\n    )\n    with Image.open(img) as im:\n        assert im.size == (83, 200), \"Image not rotated\"\n\n    img = tmp_path / 'img180.png'\n    pm.hook.rasterize_pdf_page(\n        input_file=resources / 'graph.pdf',\n        output_file=img,\n        raster_device='pngmono',\n        raster_dpi=Resolution(20, 20),\n        page_dpi=Resolution(20, 20),\n        pageno=1,\n        rotation=180,\n        filter_vector=False,\n        stop_on_soft_error=True,\n    )\n    assert Image.open(img).size == (200, 83), \"Image not rotated\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_simulated_scan", "whole_func_string": "def test_simulated_scan(outdir):\n    canvas = Canvas(\n        fspath(outdir / 'fakescan.pdf'),\n        pagesize=(209.8, 297.6),\n    )\n\n    page_vars = [(2, 36, 250), (91, 170, 240), (179, 190, 36), (271, 36, 36)]\n\n    for n, page_var in enumerate(page_vars):\n        text = canvas.beginText()\n        text.setFont('Helvetica', 20)\n\n        angle, x, y = page_var\n        cos_a, sin_a = cos(angle / 180.0 * pi), sin(angle / 180.0 * pi)\n\n        text.setTextTransform(cos_a, -sin_a, sin_a, cos_a, x, y)\n        text.textOut(f'Page {n + 1}')\n        canvas.drawText(text)\n        canvas.showPage()\n    canvas.save()\n\n    check_ocrmypdf(\n        outdir / 'fakescan.pdf',\n        outdir / 'out.pdf',\n        '--force-ocr',\n        '--deskew',\n        '--rotate-pages',\n        '--plugin',\n        'tests/plugins/tesseract_debug_rotate.py',\n    )\n\n    with pikepdf.open(outdir / 'out.pdf') as pdf:\n        assert (\n            pdf.pages[1].mediabox[2] > pdf.pages[1].mediabox[3]\n        ), \"Wrong orientation: not landscape\"\n        assert (\n            pdf.pages[3].mediabox[2] > pdf.pages[3].mediabox[3]\n        ), \"Wrong orientation: Not landscape\"\n\n        assert (\n            pdf.pages[0].mediabox[2] < pdf.pages[0].mediabox[3]\n        ), \"Wrong orientation: Not portrait\"\n        assert (\n            pdf.pages[2].mediabox[2] < pdf.pages[2].mediabox[3]\n        ), \"Wrong orientation: Not portrait\"", "func_code_string": "def test_simulated_scan(outdir):\n    canvas = Canvas(\n        fspath(outdir / 'fakescan.pdf'),\n        pagesize=(209.8, 297.6),\n    )\n\n    page_vars = [(2, 36, 250), (91, 170, 240), (179, 190, 36), (271, 36, 36)]\n\n    for n, page_var in enumerate(page_vars):\n        text = canvas.beginText()\n        text.setFont('Helvetica', 20)\n\n        angle, x, y = page_var\n        cos_a, sin_a = cos(angle / 180.0 * pi), sin(angle / 180.0 * pi)\n\n        text.setTextTransform(cos_a, -sin_a, sin_a, cos_a, x, y)\n        text.textOut(f'Page {n + 1}')\n        canvas.drawText(text)\n        canvas.showPage()\n    canvas.save()\n\n    check_ocrmypdf(\n        outdir / 'fakescan.pdf',\n        outdir / 'out.pdf',\n        '--force-ocr',\n        '--deskew',\n        '--rotate-pages',\n        '--plugin',\n        'tests/plugins/tesseract_debug_rotate.py',\n    )\n\n    with pikepdf.open(outdir / 'out.pdf') as pdf:\n        assert (\n            pdf.pages[1].mediabox[2] > pdf.pages[1].mediabox[3]\n        ), \"Wrong orientation: not landscape\"\n        assert (\n            pdf.pages[3].mediabox[2] > pdf.pages[3].mediabox[3]\n        ), \"Wrong orientation: Not landscape\"\n\n        assert (\n            pdf.pages[0].mediabox[2] < pdf.pages[0].mediabox[3]\n        ), \"Wrong orientation: Not portrait\"\n        assert (\n            pdf.pages[2].mediabox[2] < pdf.pages[2].mediabox[3]\n        ), \"Wrong orientation: Not portrait\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "rasterize", "whole_func_string": "def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )", "func_code_string": "def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "pdftotext", "whole_func_string": "def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )", "func_code_string": "def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "single_page_text", "whole_func_string": "def single_page_text(outdir):\n    filename = outdir / 'text.pdf'\n    pdf = Canvas(str(filename), pagesize=(8 * inch, 6 * inch))\n    text = pdf.beginText()\n    text.setFont('Helvetica', 12)\n    text.setTextOrigin(1 * inch, 3 * inch)\n    text.textLine(\n        \"Methink'st thou art a general offence and every man should beat thee.\"\n    )\n    pdf.drawText(text)\n    pdf.showPage()\n    pdf.save()\n    return filename", "func_code_string": "def single_page_text(outdir):\n    filename = outdir / 'text.pdf'\n    pdf = Canvas(str(filename), pagesize=(8 * inch, 6 * inch))\n    text = pdf.beginText()\n    text.setFont('Helvetica', 12)\n    text.setTextOrigin(1 * inch, 3 * inch)\n    text.textLine(\n        \"Methink'st thou art a general offence and every man should beat thee.\"\n    )\n    pdf.drawText(text)\n    pdf.showPage()\n    pdf.save()\n    return filename", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_single_page_text", "whole_func_string": "def test_single_page_text(single_page_text):\n    info = pdfinfo.PdfInfo(single_page_text)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert page.has_text\n    assert len(page.images) == 0", "func_code_string": "def test_single_page_text(single_page_text):\n    info = pdfinfo.PdfInfo(single_page_text)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert page.has_text\n    assert len(page.images) == 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "eight_by_eight", "whole_func_string": "def eight_by_eight():\n    im = Image.new('1', (8, 8), 0)\n    for n in range(8):\n        im.putpixel((n, n), 1)\n    return im", "func_code_string": "def eight_by_eight():\n    im = Image.new('1', (8, 8), 0)\n    for n in range(8):\n        im.putpixel((n, n), 1)\n    return im", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "eight_by_eight_regular_image", "whole_func_string": "def eight_by_eight_regular_image(eight_by_eight, outpdf):\n    im = eight_by_eight\n    bio = BytesIO()\n    im.save(bio, format='PNG')\n    bio.seek(0)\n\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\n\n    with outpdf.open('wb') as f:\n        img2pdf.convert(\n            bio,\n            producer=\"img2pdf\",\n            layout_fun=layout_fun,\n            outputstream=f,\n            **IMG2PDF_KWARGS,\n        )\n    return outpdf", "func_code_string": "def eight_by_eight_regular_image(eight_by_eight, outpdf):\n    im = eight_by_eight\n    bio = BytesIO()\n    im.save(bio, format='PNG')\n    bio.seek(0)\n\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\n\n    with outpdf.open('wb') as f:\n        img2pdf.convert(\n            bio,\n            producer=\"img2pdf\",\n            layout_fun=layout_fun,\n            outputstream=f,\n            **IMG2PDF_KWARGS,\n        )\n    return outpdf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_single_page_image", "whole_func_string": "def test_single_page_image(eight_by_eight_regular_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert not page.has_text\n    assert len(page.images) == 1\n\n    pdfimage = page.images[0]\n    assert pdfimage.width == 8\n    assert pdfimage.color == Colorspace.gray\n\n                                       \n    assert isclose(pdfimage.dpi.x, 8)\n    assert isclose(pdfimage.dpi.y, 8)", "func_code_string": "def test_single_page_image(eight_by_eight_regular_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert not page.has_text\n    assert len(page.images) == 1\n\n    pdfimage = page.images[0]\n    assert pdfimage.width == 8\n    assert pdfimage.color == Colorspace.gray\n\n                                       \n    assert isclose(pdfimage.dpi.x, 8)\n    assert isclose(pdfimage.dpi.y, 8)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "eight_by_eight_inline_image", "whole_func_string": "def eight_by_eight_inline_image(eight_by_eight, outpdf):\n    pdf = Canvas(str(outpdf), pagesize=(8 * 72, 6 * 72))\n                                            \n    pdf.drawInlineImage(eight_by_eight, 0, 0, width=72, height=72)\n    pdf.showPage()\n    pdf.save()\n    return outpdf", "func_code_string": "def eight_by_eight_inline_image(eight_by_eight, outpdf):\n    pdf = Canvas(str(outpdf), pagesize=(8 * 72, 6 * 72))\n                                            \n    pdf.drawInlineImage(eight_by_eight, 0, 0, width=72, height=72)\n    pdf.showPage()\n    pdf.save()\n    return outpdf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_single_page_inline_image", "whole_func_string": "def test_single_page_inline_image(eight_by_eight_inline_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_inline_image)\n    print(info)\n    pdfimage = info[0].images[0]\n    assert isclose(pdfimage.dpi.x, 8)\n    assert pdfimage.color == Colorspace.gray\n    assert pdfimage.width == 8", "func_code_string": "def test_single_page_inline_image(eight_by_eight_inline_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_inline_image)\n    print(info)\n    pdfimage = info[0].images[0]\n    assert isclose(pdfimage.dpi.x, 8)\n    assert pdfimage.color == Colorspace.gray\n    assert pdfimage.width == 8", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_jpeg", "whole_func_string": "def test_jpeg(resources):\n    filename = resources / 'c02-22.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.enc == Encoding.jpeg\n    assert isclose(pdfimage.dpi.x, 150)", "func_code_string": "def test_jpeg(resources):\n    filename = resources / 'c02-22.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.enc == Encoding.jpeg\n    assert isclose(pdfimage.dpi.x, 150)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_form_xobject", "whole_func_string": "def test_form_xobject(resources):\n    filename = resources / 'formxobject.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.width == 50", "func_code_string": "def test_form_xobject(resources):\n    filename = resources / 'formxobject.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.width == 50", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_no_contents", "whole_func_string": "def test_no_contents(resources):\n    filename = resources / 'no_contents.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    assert len(pdf[0].images) == 0\n    assert not pdf[0].has_text", "func_code_string": "def test_no_contents(resources):\n    filename = resources / 'no_contents.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    assert len(pdf[0].images) == 0\n    assert not pdf[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_oversized_page", "whole_func_string": "def test_oversized_page(resources):\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\n    image = pdf[0].images[0]\n    assert image.width * image.dpi.x > 200, \"this is supposed to be oversized\"", "func_code_string": "def test_oversized_page(resources):\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\n    image = pdf[0].images[0]\n    assert image.width * image.dpi.x > 200, \"this is supposed to be oversized\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_pickle", "whole_func_string": "def test_pickle(resources):\n                                                                        \n                                                                         \n                                \n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    pickle.dumps(pdf)", "func_code_string": "def test_pickle(resources):\n                                                                        \n                                                                         \n                                \n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    pickle.dumps(pdf)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_vector", "whole_func_string": "def test_vector(resources):\n    filename = resources / 'vector.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    assert pdf[0].has_vector\n    assert not pdf[0].has_text", "func_code_string": "def test_vector(resources):\n    filename = resources / 'vector.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    assert pdf[0].has_vector\n    assert not pdf[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_ocr_detection", "whole_func_string": "def test_ocr_detection(resources):\n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    assert not pdf[0].has_vector\n    assert pdf[0].has_text", "func_code_string": "def test_ocr_detection(resources):\n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    assert not pdf[0].has_vector\n    assert pdf[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_corrupt_font_detection", "whole_func_string": "def test_corrupt_font_detection(resources, testfile):\n    filename = resources / testfile\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\n    assert pdf[0].has_corrupt_text", "func_code_string": "def test_corrupt_font_detection(resources, testfile):\n    filename = resources / testfile\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\n    assert pdf[0].has_corrupt_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_stack_abuse", "whole_func_string": "def test_stack_abuse():\n    p = pikepdf.Pdf.new()\n\n    stream = pikepdf.Stream(p, b'q ' * 35)\n    with pytest.warns(UserWarning, match=\"overflowed\"):\n        pdfinfo.info._interpret_contents(stream)\n\n    stream = pikepdf.Stream(p, b'q Q Q Q Q')\n    with pytest.warns(UserWarning, match=\"underflowed\"):\n        pdfinfo.info._interpret_contents(stream)\n\n    stream = pikepdf.Stream(p, b'q ' * 135)\n    with pytest.warns(UserWarning):\n        with pytest.raises(RuntimeError):\n            pdfinfo.info._interpret_contents(stream)", "func_code_string": "def test_stack_abuse():\n    p = pikepdf.Pdf.new()\n\n    stream = pikepdf.Stream(p, b'q ' * 35)\n    with pytest.warns(UserWarning, match=\"overflowed\"):\n        pdfinfo.info._interpret_contents(stream)\n\n    stream = pikepdf.Stream(p, b'q Q Q Q Q')\n    with pytest.warns(UserWarning, match=\"underflowed\"):\n        pdfinfo.info._interpret_contents(stream)\n\n    stream = pikepdf.Stream(p, b'q ' * 135)\n    with pytest.warns(UserWarning):\n        with pytest.raises(RuntimeError):\n            pdfinfo.info._interpret_contents(stream)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_pages_issue700", "whole_func_string": "def test_pages_issue700(monkeypatch, resources):\n    def get_no_pages(*args, **kwargs):\n        return iter([])\n\n    monkeypatch.setattr(PDFPage, 'get_pages', get_no_pages)\n\n    with pytest.raises(InputFileError, match=\"pdfminer\"):\n        pi = pdfinfo.PdfInfo(\n            resources / 'cardinal.pdf',\n            detailed_analysis=True,\n            progbar=False,\n            max_workers=1,\n        )\n        pi._miner_state.get_page_analysis(0)", "func_code_string": "def test_pages_issue700(monkeypatch, resources):\n    def get_no_pages(*args, **kwargs):\n        return iter([])\n\n    monkeypatch.setattr(PDFPage, 'get_pages', get_no_pages)\n\n    with pytest.raises(InputFileError, match=\"pdfminer\"):\n        pi = pdfinfo.PdfInfo(\n            resources / 'cardinal.pdf',\n            detailed_analysis=True,\n            progbar=False,\n            max_workers=1,\n        )\n        pi._miner_state.get_page_analysis(0)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "image_scale0", "whole_func_string": "def image_scale0(resources, outpdf):\n    with pikepdf.open(resources / 'cmyk.pdf') as cmyk:\n        xobj = cmyk.pages[0].as_form_xobject()\n\n        p = pikepdf.Pdf.new()\n        p.add_blank_page(page_size=(72, 72))\n        objname = p.pages[0].add_resource(\n            p.copy_foreign(xobj), pikepdf.Name.XObject, pikepdf.Name.Im0\n        )\n        print(objname)\n        p.pages[0].Contents = pikepdf.Stream(\n            p, b\"q 0 0 0 0 0 0 cm %s Do Q\" % bytes(objname)\n        )\n        p.save(outpdf)\n    return outpdf", "func_code_string": "def image_scale0(resources, outpdf):\n    with pikepdf.open(resources / 'cmyk.pdf') as cmyk:\n        xobj = cmyk.pages[0].as_form_xobject()\n\n        p = pikepdf.Pdf.new()\n        p.add_blank_page(page_size=(72, 72))\n        objname = p.pages[0].add_resource(\n            p.copy_foreign(xobj), pikepdf.Name.XObject, pikepdf.Name.Im0\n        )\n        print(objname)\n        p.pages[0].Contents = pikepdf.Stream(\n            p, b\"q 0 0 0 0 0 0 cm %s Do Q\" % bytes(objname)\n        )\n        p.save(outpdf)\n    return outpdf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_image_scale0", "whole_func_string": "def test_image_scale0(image_scale0):\n    pi = pdfinfo.PdfInfo(\n        image_scale0, detailed_analysis=True, progbar=False, max_workers=1\n    )\n    assert not pi.pages[0]._images[0].dpi.is_finite\n    assert pi.pages[0].dpi == Resolution(0, 0)", "func_code_string": "def test_image_scale0(image_scale0):\n    pi = pdfinfo.PdfInfo(\n        image_scale0, detailed_analysis=True, progbar=False, max_workers=1\n    )\n    assert not pi.pages[0]._images[0].dpi.is_finite\n    assert pi.pages[0].dpi == Resolution(0, 0)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "get_no_pages", "whole_func_string": "def get_no_pages(*args, **kwargs):\n        return iter([])", "func_code_string": "def get_no_pages(*args, **kwargs):\n        return iter([])", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "acroform", "whole_func_string": "def acroform(resources):\n    return resources / 'acroform.pdf'", "func_code_string": "def acroform(resources):\n    return resources / 'acroform.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "test_acroform_and_redo", "whole_func_string": "def test_acroform_and_redo(acroform, no_outpdf):\n    with pytest.raises(\n        ocrmypdf.exceptions.InputFileError, match='--redo-ocr is not currently possible'\n    ):\n        check_ocrmypdf(acroform, no_outpdf, '--redo-ocr')", "func_code_string": "def test_acroform_and_redo(acroform, no_outpdf):\n    with pytest.raises(\n        ocrmypdf.exceptions.InputFileError, match='--redo-ocr is not currently possible'\n    ):\n        check_ocrmypdf(acroform, no_outpdf, '--redo-ocr')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "test_acroform_message", "whole_func_string": "def test_acroform_message(acroform, caplog, outpdf):\n    caplog.set_level(logging.INFO)\n    check_ocrmypdf(acroform, outpdf, '--plugin', 'tests/plugins/tesseract_noop.py')\n    assert 'fillable form' in caplog.text\n    assert '--force-ocr' in caplog.text", "func_code_string": "def test_acroform_message(acroform, caplog, outpdf):\n    caplog.set_level(logging.INFO)\n    check_ocrmypdf(acroform, outpdf, '--plugin', 'tests/plugins/tesseract_noop.py')\n    assert 'fillable form' in caplog.text\n    assert '--force-ocr' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "digitally_signed", "whole_func_string": "def digitally_signed(acroform, outdir):\n    out = outdir / 'acroform_signed.pdf'\n    with pikepdf.open(acroform) as pdf:\n        pdf.Root.AcroForm.SigFlags = 3\n        pdf.save(out)\n    yield out", "func_code_string": "def digitally_signed(acroform, outdir):\n    out = outdir / 'acroform_signed.pdf'\n    with pikepdf.open(acroform) as pdf:\n        pdf.Root.AcroForm.SigFlags = 3\n        pdf.save(out)\n    yield out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "test_digital_signature", "whole_func_string": "def test_digital_signature(digitally_signed, no_outpdf):\n    with pytest.raises(ocrmypdf.exceptions.DigitalSignatureError):\n        check_ocrmypdf(digitally_signed, no_outpdf)", "func_code_string": "def test_digital_signature(digitally_signed, no_outpdf):\n    with pytest.raises(ocrmypdf.exceptions.DigitalSignatureError):\n        check_ocrmypdf(digitally_signed, no_outpdf)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "test_digital_signature_invalidate", "whole_func_string": "def test_digital_signature_invalidate(digitally_signed, no_outpdf):\n    check_ocrmypdf(\n        digitally_signed, no_outpdf, '--force-ocr', '--invalidate-digital-signatures'\n    )", "func_code_string": "def test_digital_signature_invalidate(digitally_signed, no_outpdf):\n    check_ocrmypdf(\n        digitally_signed, no_outpdf, '--force-ocr', '--invalidate-digital-signatures'\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_hocrtransform.py", "func_name": "text_from_pdf", "whole_func_string": "def text_from_pdf(filename):\n    output_string = StringIO()\n    with open(filename, 'rb') as in_file:\n        parser = PDFParser(in_file)\n        doc = PDFDocument(parser)\n        rsrcmgr = PDFResourceManager()\n        device = TextConverter(rsrcmgr, output_string, laparams=LAParams())\n        interpreter = PDFPageInterpreter(rsrcmgr, device)\n        for page in PDFPage.create_pages(doc):\n            interpreter.process_page(page)\n    return output_string.getvalue()", "func_code_string": "def text_from_pdf(filename):\n    output_string = StringIO()\n    with open(filename, 'rb') as in_file:\n        parser = PDFParser(in_file)\n        doc = PDFDocument(parser)\n        rsrcmgr = PDFResourceManager()\n        device = TextConverter(rsrcmgr, output_string, laparams=LAParams())\n        interpreter = PDFPageInterpreter(rsrcmgr, device)\n        for page in PDFPage.create_pages(doc):\n            interpreter.process_page(page)\n    return output_string.getvalue()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_hocrtransform.py", "func_name": "blank_hocr", "whole_func_string": "def blank_hocr(tmp_path):\n    im = Image.new('1', (8, 8), 0)\n    im.save(tmp_path / 'blank.tif', format='TIFF')\n    generate_hocr(\n        input_file=tmp_path / 'blank.tif',\n        output_hocr=tmp_path / 'blank.hocr',\n        output_text=tmp_path / 'blank.txt',\n        languages=['eng'],\n        engine_mode=1,\n        tessconfig=[],\n        pagesegmode=3,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n        timeout=None,\n    )\n    return tmp_path / 'blank.hocr'", "func_code_string": "def blank_hocr(tmp_path):\n    im = Image.new('1', (8, 8), 0)\n    im.save(tmp_path / 'blank.tif', format='TIFF')\n    generate_hocr(\n        input_file=tmp_path / 'blank.tif',\n        output_hocr=tmp_path / 'blank.hocr',\n        output_text=tmp_path / 'blank.txt',\n        languages=['eng'],\n        engine_mode=1,\n        tessconfig=[],\n        pagesegmode=3,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n        timeout=None,\n    )\n    return tmp_path / 'blank.hocr'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_hocrtransform.py", "func_name": "test_mono_image", "whole_func_string": "def test_mono_image(blank_hocr, outdir):\n    im = Image.new('1', (8, 8), 0)\n    for n in range(8):\n        im.putpixel((n, n), 1)\n    im.save(outdir / 'mono.tif', format='TIFF')\n\n    hocr = hocrtransform.HocrTransform(hocr_filename=str(blank_hocr), dpi=8)\n    hocr.to_pdf(\n        out_filename=str(outdir / 'mono.pdf'), image_filename=str(outdir / 'mono.tif')\n    )\n                                                  \n    check_pdf(str(outdir / 'mono.pdf'))", "func_code_string": "def test_mono_image(blank_hocr, outdir):\n    im = Image.new('1', (8, 8), 0)\n    for n in range(8):\n        im.putpixel((n, n), 1)\n    im.save(outdir / 'mono.tif', format='TIFF')\n\n    hocr = hocrtransform.HocrTransform(hocr_filename=str(blank_hocr), dpi=8)\n    hocr.to_pdf(\n        out_filename=str(outdir / 'mono.pdf'), image_filename=str(outdir / 'mono.tif')\n    )\n                                                  \n    check_pdf(str(outdir / 'mono.pdf'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_hocrtransform.py", "func_name": "test_hocrtransform_matches_sandwich", "whole_func_string": "def test_hocrtransform_matches_sandwich(resources, outdir):\n    check_ocrmypdf(resources / 'ccitt.pdf', outdir / 'hocr.pdf', '--pdf-renderer=hocr')\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outdir / 'tess.pdf', '--pdf-renderer=sandwich'\n    )\n\n                                                                                 \n                                          \n    def clean(s):\n        s = re.sub(r'\\s+', ' ', s)\n        words = s.split(' ')\n        return set(words)\n\n    hocr_words = clean(text_from_pdf(outdir / 'hocr.pdf'))\n    tess_words = clean(text_from_pdf(outdir / 'tess.pdf'))\n\n    similarity = len(hocr_words & tess_words) / len(hocr_words | tess_words)\n\n                              \n\n                                                                \n                                                                \n                                      \n                                                                     \n       \n\n    assert similarity > 0.99", "func_code_string": "def test_hocrtransform_matches_sandwich(resources, outdir):\n    check_ocrmypdf(resources / 'ccitt.pdf', outdir / 'hocr.pdf', '--pdf-renderer=hocr')\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outdir / 'tess.pdf', '--pdf-renderer=sandwich'\n    )\n\n                                                                                 \n                                          \n    def clean(s):\n        s = re.sub(r'\\s+', ' ', s)\n        words = s.split(' ')\n        return set(words)\n\n    hocr_words = clean(text_from_pdf(outdir / 'hocr.pdf'))\n    tess_words = clean(text_from_pdf(outdir / 'tess.pdf'))\n\n    similarity = len(hocr_words & tess_words) / len(hocr_words | tess_words)\n\n                              \n\n                                                                \n                                                                \n                                      \n                                                                     \n       \n\n    assert similarity > 0.99", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_hocrtransform.py", "func_name": "clean", "whole_func_string": "def clean(s):\n        s = re.sub(r'\\s+', ' ', s)\n        words = s.split(' ')\n        return set(words)", "func_code_string": "def clean(s):\n        s = re.sub(r'\\s+', ' ', s)\n        words = s.split(' ')\n        return set(words)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_userunit.py", "func_name": "poster", "whole_func_string": "def poster(resources):\n    return resources / 'poster.pdf'", "func_code_string": "def poster(resources):\n    return resources / 'poster.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_userunit.py", "func_name": "test_userunit_pdf_passes", "whole_func_string": "def test_userunit_pdf_passes(mode, poster, outpdf):\n    before = PdfInfo(poster)\n    check_ocrmypdf(\n        poster,\n        outpdf,\n        f'--output-type={mode}',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    after = PdfInfo(outpdf)\n    assert isclose(before[0].width_inches, after[0].width_inches)", "func_code_string": "def test_userunit_pdf_passes(mode, poster, outpdf):\n    before = PdfInfo(poster)\n    check_ocrmypdf(\n        poster,\n        outpdf,\n        f'--output-type={mode}',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    after = PdfInfo(outpdf)\n    assert isclose(before[0].width_inches, after[0].width_inches)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_userunit.py", "func_name": "test_rotate_interaction", "whole_func_string": "def test_rotate_interaction(poster, outpdf):\n    check_ocrmypdf(\n        poster,\n        outpdf,\n        '--output-type=pdf',\n        '--rotate-pages',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_code_string": "def test_rotate_interaction(poster, outpdf):\n    check_ocrmypdf(\n        poster,\n        outpdf,\n        '--output-type=pdf',\n        '--rotate-pages',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "francais", "whole_func_string": "def francais(resources):\n    path = resources / 'francais.pdf'\n    return path, pikepdf.open(path)", "func_code_string": "def francais(resources):\n    path = resources / 'francais.pdf'\n    return path, pikepdf.open(path)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_rasterize_size", "whole_func_string": "def test_rasterize_size(francais, outdir):\n    path, pdf = francais\n    page_size_pts = (pdf.pages[0].mediabox[2], pdf.pages[0].mediabox[3])\n    assert pdf.pages[0].mediabox[0] == pdf.pages[0].mediabox[1] == 0\n    page_size = (page_size_pts[0] / Decimal(72), page_size_pts[1] / Decimal(72))\n    target_size = Decimal('50.0'), Decimal('30.0')\n    forced_dpi = Resolution(42.0, 4242.0)\n\n    rasterize_pdf(\n        path,\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(\n            target_size[0] / page_size[0], target_size[1] / page_size[1]\n        ),\n        page_dpi=forced_dpi,\n    )\n\n    with Image.open(outdir / 'out.png') as im:\n        assert im.size == target_size\n        assert im.info['dpi'] == forced_dpi", "func_code_string": "def test_rasterize_size(francais, outdir):\n    path, pdf = francais\n    page_size_pts = (pdf.pages[0].mediabox[2], pdf.pages[0].mediabox[3])\n    assert pdf.pages[0].mediabox[0] == pdf.pages[0].mediabox[1] == 0\n    page_size = (page_size_pts[0] / Decimal(72), page_size_pts[1] / Decimal(72))\n    target_size = Decimal('50.0'), Decimal('30.0')\n    forced_dpi = Resolution(42.0, 4242.0)\n\n    rasterize_pdf(\n        path,\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(\n            target_size[0] / page_size[0], target_size[1] / page_size[1]\n        ),\n        page_dpi=forced_dpi,\n    )\n\n    with Image.open(outdir / 'out.png') as im:\n        assert im.size == target_size\n        assert im.info['dpi'] == forced_dpi", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_rasterize_rotated", "whole_func_string": "def test_rasterize_rotated(francais, outdir, caplog):\n    path, pdf = francais\n    page_size_pts = (pdf.pages[0].mediabox[2], pdf.pages[0].mediabox[3])\n    assert pdf.pages[0].mediabox[0] == pdf.pages[0].mediabox[1] == 0\n    page_size = (page_size_pts[0] / Decimal(72), page_size_pts[1] / Decimal(72))\n    target_size = Decimal('50.0'), Decimal('30.0')\n    forced_dpi = Resolution(42.0, 4242.0)\n\n    caplog.set_level(logging.DEBUG)\n    rasterize_pdf(\n        path,\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(\n            target_size[0] / page_size[0], target_size[1] / page_size[1]\n        ),\n        page_dpi=forced_dpi,\n        rotation=90,\n    )\n\n    with Image.open(outdir / 'out.png') as im:\n        assert im.size == (target_size[1], target_size[0])\n        assert im.info['dpi'] == forced_dpi.flip_axis()", "func_code_string": "def test_rasterize_rotated(francais, outdir, caplog):\n    path, pdf = francais\n    page_size_pts = (pdf.pages[0].mediabox[2], pdf.pages[0].mediabox[3])\n    assert pdf.pages[0].mediabox[0] == pdf.pages[0].mediabox[1] == 0\n    page_size = (page_size_pts[0] / Decimal(72), page_size_pts[1] / Decimal(72))\n    target_size = Decimal('50.0'), Decimal('30.0')\n    forced_dpi = Resolution(42.0, 4242.0)\n\n    caplog.set_level(logging.DEBUG)\n    rasterize_pdf(\n        path,\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(\n            target_size[0] / page_size[0], target_size[1] / page_size[1]\n        ),\n        page_dpi=forced_dpi,\n        rotation=90,\n    )\n\n    with Image.open(outdir / 'out.png') as im:\n        assert im.size == (target_size[1], target_size[0])\n        assert im.info['dpi'] == forced_dpi.flip_axis()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_gs_render_failure", "whole_func_string": "def test_gs_render_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'blank.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_failure.py',\n    )\n    assert 'TEST ERROR: gs_render_failure.py' in caplog.text\n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_gs_render_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'blank.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_failure.py',\n    )\n    assert 'TEST ERROR: gs_render_failure.py' in caplog.text\n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_gs_raster_failure", "whole_func_string": "def test_gs_raster_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_failure.py',\n    )\n    assert 'TEST ERROR: gs_raster_failure.py' in caplog.text\n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_gs_raster_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_failure.py',\n    )\n    assert 'TEST ERROR: gs_raster_failure.py' in caplog.text\n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_ghostscript_pdfa_failure", "whole_func_string": "def test_ghostscript_pdfa_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_pdfa_failure.py',\n    )\n    assert (\n        exitcode == ExitCode.pdfa_conversion_failed\n    ), \"Unexpected return when PDF/A fails\"", "func_code_string": "def test_ghostscript_pdfa_failure(resources, outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_pdfa_failure.py',\n    )\n    assert (\n        exitcode == ExitCode.pdfa_conversion_failed\n    ), \"Unexpected return when PDF/A fails\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_ghostscript_feature_elision", "whole_func_string": "def test_ghostscript_feature_elision(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_feature_elision.py',\n    )", "func_code_string": "def test_ghostscript_feature_elision(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_feature_elision.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_ghostscript_mandatory_color_conversion", "whole_func_string": "def test_ghostscript_mandatory_color_conversion(resources, outpdf):\n    with pytest.raises(ColorConversionNeededError):\n        check_ocrmypdf(\n            resources / 'jbig2_baddevicen.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_code_string": "def test_ghostscript_mandatory_color_conversion(resources, outpdf):\n    with pytest.raises(ColorConversionNeededError):\n        check_ocrmypdf(\n            resources / 'jbig2_baddevicen.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_rasterize_pdf_errors", "whole_func_string": "def test_rasterize_pdf_errors(resources, no_outpdf, caplog):\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n                                                                \n        mock.return_value = subprocess.CompletedProcess(\n            ['fakegs'], returncode=0, stdout=b'', stderr=b'error this is an error'\n        )\n        with pytest.raises(UnidentifiedImageError):\n            rasterize_pdf(\n                resources / 'francais.pdf',\n                no_outpdf,\n                raster_device='pngmono',\n                raster_dpi=Resolution(100, 100),\n            )\n        assert \"this is an error\" in caplog.text\n        assert \"invalid page image file\" in caplog.text", "func_code_string": "def test_rasterize_pdf_errors(resources, no_outpdf, caplog):\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n                                                                \n        mock.return_value = subprocess.CompletedProcess(\n            ['fakegs'], returncode=0, stdout=b'', stderr=b'error this is an error'\n        )\n        with pytest.raises(UnidentifiedImageError):\n            rasterize_pdf(\n                resources / 'francais.pdf',\n                no_outpdf,\n                raster_device='pngmono',\n                raster_dpi=Resolution(100, 100),\n            )\n        assert \"this is an error\" in caplog.text\n        assert \"invalid page image file\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "TestDuplicateFilter", "whole_func_string": "class TestDuplicateFilter:\n    @pytest.fixture(scope='function')\n    def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger\n\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"\n\n    def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"\n\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_code_string": "class TestDuplicateFilter:\n    @pytest.fixture(scope='function')\n    def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger\n\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"\n\n    def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"\n\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "pdf_with_invalid_image", "whole_func_string": "def pdf_with_invalid_image(outdir):\n                \n    Name = pikepdf.Name\n    pdf = pikepdf.new()\n    pdf.add_blank_page()\n    pdf.pages[0].Contents = pdf.make_stream(b'612 0 0 612 0 0 cm /Image Do')\n                                                                               \n    pdf.pages[0].Resources = pikepdf.Dictionary(\n        XObject=pdf.make_indirect(\n            pikepdf.Dictionary(\n                Image=pdf.make_stream(\n                    b\"\\xf0\\x0f\" * 8,\n                    ColorSpace=Name.DeviceGray,\n                    BitsPerComponent=1,\n                    Width=8,\n                    Height=8,\n                    ImageMask=True,\n                    Subtype=Name.Image,\n                    Type=Name.XObject,\n                )\n            )\n        )\n    )\n    pdf.save(outdir / 'invalid_image.pdf')\n    pdf.save('invalid_image.pdf')\n    return outdir / 'invalid_image.pdf'", "func_code_string": "def pdf_with_invalid_image(outdir):\n                \n    Name = pikepdf.Name\n    pdf = pikepdf.new()\n    pdf.add_blank_page()\n    pdf.pages[0].Contents = pdf.make_stream(b'612 0 0 612 0 0 cm /Image Do')\n                                                                               \n    pdf.pages[0].Resources = pikepdf.Dictionary(\n        XObject=pdf.make_indirect(\n            pikepdf.Dictionary(\n                Image=pdf.make_stream(\n                    b\"\\xf0\\x0f\" * 8,\n                    ColorSpace=Name.DeviceGray,\n                    BitsPerComponent=1,\n                    Width=8,\n                    Height=8,\n                    ImageMask=True,\n                    Subtype=Name.Image,\n                    Type=Name.XObject,\n                )\n            )\n        )\n    )\n    pdf.save(outdir / 'invalid_image.pdf')\n    pdf.save('invalid_image.pdf')\n    return outdir / 'invalid_image.pdf'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_recoverable_image_error", "whole_func_string": "def test_recoverable_image_error(pdf_with_invalid_image, outdir, caplog):\n                                                                          \n                  \n    rasterize_pdf(\n        outdir / 'invalid_image.pdf',\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(10, 10),\n        stop_on_error=False,\n    )\n    assert 'Image has both ImageMask and ColorSpace' in caplog.text", "func_code_string": "def test_recoverable_image_error(pdf_with_invalid_image, outdir, caplog):\n                                                                          \n                  \n    rasterize_pdf(\n        outdir / 'invalid_image.pdf',\n        outdir / 'out.png',\n        raster_device='pngmono',\n        raster_dpi=Resolution(10, 10),\n        stop_on_error=False,\n    )\n    assert 'Image has both ImageMask and ColorSpace' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_recoverable_image_error_with_stop", "whole_func_string": "def test_recoverable_image_error_with_stop(pdf_with_invalid_image, outdir, caplog):\n                                                                          \n                                                                        \n                                                                             \n                                 \n    with pytest.raises(\n        InputFileError, match=\"Try using --continue-on-soft-render-error\"\n    ):\n        rasterize_pdf(\n            outdir / 'invalid_image.pdf',\n            outdir / 'out.png',\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            stop_on_error=True,\n        )", "func_code_string": "def test_recoverable_image_error_with_stop(pdf_with_invalid_image, outdir, caplog):\n                                                                          \n                                                                        \n                                                                             \n                                 \n    with pytest.raises(\n        InputFileError, match=\"Try using --continue-on-soft-render-error\"\n    ):\n        rasterize_pdf(\n            outdir / 'invalid_image.pdf',\n            outdir / 'out.png',\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            stop_on_error=True,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "duplicate_filter_logger", "whole_func_string": "def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger", "func_code_string": "def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_filter_duplicate_messages", "whole_func_string": "def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"", "func_code_string": "def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_filter_does_not_affect_unique_messages", "whole_func_string": "def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"", "func_code_string": "def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "test_filter_alt_messages", "whole_func_string": "def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_code_string": "def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_no_unpaper", "whole_func_string": "def test_no_unpaper(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf._exec.unpaper.version\") as mock:\n        mock.side_effect = FileNotFoundError(\"unpaper\")\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_code_string": "def test_no_unpaper(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf._exec.unpaper.version\") as mock:\n        mock.side_effect = FileNotFoundError(\"unpaper\")\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_old_unpaper", "whole_func_string": "def test_old_unpaper(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf._exec.unpaper.version\") as mock:\n        mock.return_value = Version('0.5')\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_code_string": "def test_old_unpaper(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf._exec.unpaper.version\") as mock:\n        mock.return_value = Version('0.5')\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_version_chatter", "whole_func_string": "def test_unpaper_version_chatter(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf.subprocess.run\") as mock:\n        mock.return_value = Mock(stdout='Warning: using insecure memory!\\n7.0.0\\n')\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_code_string": "def test_unpaper_version_chatter(resources, no_outpdf):\n    input_ = fspath(resources / \"c02-22.pdf\")\n    output = fspath(no_outpdf)\n\n    _parser, options, pm = get_parser_options_plugins([\"--clean\", input_, output])\n    with patch(\"ocrmypdf.subprocess.run\") as mock:\n        mock.return_value = Mock(stdout='Warning: using insecure memory!\\n7.0.0\\n')\n\n        with pytest.raises(MissingDependencyError):\n            check_options(options, pm)\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_clean", "whole_func_string": "def test_clean(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_clean(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_args_valid", "whole_func_string": "def test_unpaper_args_valid(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"--layout double\",                        \n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_unpaper_args_valid(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"--layout double\",                        \n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_args_invalid_filename", "whole_func_string": "def test_unpaper_args_invalid_filename(resources, outpdf, caplog):\n    with pytest.raises(BadArgsError):\n        run_ocrmypdf_api(\n            resources / \"skew.pdf\",\n            outpdf,\n            \"-c\",\n            \"--unpaper-args\",\n            \"/etc/passwd\",\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_code_string": "def test_unpaper_args_invalid_filename(resources, outpdf, caplog):\n    with pytest.raises(BadArgsError):\n        run_ocrmypdf_api(\n            resources / \"skew.pdf\",\n            outpdf,\n            \"-c\",\n            \"--unpaper-args\",\n            \"/etc/passwd\",\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_args_invalid", "whole_func_string": "def test_unpaper_args_invalid(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"unpaper is not going to like these arguments\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n                                                                            \n                           \n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_unpaper_args_invalid(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"unpaper is not going to like these arguments\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n                                                                            \n                           \n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_image_too_big", "whole_func_string": "def test_unpaper_image_too_big(resources, outdir, caplog):\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\n        infile = resources / 'crom.png'\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\n\n        assert any(\n            'too large for cleaning' in rec.message\n            for rec in caplog.get_records('call')\n            if rec.levelno == logging.WARNING\n        )", "func_code_string": "def test_unpaper_image_too_big(resources, outdir, caplog):\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\n        infile = resources / 'crom.png'\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\n\n        assert any(\n            'too large for cleaning' in rec.message\n            for rec in caplog.get_records('call')\n            if rec.levelno == logging.WARNING\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_palette_image", "whole_func_string": "def test_palette_image(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"palette.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_palette_image(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"palette.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_annots.py", "func_name": "test_remove_broken_goto_annotations", "whole_func_string": "def test_remove_broken_goto_annotations(resources):\n    with Pdf.open(resources / 'link.pdf') as pdf:\n        assert not remove_broken_goto_annotations(pdf), \"File should not be modified\"\n\n                                  \n        nt = NameTree.new(pdf)\n        names = pdf.Root[Name.Names] = pdf.make_indirect(Dictionary())\n        names[Name.Dests] = nt.obj\n                                           \n        nt['Invalid'] = pdf.make_indirect(Dictionary())\n                                          \n        nt['Valid'] = Array([pdf.pages[0].obj, Name.XYZ, 0, 0, 0])\n\n        pdf.pages[0].Annots[0].A.D = 'Missing'\n        pdf.pages[1].Annots[0].A.D = 'Valid'\n\n        assert remove_broken_goto_annotations(pdf), \"File should be modified\"\n\n        assert Name.D not in pdf.pages[0].Annots[0].A\n        assert Name.D in pdf.pages[1].Annots[0].A", "func_code_string": "def test_remove_broken_goto_annotations(resources):\n    with Pdf.open(resources / 'link.pdf') as pdf:\n        assert not remove_broken_goto_annotations(pdf), \"File should not be modified\"\n\n                                  \n        nt = NameTree.new(pdf)\n        names = pdf.Root[Name.Names] = pdf.make_indirect(Dictionary())\n        names[Name.Dests] = nt.obj\n                                           \n        nt['Invalid'] = pdf.make_indirect(Dictionary())\n                                          \n        nt['Valid'] = Array([pdf.pages[0].obj, Name.XYZ, 0, 0, 0])\n\n        pdf.pages[0].Annots[0].A.D = 'Missing'\n        pdf.pages[1].Annots[0].A.D = 'Valid'\n\n        assert remove_broken_goto_annotations(pdf), \"File should be modified\"\n\n        assert Name.D not in pdf.pages[0].Annots[0].A\n        assert Name.D in pdf.pages[1].Annots[0].A", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_skip_pages_does_not_replicate", "whole_func_string": "def test_skip_pages_does_not_replicate(resources, basename, outdir):\n    infile = resources / basename\n    outpdf = outdir / basename\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        'sandwich',\n        '--force-ocr',\n        '--tesseract-timeout',\n        '0',\n    )\n\n    info_in = pdfinfo.PdfInfo(infile)\n\n    info = pdfinfo.PdfInfo(outpdf)\n    for page in info:\n        assert len(page.images) == 1, \"skipped page was replicated\"\n\n    for n, info_out_n in enumerate(info):\n        assert info_out_n.width_inches == info_in[n].width_inches, \"output resized\"\n        assert info_out_n.height_inches == info_in[n].height_inches, \"output resized\"", "func_code_string": "def test_skip_pages_does_not_replicate(resources, basename, outdir):\n    infile = resources / basename\n    outpdf = outdir / basename\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        'sandwich',\n        '--force-ocr',\n        '--tesseract-timeout',\n        '0',\n    )\n\n    info_in = pdfinfo.PdfInfo(infile)\n\n    info = pdfinfo.PdfInfo(outpdf)\n    for page in info:\n        assert len(page.images) == 1, \"skipped page was replicated\"\n\n    for n, info_out_n in enumerate(info):\n        assert info_out_n.width_inches == info_in[n].width_inches, \"output resized\"\n        assert info_out_n.height_inches == info_in[n].height_inches, \"output resized\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_content_preservation", "whole_func_string": "def test_content_preservation(resources, outpdf):\n    infile = resources / 'masks.pdf'\n\n    check_ocrmypdf(infile, outpdf, '--pdf-renderer', 'hocr', '--tesseract-timeout', '0')\n\n    info = pdfinfo.PdfInfo(outpdf)\n    page = info[0]\n    assert len(page.images) > 1, \"masks were rasterized\"", "func_code_string": "def test_content_preservation(resources, outpdf):\n    infile = resources / 'masks.pdf'\n\n    check_ocrmypdf(infile, outpdf, '--pdf-renderer', 'hocr', '--tesseract-timeout', '0')\n\n    info = pdfinfo.PdfInfo(outpdf)\n    page = info[0]\n    assert len(page.images) > 1, \"masks were rasterized\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_no_languages", "whole_func_string": "def test_no_languages(tmp_path, monkeypatch):\n    (tmp_path / 'tessdata').mkdir()\n    monkeypatch.setenv('TESSDATA_PREFIX', fspath(tmp_path))\n    with pytest.raises(MissingDependencyError):\n        tesseract.get_languages()", "func_code_string": "def test_no_languages(tmp_path, monkeypatch):\n    (tmp_path / 'tessdata').mkdir()\n    monkeypatch.setenv('TESSDATA_PREFIX', fspath(tmp_path))\n    with pytest.raises(MissingDependencyError):\n        tesseract.get_languages()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_image_too_large_hocr", "whole_func_string": "def test_image_too_large_hocr(monkeypatch, resources, outdir):\n    def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\n\n    monkeypatch.setattr(tesseract, 'run', dummy_run)\n    tesseract.generate_hocr(\n        input_file=resources / 'crom.png',\n        output_hocr=outdir / 'out.hocr',\n        output_text=outdir / 'out.txt',\n        languages=['eng'],\n        engine_mode=None,\n        tessconfig=[],\n        timeout=180.0,\n        pagesegmode=None,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n    )\n    assert Path(outdir / 'out.hocr').read_text() == ''", "func_code_string": "def test_image_too_large_hocr(monkeypatch, resources, outdir):\n    def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\n\n    monkeypatch.setattr(tesseract, 'run', dummy_run)\n    tesseract.generate_hocr(\n        input_file=resources / 'crom.png',\n        output_hocr=outdir / 'out.hocr',\n        output_text=outdir / 'out.txt',\n        languages=['eng'],\n        engine_mode=None,\n        tessconfig=[],\n        timeout=180.0,\n        pagesegmode=None,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n    )\n    assert Path(outdir / 'out.hocr').read_text() == ''", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_image_too_large_pdf", "whole_func_string": "def test_image_too_large_pdf(monkeypatch, resources, outdir):\n    def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\n\n    monkeypatch.setattr(tesseract, 'run', dummy_run)\n    tesseract.generate_pdf(\n        input_file=resources / 'crom.png',\n        output_pdf=outdir / 'pdf.pdf',\n        output_text=outdir / 'txt.txt',\n        languages=['eng'],\n        engine_mode=None,\n        tessconfig=[],\n        timeout=180.0,\n        pagesegmode=None,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n    )\n    assert Path(outdir / 'txt.txt').read_text() == '[skipped page]'\n    if os.name != 'nt':                       \n        assert Path(outdir / 'pdf.pdf').stat().st_size == 0", "func_code_string": "def test_image_too_large_pdf(monkeypatch, resources, outdir):\n    def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\n\n    monkeypatch.setattr(tesseract, 'run', dummy_run)\n    tesseract.generate_pdf(\n        input_file=resources / 'crom.png',\n        output_pdf=outdir / 'pdf.pdf',\n        output_text=outdir / 'txt.txt',\n        languages=['eng'],\n        engine_mode=None,\n        tessconfig=[],\n        timeout=180.0,\n        pagesegmode=None,\n        thresholding=0,\n        user_words=None,\n        user_patterns=None,\n    )\n    assert Path(outdir / 'txt.txt').read_text() == '[skipped page]'\n    if os.name != 'nt':                       \n        assert Path(outdir / 'pdf.pdf').stat().st_size == 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_timeout", "whole_func_string": "def test_timeout(caplog):\n    tesseract.page_timedout(5)\n    assert \"took too long\" in caplog.text", "func_code_string": "def test_timeout(caplog):\n    tesseract.page_timedout(5)\n    assert \"took too long\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_tesseract_log_output", "whole_func_string": "def test_tesseract_log_output(caplog, in_, logged):\n    caplog.set_level(logging.INFO)\n    tesseract.tesseract_log_output(in_)\n    if logged == '':\n        assert caplog.text == ''\n    else:\n        assert logged in caplog.text", "func_code_string": "def test_tesseract_log_output(caplog, in_, logged):\n    caplog.set_level(logging.INFO)\n    tesseract.tesseract_log_output(in_)\n    if logged == '':\n        assert caplog.text == ''\n    else:\n        assert logged in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_tesseract_log_output_raises", "whole_func_string": "def test_tesseract_log_output_raises(caplog):\n    with pytest.raises(tesseract.TesseractConfigError):\n        tesseract.tesseract_log_output(b'parameter not found: moo')\n    assert 'not found' in caplog.text", "func_code_string": "def test_tesseract_log_output_raises(caplog):\n    with pytest.raises(tesseract.TesseractConfigError):\n        tesseract.tesseract_log_output(b'parameter not found: moo')\n    assert 'not found' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_blocked_language", "whole_func_string": "def test_blocked_language(resources, no_outpdf):\n    infile = resources / 'masks.pdf'\n    for bad_lang in ['osd', 'equ']:\n        with pytest.raises(BadArgsError):\n            run_ocrmypdf_api(infile, no_outpdf, '-l', bad_lang)", "func_code_string": "def test_blocked_language(resources, no_outpdf):\n    infile = resources / 'masks.pdf'\n    for bad_lang in ['osd', 'equ']:\n        with pytest.raises(BadArgsError):\n            run_ocrmypdf_api(infile, no_outpdf, '-l', bad_lang)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "dummy_run", "whole_func_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_code_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "dummy_run", "whole_func_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_code_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_imageops.py", "func_name": "test_bytes_per_pixel", "whole_func_string": "def test_bytes_per_pixel():\n    assert bytes_per_pixel('RGB') == 4\n    assert bytes_per_pixel('RGBA') == 4\n    assert bytes_per_pixel('LA') == 2\n    assert bytes_per_pixel('L') == 1", "func_code_string": "def test_bytes_per_pixel():\n    assert bytes_per_pixel('RGB') == 4\n    assert bytes_per_pixel('RGBA') == 4\n    assert bytes_per_pixel('LA') == 2\n    assert bytes_per_pixel('L') == 1", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_imageops.py", "func_name": "test_calculate_downsample", "whole_func_string": "def test_calculate_downsample():\n    im = Image.new('RGB', (100, 100))\n    assert calculate_downsample(im, max_size=(50, 50)) == (50, 50)\n    assert calculate_downsample(im, max_pixels=2500) == (50, 50)\n    assert calculate_downsample(im, max_bytes=10000) == (50, 50)\n    assert calculate_downsample(im, max_bytes=100000) == (100, 100)", "func_code_string": "def test_calculate_downsample():\n    im = Image.new('RGB', (100, 100))\n    assert calculate_downsample(im, max_size=(50, 50)) == (50, 50)\n    assert calculate_downsample(im, max_pixels=2500) == (50, 50)\n    assert calculate_downsample(im, max_bytes=10000) == (50, 50)\n    assert calculate_downsample(im, max_bytes=100000) == (100, 100)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_imageops.py", "func_name": "test_calculate_downsample_hypothesis", "whole_func_string": "def test_calculate_downsample_hypothesis(mode, im_w, im_h, max_x, max_y, max_bytes):\n    result = _calculate_downsample(\n        (im_w, im_h),\n        bytes_per_pixel(mode),\n        max_size=(max_x, max_y),\n        max_bytes=max_bytes,\n    )\n    assert result[0] <= max_x\n    assert result[1] <= max_y\n    assert result[0] * result[1] * bytes_per_pixel(mode) <= max_bytes", "func_code_string": "def test_calculate_downsample_hypothesis(mode, im_w, im_h, max_x, max_y, max_bytes):\n    result = _calculate_downsample(\n        (im_w, im_h),\n        bytes_per_pixel(mode),\n        max_size=(max_x, max_y),\n        max_bytes=max_bytes,\n    )\n    assert result[0] <= max_x\n    assert result[1] <= max_y\n    assert result[0] * result[1] * bytes_per_pixel(mode) <= max_bytes", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_imageops.py", "func_name": "test_downsample_image", "whole_func_string": "def test_downsample_image():\n    im = Image.new('RGB', (100, 100))\n    im.info['dpi'] = (300, 300)\n    ds = downsample_image(im, (50, 50))\n    assert ds.size == (50, 50)\n    assert ds.info['dpi'] == (150, 150)", "func_code_string": "def test_downsample_image():\n    im = Image.new('RGB', (100, 100))\n    im.info['dpi'] = (300, 300)\n    ds = downsample_image(im, (50, 50))\n    assert ds.size == (50, 50)\n    assert ds.info['dpi'] == (150, 150)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_page_numbers.py", "func_name": "test_pages", "whole_func_string": "def test_pages(pages, result):\n    if isinstance(result, type):\n        with pytest.raises(result):\n            _pages_from_ranges(pages)\n    else:\n        assert _pages_from_ranges(pages) == result", "func_code_string": "def test_pages(pages, result):\n    if isinstance(result, type):\n        with pytest.raises(result):\n            _pages_from_ranges(pages)\n    else:\n        assert _pages_from_ranges(pages) == result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_page_numbers.py", "func_name": "test_nonmonotonic_warning", "whole_func_string": "def test_nonmonotonic_warning(caplog):\n    pages = _pages_from_ranges('1, 3, 2')\n    assert pages == {0, 1, 2}\n    assert 'out of order' in caplog.text", "func_code_string": "def test_nonmonotonic_warning(caplog):\n    pages = _pages_from_ranges('1, 3, 2')\n    assert pages == {0, 1, 2}\n    assert 'out of order' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_page_numbers.py", "func_name": "test_limited_pages", "whole_func_string": "def test_limited_pages(multipage, outpdf):\n    ocrmypdf.ocr(\n        multipage,\n        outpdf,\n        pages='5-6',\n        optimize=0,\n        output_type='pdf',\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    pi = PdfInfo(outpdf)\n    assert not pi.pages[0].has_text\n    assert pi.pages[4].has_text\n    assert pi.pages[5].has_text", "func_code_string": "def test_limited_pages(multipage, outpdf):\n    ocrmypdf.ocr(\n        multipage,\n        outpdf,\n        pages='5-6',\n        optimize=0,\n        output_type='pdf',\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    pi = PdfInfo(outpdf)\n    assert not pi.pages[0].has_text\n    assert pi.pages[4].has_text\n    assert pi.pages[5].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "TestSafeSymlink", "whole_func_string": "class TestSafeSymlink:\n    def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING\n\n    def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n\n    @needs_symlink\n    def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_code_string": "class TestSafeSymlink:\n    def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING\n\n    def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n\n    @needs_symlink\n    def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_no_cpu_count", "whole_func_string": "def test_no_cpu_count(monkeypatch):\n    invoked = False\n\n    def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()\n\n    monkeypatch.setattr(multiprocessing, 'cpu_count', cpu_count_raises)\n    with pytest.warns(expected_warning=UserWarning):\n        assert helpers.available_cpu_count() == 1\n    assert invoked, \"Patched function called during test\"", "func_code_string": "def test_no_cpu_count(monkeypatch):\n    invoked = False\n\n    def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()\n\n    monkeypatch.setattr(multiprocessing, 'cpu_count', cpu_count_raises)\n    with pytest.warns(expected_warning=UserWarning):\n        assert helpers.available_cpu_count() == 1\n    assert invoked, \"Patched function called during test\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "TestFileIsWritable", "whole_func_string": "class TestFileIsWritable:\n    @pytest.fixture\n    def non_existent(self, tmp_path):\n        return tmp_path / 'nofile'\n\n    @pytest.fixture\n    def basic_file(self, tmp_path):\n        basic = tmp_path / 'basic'\n        basic.touch()\n        return basic\n\n    def test_plain(self, non_existent):\n        assert helpers.is_file_writable(non_existent)\n\n    @needs_symlink\n    def test_symlink_loop(self, tmp_path):\n        loop = tmp_path / 'loop'\n        loop.symlink_to(loop)\n        assert not helpers.is_file_writable(loop)\n\n    @skipif_docker\n    def test_chmod(self, basic_file):\n        assert helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o400)\n        assert not helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o000)\n        assert not helpers.is_file_writable(basic_file)\n\n    def test_permission_error(self, basic_file):\n        pathmock = MagicMock(spec_set=basic_file)\n        pathmock.is_symlink.return_value = False\n        pathmock.exists.return_value = True\n        pathmock.is_file.side_effect = PermissionError\n        assert not helpers.is_file_writable(pathmock)", "func_code_string": "class TestFileIsWritable:\n    @pytest.fixture\n    def non_existent(self, tmp_path):\n        return tmp_path / 'nofile'\n\n    @pytest.fixture\n    def basic_file(self, tmp_path):\n        basic = tmp_path / 'basic'\n        basic.touch()\n        return basic\n\n    def test_plain(self, non_existent):\n        assert helpers.is_file_writable(non_existent)\n\n    @needs_symlink\n    def test_symlink_loop(self, tmp_path):\n        loop = tmp_path / 'loop'\n        loop.symlink_to(loop)\n        assert not helpers.is_file_writable(loop)\n\n    @skipif_docker\n    def test_chmod(self, basic_file):\n        assert helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o400)\n        assert not helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o000)\n        assert not helpers.is_file_writable(basic_file)\n\n    def test_permission_error(self, basic_file):\n        pathmock = MagicMock(spec_set=basic_file)\n        pathmock.is_symlink.return_value = False\n        pathmock.exists.return_value = True\n        pathmock.is_file.side_effect = PermissionError\n        assert not helpers.is_file_writable(pathmock)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_gs_install_locations", "whole_func_string": "def test_gs_install_locations():\n                                             \n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\n\n    assert _gs_version_in_path_key(Path(\"C:\\\\Program Files\\\\gs\\\\gs9.52\\\\bin\")) == (\n        'gs',\n        Version('9.52'),\n    )", "func_code_string": "def test_gs_install_locations():\n                                             \n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\n\n    assert _gs_version_in_path_key(Path(\"C:\\\\Program Files\\\\gs\\\\gs9.52\\\\bin\")) == (\n        'gs',\n        Version('9.52'),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_shim_paths", "whole_func_string": "def test_shim_paths(tmp_path):\n                                             \n    from ocrmypdf.subprocess._windows import shim_env_path\n\n    progfiles = tmp_path / 'Program Files'\n    progfiles.mkdir()\n    (progfiles / 'tesseract-ocr').mkdir()\n    (progfiles / 'gs' / '9.51' / 'bin').mkdir(parents=True)\n    (progfiles / 'gs' / 'gs9.52.3' / 'bin').mkdir(parents=True)\n    syspath = tmp_path / 'bin'\n    env = {'PROGRAMFILES': str(progfiles), 'PATH': str(syspath)}\n\n    result_str = shim_env_path(env=env)\n    results = result_str.split(os.pathsep)\n    assert results[0] == str(syspath), results\n    assert results[-3].endswith('tesseract-ocr'), results\n    assert results[-2].endswith(os.path.join('gs9.52.3', 'bin')), results\n    assert results[-1].endswith(os.path.join('gs', '9.51', 'bin')), results", "func_code_string": "def test_shim_paths(tmp_path):\n                                             \n    from ocrmypdf.subprocess._windows import shim_env_path\n\n    progfiles = tmp_path / 'Program Files'\n    progfiles.mkdir()\n    (progfiles / 'tesseract-ocr').mkdir()\n    (progfiles / 'gs' / '9.51' / 'bin').mkdir(parents=True)\n    (progfiles / 'gs' / 'gs9.52.3' / 'bin').mkdir(parents=True)\n    syspath = tmp_path / 'bin'\n    env = {'PROGRAMFILES': str(progfiles), 'PATH': str(syspath)}\n\n    result_str = shim_env_path(env=env)\n    results = result_str.split(os.pathsep)\n    assert results[0] == str(syspath), results\n    assert results[-3].endswith('tesseract-ocr'), results\n    assert results[-2].endswith(os.path.join('gs9.52.3', 'bin')), results\n    assert results[-1].endswith(os.path.join('gs', '9.51', 'bin')), results", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_resolution", "whole_func_string": "def test_resolution():\n    Resolution = helpers.Resolution\n    dpi_100 = Resolution(100, 100)\n    dpi_200 = Resolution(200, 200)\n    assert dpi_100.is_square\n    assert not Resolution(100, 200).is_square\n    assert dpi_100 == Resolution(100, 100)\n    assert str(dpi_100) != str(dpi_200)\n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400)", "func_code_string": "def test_resolution():\n    Resolution = helpers.Resolution\n    dpi_100 = Resolution(100, 100)\n    dpi_200 = Resolution(200, 200)\n    assert dpi_100.is_square\n    assert not Resolution(100, 200).is_square\n    assert dpi_100 == Resolution(100, 100)\n    assert str(dpi_100) != str(dpi_200)\n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_safe_symlink_link_self", "whole_func_string": "def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING", "func_code_string": "def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_safe_symlink_overwrite", "whole_func_string": "def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')", "func_code_string": "def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_safe_symlink_relink", "whole_func_string": "def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_code_string": "def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "cpu_count_raises", "whole_func_string": "def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()", "func_code_string": "def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "non_existent", "whole_func_string": "def non_existent(self, tmp_path):\n        return tmp_path / 'nofile'", "func_code_string": "def non_existent(self, tmp_path):\n        return tmp_path / 'nofile'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "basic_file", "whole_func_string": "def basic_file(self, tmp_path):\n        basic = tmp_path / 'basic'\n        basic.touch()\n        return basic", "func_code_string": "def basic_file(self, tmp_path):\n        basic = tmp_path / 'basic'\n        basic.touch()\n        return basic", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_plain", "whole_func_string": "def test_plain(self, non_existent):\n        assert helpers.is_file_writable(non_existent)", "func_code_string": "def test_plain(self, non_existent):\n        assert helpers.is_file_writable(non_existent)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_symlink_loop", "whole_func_string": "def test_symlink_loop(self, tmp_path):\n        loop = tmp_path / 'loop'\n        loop.symlink_to(loop)\n        assert not helpers.is_file_writable(loop)", "func_code_string": "def test_symlink_loop(self, tmp_path):\n        loop = tmp_path / 'loop'\n        loop.symlink_to(loop)\n        assert not helpers.is_file_writable(loop)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_chmod", "whole_func_string": "def test_chmod(self, basic_file):\n        assert helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o400)\n        assert not helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o000)\n        assert not helpers.is_file_writable(basic_file)", "func_code_string": "def test_chmod(self, basic_file):\n        assert helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o400)\n        assert not helpers.is_file_writable(basic_file)\n        basic_file.chmod(0o000)\n        assert not helpers.is_file_writable(basic_file)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_permission_error", "whole_func_string": "def test_permission_error(self, basic_file):\n        pathmock = MagicMock(spec_set=basic_file)\n        pathmock.is_symlink.return_value = False\n        pathmock.exists.return_value = True\n        pathmock.is_file.side_effect = PermissionError\n        assert not helpers.is_file_writable(pathmock)", "func_code_string": "def test_permission_error(self, basic_file):\n        pathmock = MagicMock(spec_set=basic_file)\n        pathmock.is_symlink.return_value = False\n        pathmock.exists.return_value = True\n        pathmock.is_file.side_effect = PermissionError\n        assert not helpers.is_file_writable(pathmock)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_language_list", "whole_func_string": "def test_language_list():\n    with pytest.raises(\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\n    ):\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])", "func_code_string": "def test_language_list():\n    with pytest.raises(\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\n    ):\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_stream_api", "whole_func_string": "def test_stream_api(resources: Path):\n    in_ = (resources / 'graph.pdf').open('rb')\n    out = BytesIO()\n\n    ocrmypdf.ocr(in_, out, tesseract_timeout=0.0)\n    out.seek(0)\n    assert b'%PDF' in out.read(1024)", "func_code_string": "def test_stream_api(resources: Path):\n    in_ = (resources / 'graph.pdf').open('rb')\n    out = BytesIO()\n\n    ocrmypdf.ocr(in_, out, tesseract_timeout=0.0)\n    out.seek(0)\n    assert b'%PDF' in out.read(1024)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_sidecar_stringio", "whole_func_string": "def test_sidecar_stringio(resources: Path, outdir: Path, outpdf: Path):\n    s = BytesIO()\n    ocrmypdf.ocr(\n        resources / 'ccitt.pdf',\n        outpdf,\n        plugins=['tests/plugins/tesseract_cache.py'],\n        sidecar=s,\n    )\n    s.seek(0)\n    assert b'the' in s.getvalue()", "func_code_string": "def test_sidecar_stringio(resources: Path, outdir: Path, outpdf: Path):\n    s = BytesIO()\n    ocrmypdf.ocr(\n        resources / 'ccitt.pdf',\n        outpdf,\n        plugins=['tests/plugins/tesseract_cache.py'],\n        sidecar=s,\n    )\n    s.seek(0)\n    assert b'the' in s.getvalue()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_hocr_api_multipage", "whole_func_string": "def test_hocr_api_multipage(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'multipage.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    assert (outdir / '000006_ocr_hocr.hocr').exists()\n    assert not (outdir / '000004_ocr_hocr.hocr').exists()\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf)\n    assert outpdf.exists()", "func_code_string": "def test_hocr_api_multipage(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'multipage.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    assert (outdir / '000006_ocr_hocr.hocr').exists()\n    assert not (outdir / '000004_ocr_hocr.hocr').exists()\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf)\n    assert outpdf.exists()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_hocr_to_pdf_api", "whole_func_string": "def test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'ccitt.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\n    mangled = hocr.replace('the', 'hocr')\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\n\n    text = extract_text(outpdf)\n    assert 'hocr' in text and 'the' not in text", "func_code_string": "def test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'ccitt.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\n    mangled = hocr.replace('the', 'hocr')\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\n\n    text = extract_text(outpdf)\n    assert 'hocr' in text and 'the' not in text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_hocr_result_json", "whole_func_string": "def test_hocr_result_json():\n    result = ocrmypdf._pipelines._common.HOCRResult(\n        pageno=1,\n        pdf_page_from_image=Path('a'),\n        hocr=Path('b'),\n        textpdf=Path('c'),\n        orientation_correction=180,\n    )\n    assert (\n        result.to_json()\n        == '{\"pageno\": 1, \"pdf_page_from_image\": {\"Path\": \"a\"}, \"hocr\": {\"Path\": \"b\"}, '\n        '\"textpdf\": {\"Path\": \"c\"}, \"orientation_correction\": 180}'\n    )\n    assert ocrmypdf._pipelines._common.HOCRResult.from_json(result.to_json()) == result", "func_code_string": "def test_hocr_result_json():\n    result = ocrmypdf._pipelines._common.HOCRResult(\n        pageno=1,\n        pdf_page_from_image=Path('a'),\n        hocr=Path('b'),\n        textpdf=Path('c'),\n        orientation_correction=180,\n    )\n    assert (\n        result.to_json()\n        == '{\"pageno\": 1, \"pdf_page_from_image\": {\"Path\": \"a\"}, \"hocr\": {\"Path\": \"b\"}, '\n        '\"textpdf\": {\"Path\": \"c\"}, \"orientation_correction\": 180}'\n    )\n    assert ocrmypdf._pipelines._common.HOCRResult.from_json(result.to_json()) == result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_hocr_result_pickle", "whole_func_string": "def test_hocr_result_pickle():\n    result = ocrmypdf._pipelines._common.HOCRResult(\n        pageno=1,\n        pdf_page_from_image=Path('a'),\n        hocr=Path('b'),\n        textpdf=Path('c'),\n        orientation_correction=180,\n    )\n    assert result == pickle.loads(pickle.dumps(result))", "func_code_string": "def test_hocr_result_pickle():\n    result = ocrmypdf._pipelines._common.HOCRResult(\n        pageno=1,\n        pdf_page_from_image=Path('a'),\n        hocr=Path('b'),\n        textpdf=Path('c'),\n        orientation_correction=180,\n    )\n    assert result == pickle.loads(pickle.dumps(result))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_graft.py", "func_name": "test_no_glyphless_graft", "whole_func_string": "def test_no_glyphless_graft(resources, outdir):\n    with (\n        pikepdf.open(resources / 'francais.pdf') as pdf,\n        pikepdf.open(resources / 'aspect.pdf') as pdf_aspect,\n        pikepdf.open(resources / 'cmyk.pdf') as pdf_cmyk,\n    ):\n        pdf.pages.extend(pdf_aspect.pages)\n        pdf.pages.extend(pdf_cmyk.pages)\n        pdf.save(outdir / 'test.pdf')\n\n    with patch('ocrmypdf._graft.MAX_REPLACE_PAGES', 2):\n        ocrmypdf.ocr(\n            outdir / 'test.pdf',\n            outdir / 'out.pdf',\n            deskew=True,\n            tesseract_timeout=0,\n            force_ocr=True,\n        )", "func_code_string": "def test_no_glyphless_graft(resources, outdir):\n    with (\n        pikepdf.open(resources / 'francais.pdf') as pdf,\n        pikepdf.open(resources / 'aspect.pdf') as pdf_aspect,\n        pikepdf.open(resources / 'cmyk.pdf') as pdf_cmyk,\n    ):\n        pdf.pages.extend(pdf_aspect.pages)\n        pdf.pages.extend(pdf_cmyk.pages)\n        pdf.save(outdir / 'test.pdf')\n\n    with patch('ocrmypdf._graft.MAX_REPLACE_PAGES', 2):\n        ocrmypdf.ocr(\n            outdir / 'test.pdf',\n            outdir / 'out.pdf',\n            deskew=True,\n            tesseract_timeout=0,\n            force_ocr=True,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_graft.py", "func_name": "test_links", "whole_func_string": "def test_links(resources, outpdf):\n    ocrmypdf.ocr(\n        resources / 'link.pdf', outpdf, redo_ocr=True, oversample=200, output_type='pdf'\n    )\n    with pikepdf.open(outpdf) as pdf:\n        p1 = pdf.pages[0]\n        p2 = pdf.pages[1]\n        assert p1.Annots[0].A.D[0].objgen == p2.objgen\n        assert p2.Annots[0].A.D[0].objgen == p1.objgen", "func_code_string": "def test_links(resources, outpdf):\n    ocrmypdf.ocr(\n        resources / 'link.pdf', outpdf, redo_ocr=True, oversample=200, output_type='pdf'\n    )\n    with pikepdf.open(outpdf) as pdf:\n        p1 = pdf.pages[0]\n        p2 = pdf.pages[1]\n        assert p1.Annots[0].A.D[0].objgen == p2.objgen\n        assert p2.Annots[0].A.D[0].objgen == p1.objgen", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_graft.py", "func_name": "test_strip_invisble_text", "whole_func_string": "def test_strip_invisble_text():\n    pdf = pikepdf.Pdf.new()\n    print(pikepdf.parse_content_stream(pikepdf.Stream(pdf, b'3 Tr')))\n    page = pdf.add_blank_page()\n    visible_text = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('visible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    invisible_text = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('invisible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    invisible_text_setting_tr = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction([3], pikepdf.Operator('Tr')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('invisible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    stream = [\n        pikepdf.ContentStreamInstruction([], pikepdf.Operator('q')),\n        pikepdf.ContentStreamInstruction([3], pikepdf.Operator('Tr')),\n        *invisible_text,\n        pikepdf.ContentStreamInstruction([], pikepdf.Operator('Q')),\n        *visible_text,\n        *invisible_text_setting_tr,\n        *invisible_text,\n    ]\n    content_stream = pikepdf.unparse_content_stream(stream)\n    page.Contents = pikepdf.Stream(pdf, content_stream)\n\n    def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )\n\n    nr_visible_pre = count('visible', page)\n    ocrmypdf._graft.strip_invisible_text(pdf, page)\n    nr_visible_post = count('visible', page)\n    assert (\n        nr_visible_pre == nr_visible_post\n    ), 'Number of visible text elements did not change'\n    assert count('invisible', page) == 0, 'No invisible elems left'", "func_code_string": "def test_strip_invisble_text():\n    pdf = pikepdf.Pdf.new()\n    print(pikepdf.parse_content_stream(pikepdf.Stream(pdf, b'3 Tr')))\n    page = pdf.add_blank_page()\n    visible_text = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('visible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    invisible_text = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('invisible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    invisible_text_setting_tr = [\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('BT')),\n        pikepdf.ContentStreamInstruction([3], pikepdf.Operator('Tr')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.Name('/F0'), 12), pikepdf.Operator('Tf')\n        ),\n        pikepdf.ContentStreamInstruction((288, 720), pikepdf.Operator('Td')),\n        pikepdf.ContentStreamInstruction(\n            (pikepdf.String('invisible'),), pikepdf.Operator('Tj')\n        ),\n        pikepdf.ContentStreamInstruction((), pikepdf.Operator('ET')),\n    ]\n    stream = [\n        pikepdf.ContentStreamInstruction([], pikepdf.Operator('q')),\n        pikepdf.ContentStreamInstruction([3], pikepdf.Operator('Tr')),\n        *invisible_text,\n        pikepdf.ContentStreamInstruction([], pikepdf.Operator('Q')),\n        *visible_text,\n        *invisible_text_setting_tr,\n        *invisible_text,\n    ]\n    content_stream = pikepdf.unparse_content_stream(stream)\n    page.Contents = pikepdf.Stream(pdf, content_stream)\n\n    def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )\n\n    nr_visible_pre = count('visible', page)\n    ocrmypdf._graft.strip_invisible_text(pdf, page)\n    nr_visible_post = count('visible', page)\n    assert (\n        nr_visible_pre == nr_visible_post\n    ), 'Number of visible text elements did not change'\n    assert count('invisible', page) == 0, 'No invisible elems left'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_graft.py", "func_name": "count", "whole_func_string": "def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )", "func_code_string": "def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfa.py", "func_name": "test_pdfa", "whole_func_string": "def test_pdfa(resources, outpdf, optimize, pdfa_level):\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            f'--output-type=pdfa-{pdfa_level}',\n            f'--optimize={optimize}',\n        )\n    except MissingDependencyError as e:\n        if 'pngquant' in str(e) and optimize in (2, 3) and os.name == 'nt':\n            pytest.xfail(\"pngquant currently not available on Windows\")\n    if pdfa_level in (2, 3):\n                               \n        assert b'/ObjStm' in outpdf.read_bytes()\n    elif pdfa_level == 1:\n                                                                         \n                         \n        assert b'/ObjStm' not in outpdf.read_bytes()\n\n    with pikepdf.open(outpdf) as pdf:\n        with pdf.open_metadata() as m:\n            assert m.pdfa_status == f'{pdfa_level}B'", "func_code_string": "def test_pdfa(resources, outpdf, optimize, pdfa_level):\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            f'--output-type=pdfa-{pdfa_level}',\n            f'--optimize={optimize}',\n        )\n    except MissingDependencyError as e:\n        if 'pngquant' in str(e) and optimize in (2, 3) and os.name == 'nt':\n            pytest.xfail(\"pngquant currently not available on Windows\")\n    if pdfa_level in (2, 3):\n                               \n        assert b'/ObjStm' in outpdf.read_bytes()\n    elif pdfa_level == 1:\n                                                                         \n                         \n        assert b'/ObjStm' not in outpdf.read_bytes()\n\n    with pikepdf.open(outpdf) as pdf:\n        with pdf.open_metadata() as m:\n            assert m.pdfa_status == f'{pdfa_level}B'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_quick", "whole_func_string": "def test_quick(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\n    )", "func_code_string": "def test_quick(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_oversample", "whole_func_string": "def test_oversample(renderer, resources, outpdf):\n    oversampled_pdf = check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--oversample',\n        '350',\n        '-f',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfinfo = PdfInfo(oversampled_pdf)\n\n    print(pdfinfo[0].dpi.x)\n    assert abs(pdfinfo[0].dpi.x - 350) < 1", "func_code_string": "def test_oversample(renderer, resources, outpdf):\n    oversampled_pdf = check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--oversample',\n        '350',\n        '-f',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfinfo = PdfInfo(oversampled_pdf)\n\n    print(pdfinfo[0].dpi.x)\n    assert abs(pdfinfo[0].dpi.x - 350) < 1", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_repeat_ocr", "whole_func_string": "def test_repeat_ocr(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'graph_ocred.pdf', no_outpdf)\n    assert result == ExitCode.already_done_ocr", "func_code_string": "def test_repeat_ocr(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'graph_ocred.pdf', no_outpdf)\n    assert result == ExitCode.already_done_ocr", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_force_ocr", "whole_func_string": "def test_force_ocr(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'graph_ocred.pdf',\n        outpdf,\n        '-f',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert pdfinfo[0].has_text", "func_code_string": "def test_force_ocr(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'graph_ocred.pdf',\n        outpdf,\n        '-f',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert pdfinfo[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_skip_ocr", "whole_func_string": "def test_skip_ocr(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'graph_ocred.pdf',\n        outpdf,\n        '-s',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert pdfinfo[0].has_text", "func_code_string": "def test_skip_ocr(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'graph_ocred.pdf',\n        outpdf,\n        '-s',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert pdfinfo[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_redo_ocr", "whole_func_string": "def test_redo_ocr(resources, outpdf):\n    in_ = resources / 'graph_ocred.pdf'\n    before = PdfInfo(in_, detailed_analysis=True)\n    out = outpdf\n    out = check_ocrmypdf(in_, out, '--redo-ocr')\n    after = PdfInfo(out, detailed_analysis=True)\n    assert before[0].has_text and after[0].has_text\n    assert (\n        before[0].get_textareas() != after[0].get_textareas()\n    ), \"Expected text to be different after re-OCR\"", "func_code_string": "def test_redo_ocr(resources, outpdf):\n    in_ = resources / 'graph_ocred.pdf'\n    before = PdfInfo(in_, detailed_analysis=True)\n    out = outpdf\n    out = check_ocrmypdf(in_, out, '--redo-ocr')\n    after = PdfInfo(out, detailed_analysis=True)\n    assert before[0].has_text and after[0].has_text\n    assert (\n        before[0].get_textareas() != after[0].get_textareas()\n    ), \"Expected text to be different after re-OCR\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_argsfile", "whole_func_string": "def test_argsfile(resources, outdir):\n    path_argsfile = outdir / 'test_argsfile.txt'\n    with open(str(path_argsfile), 'w') as argsfile:\n        print(\n            '--title',\n            'ArgsFile Test',\n            '--author',\n            'Test Cases',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            sep='\\n',\n            end='\\n',\n            file=argsfile,\n        )\n    check_ocrmypdf(\n        resources / 'graph.pdf', path_argsfile, '@' + str(outdir / 'test_argsfile.txt')\n    )", "func_code_string": "def test_argsfile(resources, outdir):\n    path_argsfile = outdir / 'test_argsfile.txt'\n    with open(str(path_argsfile), 'w') as argsfile:\n        print(\n            '--title',\n            'ArgsFile Test',\n            '--author',\n            'Test Cases',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            sep='\\n',\n            end='\\n',\n            file=argsfile,\n        )\n    check_ocrmypdf(\n        resources / 'graph.pdf', path_argsfile, '@' + str(outdir / 'test_argsfile.txt')\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_ocr_timeout", "whole_func_string": "def test_ocr_timeout(renderer, resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--tesseract-timeout',\n        '0',\n        '--pdf-renderer',\n        renderer,\n    )\n    pdfinfo = PdfInfo(out)\n    assert not pdfinfo[0].has_text", "func_code_string": "def test_ocr_timeout(renderer, resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--tesseract-timeout',\n        '0',\n        '--pdf-renderer',\n        renderer,\n    )\n    pdfinfo = PdfInfo(out)\n    assert not pdfinfo[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_skip_big", "whole_func_string": "def test_skip_big(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'jbig2.pdf',\n        outpdf,\n        '--skip-big',\n        '1',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert not pdfinfo[0].has_text", "func_code_string": "def test_skip_big(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'jbig2.pdf',\n        outpdf,\n        '--skip-big',\n        '1',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(out)\n    assert not pdfinfo[0].has_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_maximum_options", "whole_func_string": "def test_maximum_options(renderer, output_type, multipage, outpdf):\n    check_ocrmypdf(\n        multipage,\n        outpdf,\n        '-d',\n        '-ci' if have_unpaper() else None,\n        '-f',\n        '-k',\n        '--oversample',\n        '300',\n        '--skip-big',\n        '10',\n        '--title',\n        'Too Many Weird Files',\n        '--author',\n        'py.test',\n        '--pdf-renderer',\n        renderer,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_code_string": "def test_maximum_options(renderer, output_type, multipage, outpdf):\n    check_ocrmypdf(\n        multipage,\n        outpdf,\n        '-d',\n        '-ci' if have_unpaper() else None,\n        '-f',\n        '-k',\n        '--oversample',\n        '300',\n        '--skip-big',\n        '10',\n        '--title',\n        'Too Many Weird Files',\n        '--author',\n        'py.test',\n        '--pdf-renderer',\n        renderer,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_missing_tessdata", "whole_func_string": "def test_tesseract_missing_tessdata(monkeypatch, resources, no_outpdf, tmpdir):\n    monkeypatch.setenv(\"TESSDATA_PREFIX\", os.fspath(tmpdir))\n    with pytest.raises(MissingDependencyError):\n        run_ocrmypdf_api(resources / 'graph.pdf', no_outpdf, '-v', '1', '--skip-text')", "func_code_string": "def test_tesseract_missing_tessdata(monkeypatch, resources, no_outpdf, tmpdir):\n    monkeypatch.setenv(\"TESSDATA_PREFIX\", os.fspath(tmpdir))\n    with pytest.raises(MissingDependencyError):\n        run_ocrmypdf_api(resources / 'graph.pdf', no_outpdf, '-v', '1', '--skip-text')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_invalid_input_pdf", "whole_func_string": "def test_invalid_input_pdf(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\n    assert result == ExitCode.input_file", "func_code_string": "def test_invalid_input_pdf(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\n    assert result == ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_blank_input_pdf", "whole_func_string": "def test_blank_input_pdf(resources, outpdf):\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\n    assert result == ExitCode.ok", "func_code_string": "def test_blank_input_pdf(resources, outpdf):\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\n    assert result == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_force_ocr_on_pdf_with_no_images", "whole_func_string": "def test_force_ocr_on_pdf_with_no_images(resources, no_outpdf):\n                                                                        \n                                                                         \n             \n    exitcode = run_ocrmypdf_api(\n        resources / 'blank.pdf',\n        no_outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()", "func_code_string": "def test_force_ocr_on_pdf_with_no_images(resources, no_outpdf):\n                                                                        \n                                                                         \n             \n    exitcode = run_ocrmypdf_api(\n        resources / 'blank.pdf',\n        no_outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_german", "whole_func_string": "def test_german(resources, outdir):\n                                                                        \n                                                                              \n                                                                 \n    sidecar = outdir / 'francais.txt'\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outdir / 'francais.pdf',\n            '-l',\n            'deu',                           \n            '--sidecar',\n            sidecar,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )\n    except MissingDependencyError:\n        if 'deu' not in tesseract.get_languages():\n            pytest.xfail(reason=\"tesseract-deu language pack not installed\")\n        raise", "func_code_string": "def test_german(resources, outdir):\n                                                                        \n                                                                              \n                                                                 \n    sidecar = outdir / 'francais.txt'\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outdir / 'francais.pdf',\n            '-l',\n            'deu',                           \n            '--sidecar',\n            sidecar,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )\n    except MissingDependencyError:\n        if 'deu' not in tesseract.get_languages():\n            pytest.xfail(reason=\"tesseract-deu language pack not installed\")\n        raise", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_klingon", "whole_func_string": "def test_klingon(resources, outpdf):\n    with pytest.raises(MissingDependencyError):\n        run_ocrmypdf_api(resources / 'francais.pdf', outpdf, '-l', 'klz')", "func_code_string": "def test_klingon(resources, outpdf):\n    with pytest.raises(MissingDependencyError):\n        run_ocrmypdf_api(resources / 'francais.pdf', outpdf, '-l', 'klz')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_missing_docinfo", "whole_func_string": "def test_missing_docinfo(resources, outpdf):\n    result = run_ocrmypdf_api(\n        resources / 'missing_docinfo.pdf',\n        outpdf,\n        '-l',\n        'eng',\n        '--skip-text',\n        '--plugin',\n        Path('tests/plugins/tesseract_noop.py'),\n    )\n    assert result == ExitCode.ok", "func_code_string": "def test_missing_docinfo(resources, outpdf):\n    result = run_ocrmypdf_api(\n        resources / 'missing_docinfo.pdf',\n        outpdf,\n        '-l',\n        'eng',\n        '--skip-text',\n        '--plugin',\n        Path('tests/plugins/tesseract_noop.py'),\n    )\n    assert result == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_uppercase_extension", "whole_func_string": "def test_uppercase_extension(resources, outdir):\n    shutil.copy(str(resources / \"skew.pdf\"), str(outdir / \"UPPERCASE.PDF\"))\n\n    check_ocrmypdf(\n        outdir / \"UPPERCASE.PDF\",\n        outdir / \"UPPERCASE_OUT.PDF\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_uppercase_extension(resources, outdir):\n    shutil.copy(str(resources / \"skew.pdf\"), str(outdir / \"UPPERCASE.PDF\"))\n\n    check_ocrmypdf(\n        outdir / \"UPPERCASE.PDF\",\n        outdir / \"UPPERCASE_OUT.PDF\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_input_file_not_found", "whole_func_string": "def test_input_file_not_found(caplog, no_outpdf):\n    input_file = \"does not exist.pdf\"\n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    assert input_file in caplog.text", "func_code_string": "def test_input_file_not_found(caplog, no_outpdf):\n    input_file = \"does not exist.pdf\"\n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    assert input_file in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_input_file_not_readable", "whole_func_string": "def test_input_file_not_readable(caplog, resources, outdir, no_outpdf):\n    input_file = outdir / 'trivial.pdf'\n    shutil.copy(resources / 'trivial.pdf', input_file)\n    input_file.chmod(0o000)\n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    assert str(input_file) in caplog.text", "func_code_string": "def test_input_file_not_readable(caplog, resources, outdir, no_outpdf):\n    input_file = outdir / 'trivial.pdf'\n    shutil.copy(resources / 'trivial.pdf', input_file)\n    input_file.chmod(0o000)\n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    assert str(input_file) in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_input_file_not_a_pdf", "whole_func_string": "def test_input_file_not_a_pdf(caplog, no_outpdf):\n    input_file = __file__                        \n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    if os.name != 'nt':                                        \n        assert input_file in caplog.text", "func_code_string": "def test_input_file_not_a_pdf(caplog, no_outpdf):\n    input_file = __file__                        \n    result = run_ocrmypdf_api(input_file, no_outpdf)\n    assert result == ExitCode.input_file\n    if os.name != 'nt':                                        \n        assert input_file in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_pagesegmode", "whole_func_string": "def test_pagesegmode(renderer, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--tesseract-pagesegmode',\n        '7',\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_code_string": "def test_pagesegmode(renderer, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'skew.pdf',\n        outpdf,\n        '--tesseract-pagesegmode',\n        '7',\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_oem", "whole_func_string": "def test_tesseract_oem(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--tesseract-oem',\n        '1',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_code_string": "def test_tesseract_oem(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--tesseract-oem',\n        '1',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_thresholding", "whole_func_string": "def test_tesseract_thresholding(value, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--tesseract-thresholding',\n        value,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_code_string": "def test_tesseract_thresholding(value, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--tesseract-thresholding',\n        value,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_thresholding_invalid", "whole_func_string": "def test_tesseract_thresholding_invalid(value, resources, no_outpdf):\n    with pytest.raises(SystemExit, match='2'):\n        run_ocrmypdf_api(\n            resources / 'trivial.pdf',\n            no_outpdf,\n            '--tesseract-thresholding',\n            value,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )", "func_code_string": "def test_tesseract_thresholding_invalid(value, resources, no_outpdf):\n    with pytest.raises(SystemExit, match='2'):\n        run_ocrmypdf_api(\n            resources / 'trivial.pdf',\n            no_outpdf,\n            '--tesseract-thresholding',\n            value,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_crash", "whole_func_string": "def test_tesseract_crash(renderer, resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'ccitt.pdf',\n        no_outpdf,\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()\n    assert \"SubprocessOutputError\" in caplog.text", "func_code_string": "def test_tesseract_crash(renderer, resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'ccitt.pdf',\n        no_outpdf,\n        '-v',\n        '1',\n        '--pdf-renderer',\n        renderer,\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()\n    assert \"SubprocessOutputError\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_crash_autorotate", "whole_func_string": "def test_tesseract_crash_autorotate(resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'ccitt.pdf',\n        no_outpdf,\n        '-r',\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()\n    assert \"uncaught exception\" in caplog.text", "func_code_string": "def test_tesseract_crash_autorotate(resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'ccitt.pdf',\n        no_outpdf,\n        '-r',\n        '--plugin',\n        'tests/plugins/tesseract_crash.py',\n    )\n    assert exitcode == ExitCode.child_process_error\n    assert not no_outpdf.exists()\n    assert \"uncaught exception\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_image_too_big", "whole_func_string": "def test_tesseract_image_too_big(renderer, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'hugemono.pdf',\n        outpdf,\n        '-r',\n        '--pdf-renderer',\n        renderer,\n        '--max-image-mpixels',\n        '0',\n        '--plugin',\n        'tests/plugins/tesseract_big_image_error.py',\n    )", "func_code_string": "def test_tesseract_image_too_big(renderer, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'hugemono.pdf',\n        outpdf,\n        '-r',\n        '--pdf-renderer',\n        renderer,\n        '--max-image-mpixels',\n        '0',\n        '--plugin',\n        'tests/plugins/tesseract_big_image_error.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_encrypted", "whole_func_string": "def test_encrypted(resources, outpdf, encryption_level, caplog):\n    if os.name == 'darwin' and sys.version_info >= (3, 12) and encryption_level <= 4:\n                                                                        \n                                                                                      \n                    \n                                               \n                                                                                                                      \n                                                                                   \n                                                                                      \n                                                                                      \n                                                                             \n                                                                                  \n                                                                                       \n                            \n        pytest.skip(\"GitHub Python 3.12 on macOS does not have openssl legacy support\")\n    encryption = pikepdf.models.encryption.Encryption(\n        owner='ocrmypdf',\n        user='ocrmypdf',\n        R=encryption_level,\n        aes=(encryption_level >= 4),\n        metadata=(encryption_level == 6),\n    )\n\n    with pikepdf.open(resources / 'jbig2.pdf') as pdf:\n        pdf.save(outpdf, encryption=encryption)\n\n    exitcode = run_ocrmypdf_api(\n        outpdf,\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.encrypted_pdf\n    assert 'encryption must be removed' in caplog.text", "func_code_string": "def test_encrypted(resources, outpdf, encryption_level, caplog):\n    if os.name == 'darwin' and sys.version_info >= (3, 12) and encryption_level <= 4:\n                                                                        \n                                                                                      \n                    \n                                               \n                                                                                                                      \n                                                                                   \n                                                                                      \n                                                                                      \n                                                                             \n                                                                                  \n                                                                                       \n                            \n        pytest.skip(\"GitHub Python 3.12 on macOS does not have openssl legacy support\")\n    encryption = pikepdf.models.encryption.Encryption(\n        owner='ocrmypdf',\n        user='ocrmypdf',\n        R=encryption_level,\n        aes=(encryption_level >= 4),\n        metadata=(encryption_level == 6),\n    )\n\n    with pikepdf.open(resources / 'jbig2.pdf') as pdf:\n        pdf.save(outpdf, encryption=encryption)\n\n    exitcode = run_ocrmypdf_api(\n        outpdf,\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.encrypted_pdf\n    assert 'encryption must be removed' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_jbig2_passthrough", "whole_func_string": "def test_jbig2_passthrough(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'jbig2.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--pdf-renderer',\n        'hocr',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    out_pageinfo = PdfInfo(out)\n    assert out_pageinfo[0].images[0].enc == Encoding.jbig2", "func_code_string": "def test_jbig2_passthrough(resources, outpdf):\n    out = check_ocrmypdf(\n        resources / 'jbig2.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--pdf-renderer',\n        'hocr',\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    out_pageinfo = PdfInfo(out)\n    assert out_pageinfo[0].images[0].enc == Encoding.jbig2", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_masks", "whole_func_string": "def test_masks(resources, outpdf):\n    assert (\n        ocrmypdf.ocr(\n            resources / 'masks.pdf', outpdf, plugins=['tests/plugins/tesseract_noop.py']\n        )\n        == ExitCode.ok\n    )", "func_code_string": "def test_masks(resources, outpdf):\n    assert (\n        ocrmypdf.ocr(\n            resources / 'masks.pdf', outpdf, plugins=['tests/plugins/tesseract_noop.py']\n        )\n        == ExitCode.ok\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_linearized_pdf_and_indirect_object", "whole_func_string": "def test_linearized_pdf_and_indirect_object(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'epson.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_noop.py'\n    )", "func_code_string": "def test_linearized_pdf_and_indirect_object(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'epson.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_noop.py'\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_very_high_dpi", "whole_func_string": "def test_very_high_dpi(resources, outpdf):\n                                                                 \n    check_ocrmypdf(\n        resources / '2400dpi.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(outpdf)\n\n    image = pdfinfo[0].images[0]\n    assert isclose(image.dpi.x, image.dpi.y)\n    assert isclose(image.dpi.x, 2400)", "func_code_string": "def test_very_high_dpi(resources, outpdf):\n                                                                 \n    check_ocrmypdf(\n        resources / '2400dpi.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(outpdf)\n\n    image = pdfinfo[0].images[0]\n    assert isclose(image.dpi.x, image.dpi.y)\n    assert isclose(image.dpi.x, 2400)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_overlay", "whole_func_string": "def test_overlay(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'overlay.pdf',\n        outpdf,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_overlay(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'overlay.pdf',\n        outpdf,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "protected_file", "whole_func_string": "def protected_file(outdir):\n    protected_file = outdir / 'protected.pdf'\n    protected_file.touch()\n    protected_file.chmod(0o400)             \n    yield protected_file", "func_code_string": "def protected_file(outdir):\n    protected_file = outdir / 'protected.pdf'\n    protected_file.touch()\n    protected_file.chmod(0o400)             \n    yield protected_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_destination_not_writable", "whole_func_string": "def test_destination_not_writable(resources, protected_file):\n    exitcode = run_ocrmypdf_api(\n        resources / 'jbig2.pdf',\n        protected_file,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.file_access_error", "func_code_string": "def test_destination_not_writable(resources, protected_file):\n    exitcode = run_ocrmypdf_api(\n        resources / 'jbig2.pdf',\n        protected_file,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.file_access_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "valid_tess_config", "whole_func_string": "def valid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nload_system_dawg 0\nlanguage_model_penalty_non_dict_word 0\nlanguage_model_penalty_non_freq_dict_word 0\n'''\n        )\n    yield cfg_file", "func_code_string": "def valid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nload_system_dawg 0\nlanguage_model_penalty_non_dict_word 0\nlanguage_model_penalty_non_freq_dict_word 0\n'''\n        )\n    yield cfg_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_config_valid", "whole_func_string": "def test_tesseract_config_valid(resources, valid_tess_config, outpdf):\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--tesseract-config',\n        valid_tess_config,\n        '--pages',\n        '1',\n    )", "func_code_string": "def test_tesseract_config_valid(resources, valid_tess_config, outpdf):\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--tesseract-config',\n        valid_tess_config,\n        '--pages',\n        '1',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "invalid_tess_config", "whole_func_string": "def invalid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nTHIS FILE IS INVALID\n'''\n        )\n    yield cfg_file", "func_code_string": "def invalid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nTHIS FILE IS INVALID\n'''\n        )\n    yield cfg_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_config_invalid", "whole_func_string": "def test_tesseract_config_invalid(renderer, resources, invalid_tess_config, outpdf):\n    p = run_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--tesseract-config',\n        invalid_tess_config,\n    )\n    assert (\n        \"parameter not found\" in p.stderr.lower()\n        or \"error occurred while parsing\" in p.stderr.lower()\n    ), \"No error message\"\n    assert p.returncode == ExitCode.invalid_config", "func_code_string": "def test_tesseract_config_invalid(renderer, resources, invalid_tess_config, outpdf):\n    p = run_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--tesseract-config',\n        invalid_tess_config,\n    )\n    assert (\n        \"parameter not found\" in p.stderr.lower()\n        or \"error occurred while parsing\" in p.stderr.lower()\n    ), \"No error message\"\n    assert p.returncode == ExitCode.invalid_config", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_user_words_ocr", "whole_func_string": "def test_user_words_ocr(resources, outdir):\n                                                                    \n    word_list = outdir / 'wordlist.txt'\n    sidecar_after = outdir / 'sidecar.txt'\n\n    with word_list.open('w') as f:\n        f.write('cromulent\\n')                              \n\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outdir / 'out.pdf',\n        '--image-dpi',\n        150,\n        '--sidecar',\n        sidecar_after,\n        '--user-words',\n        word_list,\n    )", "func_code_string": "def test_user_words_ocr(resources, outdir):\n                                                                    \n    word_list = outdir / 'wordlist.txt'\n    sidecar_after = outdir / 'sidecar.txt'\n\n    with word_list.open('w') as f:\n        f.write('cromulent\\n')                              \n\n    check_ocrmypdf(\n        resources / 'crom.png',\n        outdir / 'out.pdf',\n        '--image-dpi',\n        150,\n        '--sidecar',\n        sidecar_after,\n        '--user-words',\n        word_list,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_form_xobject", "whole_func_string": "def test_form_xobject(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'formxobject.pdf',\n        outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_form_xobject(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'formxobject.pdf',\n        outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_pagesize_consistency", "whole_func_string": "def test_pagesize_consistency(renderer, resources, outpdf):\n    infile = resources / '3small.pdf'\n\n    before_dims = first_page_dimensions(infile)\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--clean' if have_unpaper() else None,\n        '--deskew',\n                                \n        '--clean-final' if have_unpaper() else None,\n        '-k',\n        '--pages',\n        '1',\n    )\n\n    after_dims = first_page_dimensions(outpdf)\n\n    assert isclose(before_dims[0], after_dims[0], rel_tol=1e-4)\n    assert isclose(before_dims[1], after_dims[1], rel_tol=1e-4)", "func_code_string": "def test_pagesize_consistency(renderer, resources, outpdf):\n    infile = resources / '3small.pdf'\n\n    before_dims = first_page_dimensions(infile)\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--clean' if have_unpaper() else None,\n        '--deskew',\n                                \n        '--clean-final' if have_unpaper() else None,\n        '-k',\n        '--pages',\n        '1',\n    )\n\n    after_dims = first_page_dimensions(outpdf)\n\n    assert isclose(before_dims[0], after_dims[0], rel_tol=1e-4)\n    assert isclose(before_dims[1], after_dims[1], rel_tol=1e-4)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_skip_big_with_no_images", "whole_func_string": "def test_skip_big_with_no_images(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'blank.pdf',\n        outpdf,\n        '--skip-big',\n        '5',\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_skip_big_with_no_images(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'blank.pdf',\n        outpdf,\n        '--skip-big',\n        '5',\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_no_contents", "whole_func_string": "def test_no_contents(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'no_contents.pdf',\n        outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_no_contents(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'no_contents.pdf',\n        outpdf,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_compression_preserved", "whole_func_string": "def test_compression_preserved(ocrmypdf_exec, resources, image, outpdf):\n    input_file = str(resources / image)\n    output_file = str(outpdf)\n\n    im = Image.open(input_file)\n                                            \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '--optimize',\n            '0',\n            '--image-dpi',\n            '150',\n            '--output-type',\n            'pdf',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            '-',\n            output_file,\n        ]\n        p = run(\n            p_args,\n            capture_output=True,\n            stdin=input_stream,\n            text=True,\n            check=False,\n        )\n\n        if im.mode in ('RGBA', 'LA'):\n                                                      \n            assert p.returncode != ExitCode.ok and 'alpha' in p.stderr\n            return\n\n        assert p.returncode == ExitCode.ok, p.stderr\n\n    pdfinfo = PdfInfo(output_file)\n\n    pdfimage = pdfinfo[0].images[0]\n\n    if input_file.endswith('.png'):\n        assert pdfimage.enc != Encoding.jpeg, \"Lossless compression changed to lossy!\"\n    elif input_file.endswith('.jpg'):\n        assert pdfimage.enc == Encoding.jpeg, \"Lossy compression changed to lossless!\"\n    if im.mode.startswith('RGB') or im.mode.startswith('BGR'):\n        assert pdfimage.color == Colorspace.rgb, \"Colorspace changed\"\n    elif im.mode.startswith('L'):\n        assert pdfimage.color == Colorspace.gray, \"Colorspace changed\"\n    im.close()", "func_code_string": "def test_compression_preserved(ocrmypdf_exec, resources, image, outpdf):\n    input_file = str(resources / image)\n    output_file = str(outpdf)\n\n    im = Image.open(input_file)\n                                            \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '--optimize',\n            '0',\n            '--image-dpi',\n            '150',\n            '--output-type',\n            'pdf',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            '-',\n            output_file,\n        ]\n        p = run(\n            p_args,\n            capture_output=True,\n            stdin=input_stream,\n            text=True,\n            check=False,\n        )\n\n        if im.mode in ('RGBA', 'LA'):\n                                                      \n            assert p.returncode != ExitCode.ok and 'alpha' in p.stderr\n            return\n\n        assert p.returncode == ExitCode.ok, p.stderr\n\n    pdfinfo = PdfInfo(output_file)\n\n    pdfimage = pdfinfo[0].images[0]\n\n    if input_file.endswith('.png'):\n        assert pdfimage.enc != Encoding.jpeg, \"Lossless compression changed to lossy!\"\n    elif input_file.endswith('.jpg'):\n        assert pdfimage.enc == Encoding.jpeg, \"Lossy compression changed to lossless!\"\n    if im.mode.startswith('RGB') or im.mode.startswith('BGR'):\n        assert pdfimage.color == Colorspace.rgb, \"Colorspace changed\"\n    elif im.mode.startswith('L'):\n        assert pdfimage.color == Colorspace.gray, \"Colorspace changed\"\n    im.close()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_compression_changed", "whole_func_string": "def test_compression_changed(ocrmypdf_exec, resources, image, compression, outpdf):\n    input_file = str(resources / image)\n    output_file = str(outpdf)\n\n    im = Image.open(input_file)\n\n                                            \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '--image-dpi',\n            '150',\n            '--output-type',\n            'pdfa',\n            '--optimize',\n            '0',\n            '--pdfa-image-compression',\n            compression,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            '-',\n            output_file,\n        ]\n        p = run(\n            p_args,\n            capture_output=True,\n            stdin=input_stream,\n            text=True,\n            check=False,\n        )\n        assert p.returncode == ExitCode.ok, p.stderr\n\n    pdfinfo = PdfInfo(output_file)\n\n    pdfimage = pdfinfo[0].images[0]\n\n    if compression == \"jpeg\":\n        assert pdfimage.enc == Encoding.jpeg\n    else:\n        if image.endswith('jpg'):\n                                                     \n            assert pdfimage.enc == Encoding.jpeg\n        else:\n            assert pdfimage.enc not in (Encoding.jpeg, Encoding.jpeg2000)\n\n    if im.mode.startswith('RGB') or im.mode.startswith('BGR'):\n        assert pdfimage.color == Colorspace.rgb, \"Colorspace changed\"\n    elif im.mode.startswith('L'):\n        assert pdfimage.color == Colorspace.gray, \"Colorspace changed\"\n    im.close()", "func_code_string": "def test_compression_changed(ocrmypdf_exec, resources, image, compression, outpdf):\n    input_file = str(resources / image)\n    output_file = str(outpdf)\n\n    im = Image.open(input_file)\n\n                                            \n    with open(input_file, 'rb') as input_stream:\n        p_args = ocrmypdf_exec + [\n            '--image-dpi',\n            '150',\n            '--output-type',\n            'pdfa',\n            '--optimize',\n            '0',\n            '--pdfa-image-compression',\n            compression,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n            '-',\n            output_file,\n        ]\n        p = run(\n            p_args,\n            capture_output=True,\n            stdin=input_stream,\n            text=True,\n            check=False,\n        )\n        assert p.returncode == ExitCode.ok, p.stderr\n\n    pdfinfo = PdfInfo(output_file)\n\n    pdfimage = pdfinfo[0].images[0]\n\n    if compression == \"jpeg\":\n        assert pdfimage.enc == Encoding.jpeg\n    else:\n        if image.endswith('jpg'):\n                                                     \n            assert pdfimage.enc == Encoding.jpeg\n        else:\n            assert pdfimage.enc not in (Encoding.jpeg, Encoding.jpeg2000)\n\n    if im.mode.startswith('RGB') or im.mode.startswith('BGR'):\n        assert pdfimage.color == Colorspace.rgb, \"Colorspace changed\"\n    elif im.mode.startswith('L'):\n        assert pdfimage.color == Colorspace.gray, \"Colorspace changed\"\n    im.close()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_sidecar_pagecount", "whole_func_string": "def test_sidecar_pagecount(resources, outpdf):\n    sidecar = outpdf.with_suffix('.txt')\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--skip-text',\n        '--sidecar',\n        sidecar,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfinfo = PdfInfo(resources / '3small.pdf')\n    num_pages = len(pdfinfo)\n\n    with open(sidecar, encoding='utf-8') as f:\n        ocr_text = f.read()\n\n                                                                         \n                                          \n    assert (\n        ocr_text.count('\\f') == num_pages - 1\n    ), \"Sidecar page count does not match PDF page count\"", "func_code_string": "def test_sidecar_pagecount(resources, outpdf):\n    sidecar = outpdf.with_suffix('.txt')\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--skip-text',\n        '--sidecar',\n        sidecar,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfinfo = PdfInfo(resources / '3small.pdf')\n    num_pages = len(pdfinfo)\n\n    with open(sidecar, encoding='utf-8') as f:\n        ocr_text = f.read()\n\n                                                                         \n                                          \n    assert (\n        ocr_text.count('\\f') == num_pages - 1\n    ), \"Sidecar page count does not match PDF page count\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_sidecar_nonempty", "whole_func_string": "def test_sidecar_nonempty(resources, outpdf):\n    sidecar = outpdf.with_suffix('.txt')\n    check_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--sidecar',\n        sidecar,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    with open(sidecar, encoding='utf-8') as f:\n        ocr_text = f.read()\n    assert 'the' in ocr_text", "func_code_string": "def test_sidecar_nonempty(resources, outpdf):\n    sidecar = outpdf.with_suffix('.txt')\n    check_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--sidecar',\n        sidecar,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    with open(sidecar, encoding='utf-8') as f:\n        ocr_text = f.read()\n    assert 'the' in ocr_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_pdfa_n", "whole_func_string": "def test_pdfa_n(pdfa_level, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--output-type',\n        'pdfa-' + pdfa_level,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfa_info = file_claims_pdfa(outpdf)\n    assert pdfa_info['conformance'] == f'PDF/A-{pdfa_level}B'", "func_code_string": "def test_pdfa_n(pdfa_level, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf',\n        outpdf,\n        '--output-type',\n        'pdfa-' + pdfa_level,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n\n    pdfa_info = file_claims_pdfa(outpdf)\n    assert pdfa_info['conformance'] == f'PDF/A-{pdfa_level}B'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_decompression_bomb_error", "whole_func_string": "def test_decompression_bomb_error(resources, outpdf, caplog):\n    run_ocrmypdf_api(resources / 'hugemono.pdf', outpdf)\n    assert 'decompression bomb' in caplog.text\n    assert 'max-image-mpixels' in caplog.text", "func_code_string": "def test_decompression_bomb_error(resources, outpdf, caplog):\n    run_ocrmypdf_api(resources / 'hugemono.pdf', outpdf)\n    assert 'decompression bomb' in caplog.text\n    assert 'max-image-mpixels' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_decompression_bomb_succeeds", "whole_func_string": "def test_decompression_bomb_succeeds(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'hugemono.pdf', outpdf, '--max-image-mpixels', '2000'\n    )\n    assert exitcode == 0", "func_code_string": "def test_decompression_bomb_succeeds(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'hugemono.pdf', outpdf, '--max-image-mpixels', '2000'\n    )\n    assert exitcode == 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_text_curves", "whole_func_string": "def test_text_curves(resources, outpdf):\n    with patch('ocrmypdf._pipeline.VECTOR_PAGE_DPI', 100):\n        check_ocrmypdf(\n            resources / 'vector.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n\n        info = PdfInfo(outpdf)\n        assert len(info.pages[0].images) == 0, \"added images to the vector PDF\"", "func_code_string": "def test_text_curves(resources, outpdf):\n    with patch('ocrmypdf._pipeline.VECTOR_PAGE_DPI', 100):\n        check_ocrmypdf(\n            resources / 'vector.pdf',\n            outpdf,\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n\n        info = PdfInfo(outpdf)\n        assert len(info.pages[0].images) == 0, \"added images to the vector PDF\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_text_curves_force", "whole_func_string": "def test_text_curves_force(resources, outpdf):\n    with patch('ocrmypdf._pipeline.VECTOR_PAGE_DPI', 100):\n        check_ocrmypdf(\n            resources / 'vector.pdf',\n            outpdf,\n            '--force-ocr',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n\n        info = PdfInfo(outpdf)\n        assert len(info.pages[0].images) != 0, \"force did not rasterize\"", "func_code_string": "def test_text_curves_force(resources, outpdf):\n    with patch('ocrmypdf._pipeline.VECTOR_PAGE_DPI', 100):\n        check_ocrmypdf(\n            resources / 'vector.pdf',\n            outpdf,\n            '--force-ocr',\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n\n        info = PdfInfo(outpdf)\n        assert len(info.pages[0].images) != 0, \"force did not rasterize\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_output_is_dir", "whole_func_string": "def test_output_is_dir(resources, outdir, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        outdir,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.file_access_error\n    assert 'is not a writable file' in caplog.text", "func_code_string": "def test_output_is_dir(resources, outdir, caplog):\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        outdir,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.file_access_error\n    assert 'is not a writable file' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_output_is_symlink", "whole_func_string": "def test_output_is_symlink(resources, outdir):\n    sym = Path(outdir / 'this_is_a_symlink')\n    sym.symlink_to(outdir / 'out.pdf')\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        sym,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.ok\n    assert (outdir / 'out.pdf').stat().st_size > 0, 'target file not created'", "func_code_string": "def test_output_is_symlink(resources, outdir):\n    sym = Path(outdir / 'this_is_a_symlink')\n    sym.symlink_to(outdir / 'out.pdf')\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        sym,\n        '--force-ocr',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.ok\n    assert (outdir / 'out.pdf').stat().st_size > 0, 'target file not created'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_livecycle", "whole_func_string": "def test_livecycle(resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(resources / 'livecycle.pdf', no_outpdf)\n\n    assert exitcode == ExitCode.input_file, caplog.text", "func_code_string": "def test_livecycle(resources, no_outpdf, caplog):\n    exitcode = run_ocrmypdf_api(resources / 'livecycle.pdf', no_outpdf)\n\n    assert exitcode == ExitCode.input_file, caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_version_check", "whole_func_string": "def test_version_check():\n    with pytest.raises(MissingDependencyError):\n        get_version('NOT_FOUND_UNLIKELY_ON_PATH')\n\n    with pytest.raises(MissingDependencyError):\n        get_version('sh', version_arg='-c')\n\n    with pytest.raises(MissingDependencyError):\n        get_version('echo')", "func_code_string": "def test_version_check():\n    with pytest.raises(MissingDependencyError):\n        get_version('NOT_FOUND_UNLIKELY_ON_PATH')\n\n    with pytest.raises(MissingDependencyError):\n        get_version('sh', version_arg='-c')\n\n    with pytest.raises(MissingDependencyError):\n        get_version('echo')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_fast_web_view", "whole_func_string": "def test_fast_web_view(resources, outpdf, threshold, optimize, output_type, expected):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--fast-web-view',\n        threshold,\n        '--optimize',\n        optimize,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with pikepdf.open(outpdf) as pdf:\n        assert pdf.is_linearized == expected", "func_code_string": "def test_fast_web_view(resources, outpdf, threshold, optimize, output_type, expected):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--fast-web-view',\n        threshold,\n        '--optimize',\n        optimize,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with pikepdf.open(outpdf) as pdf:\n        assert pdf.is_linearized == expected", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_image_dpi_not_image", "whole_func_string": "def test_image_dpi_not_image(caplog, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--image-dpi',\n        '100',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert '--image-dpi is being ignored' in caplog.text", "func_code_string": "def test_image_dpi_not_image(caplog, resources, outpdf):\n    check_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--image-dpi',\n        '100',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert '--image-dpi is being ignored' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_outputtype_none_bad_setup", "whole_func_string": "def test_outputtype_none_bad_setup(resources, outpdf):\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--output-type=none',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == ExitCode.bad_args\n    assert 'Set the output file to' in p.stderr", "func_code_string": "def test_outputtype_none_bad_setup(resources, outpdf):\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--output-type=none',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == ExitCode.bad_args\n    assert 'Set the output file to' in p.stderr", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_outputtype_none", "whole_func_string": "def test_outputtype_none(resources, outtxt):\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        '-',\n        '--output-type=none',\n        '--sidecar',\n        outtxt,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.ok\n    assert outtxt.exists()", "func_code_string": "def test_outputtype_none(resources, outtxt):\n    exitcode = run_ocrmypdf_api(\n        resources / 'trivial.pdf',\n        '-',\n        '--output-type=none',\n        '--sidecar',\n        outtxt,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert exitcode == ExitCode.ok\n    assert outtxt.exists()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "graph_bad_icc", "whole_func_string": "def graph_bad_icc(resources, outdir):\n    synth_input_file = outdir / 'graph-bad-icc.pdf'\n    with pikepdf.open(resources / 'graph.pdf') as pdf:\n        icc = pdf.make_stream(\n            b'invalid icc profile', N=3, Alternate=pikepdf.Name.DeviceRGB\n        )\n        pdf.pages[0].Resources.XObject['/Im0'].ColorSpace = pikepdf.Array(\n            [pikepdf.Name.ICCBased, icc]\n        )\n        pdf.save(synth_input_file)\n        yield synth_input_file", "func_code_string": "def graph_bad_icc(resources, outdir):\n    synth_input_file = outdir / 'graph-bad-icc.pdf'\n    with pikepdf.open(resources / 'graph.pdf') as pdf:\n        icc = pdf.make_stream(\n            b'invalid icc profile', N=3, Alternate=pikepdf.Name.DeviceRGB\n        )\n        pdf.pages[0].Resources.XObject['/Im0'].ColorSpace = pikepdf.Array(\n            [pikepdf.Name.ICCBased, icc]\n        )\n        pdf.save(synth_input_file)\n        yield synth_input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_corrupt_icc", "whole_func_string": "def test_corrupt_icc(graph_bad_icc, outpdf, caplog):\n    result = run_ocrmypdf_api(graph_bad_icc, outpdf)\n    assert result == ExitCode.ok\n    assert any(\n        'corrupt or unreadable ICC profile' in rec.message for rec in caplog.records\n    )", "func_code_string": "def test_corrupt_icc(graph_bad_icc, outpdf, caplog):\n    result = run_ocrmypdf_api(graph_bad_icc, outpdf)\n    assert result == ExitCode.ok\n    assert any(\n        'corrupt or unreadable ICC profile' in rec.message for rec in caplog.records\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_soft_error.py", "func_name": "test_raster_continue_on_soft_error", "whole_func_string": "def test_raster_continue_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--continue-on-soft-render-error',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_soft_error.py',\n    )\n    assert exitcode == ExitCode.ok", "func_code_string": "def test_raster_continue_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--continue-on-soft-render-error',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_soft_error.py',\n    )\n    assert exitcode == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_soft_error.py", "func_name": "test_raster_stop_on_soft_error", "whole_func_string": "def test_raster_stop_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_soft_error.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_raster_stop_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_raster_soft_error.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_soft_error.py", "func_name": "test_render_continue_on_soft_error", "whole_func_string": "def test_render_continue_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--continue-on-soft-render-error',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_soft_error.py',\n    )\n    assert exitcode == ExitCode.ok", "func_code_string": "def test_render_continue_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--continue-on-soft-render-error',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_soft_error.py',\n    )\n    assert exitcode == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_soft_error.py", "func_name": "test_render_stop_on_soft_error", "whole_func_string": "def test_render_stop_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_soft_error.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_render_stop_on_soft_error(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / 'francais.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n        '--plugin',\n        'tests/plugins/gs_render_soft_error.py',\n    )\n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_completion.py", "func_name": "test_fish", "whole_func_string": "def test_fish():\n    try:\n        proc = run(\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('fish is not installed')", "func_code_string": "def test_fish():\n    try:\n        proc = run(\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('fish is not installed')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_completion.py", "func_name": "test_bash", "whole_func_string": "def test_bash():\n    try:\n        proc = run(\n            ['bash', '-n', 'misc/completion/ocrmypdf.bash'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('bash is not installed')", "func_code_string": "def test_bash():\n    try:\n        proc = run(\n            ['bash', '-n', 'misc/completion/ocrmypdf.bash'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('bash is not installed')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pipeline.py", "func_name": "rgb_image", "whole_func_string": "def rgb_image():\n    im = Image.new('RGB', (8, 8))\n    im.putpixel((4, 4), (255, 0, 0))\n    im.putpixel((5, 5), (0, 255, 0))\n    im.putpixel((6, 6), (0, 0, 255))\n    return ImageReader(im)", "func_code_string": "def rgb_image():\n    im = Image.new('RGB', (8, 8))\n    im.putpixel((4, 4), (255, 0, 0))\n    im.putpixel((5, 5), (0, 255, 0))\n    im.putpixel((6, 6), (0, 0, 255))\n    return ImageReader(im)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pipeline.py", "func_name": "test_dpi_needed", "whole_func_string": "def test_dpi_needed(image, text, vector, result, rgb_image, outdir):\n    c = Canvas(str(outdir / 'dpi.pdf'), pagesize=(5 * inch, 5 * inch))\n    if image:\n        c.drawImage(rgb_image, 1 * inch, 1 * inch, width=1 * inch, height=1 * inch)\n    if text:\n        c.drawString(1 * inch, 4 * inch, \"Actual text\")\n    if vector:\n        c.ellipse(3 * inch, 3 * inch, 4 * inch, 4 * inch)\n    c.showPage()\n    c.save()\n\n    pi = pdfinfo.PdfInfo(outdir / 'dpi.pdf')\n    pageinfo = pi[0]\n    ctx = Mock()\n    ctx.options.oversample = DUMMY_OVERSAMPLE_RESOLUTION[0]\n    ctx.pageinfo = pageinfo\n\n    assert _pipeline.get_canvas_square_dpi(ctx) == result\n    assert _pipeline.get_page_square_dpi(ctx) == result", "func_code_string": "def test_dpi_needed(image, text, vector, result, rgb_image, outdir):\n    c = Canvas(str(outdir / 'dpi.pdf'), pagesize=(5 * inch, 5 * inch))\n    if image:\n        c.drawImage(rgb_image, 1 * inch, 1 * inch, width=1 * inch, height=1 * inch)\n    if text:\n        c.drawString(1 * inch, 4 * inch, \"Actual text\")\n    if vector:\n        c.ellipse(3 * inch, 3 * inch, 4 * inch, 4 * inch)\n    c.showPage()\n    c.save()\n\n    pi = pdfinfo.PdfInfo(outdir / 'dpi.pdf')\n    pageinfo = pi[0]\n    ctx = Mock()\n    ctx.options.oversample = DUMMY_OVERSAMPLE_RESOLUTION[0]\n    ctx.pageinfo = pageinfo\n\n    assert _pipeline.get_canvas_square_dpi(ctx) == result\n    assert _pipeline.get_page_square_dpi(ctx) == result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pipeline.py", "func_name": "test_enumerate_compress_ranges", "whole_func_string": "def test_enumerate_compress_ranges(name, input, output):\n    assert output == tuple(_pipeline.enumerate_compress_ranges(input))", "func_code_string": "def test_enumerate_compress_ranges(name, input, output):\n    assert output == tuple(_pipeline.enumerate_compress_ranges(input))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_quality.py", "func_name": "test_quality_measurement", "whole_func_string": "def test_quality_measurement():\n    oqd = qual.OcrQualityDictionary(\n        wordlist=[\"words\", \"words\", \"quick\", \"brown\", \"fox\", \"dog\", \"lazy\"]\n    )\n    assert len(oqd.dictionary) == 6            \n\n    assert (\n        oqd.measure_words_matched(\"The quick brown fox jumps quickly over the lazy dog\")\n        == 0.5\n    )\n    assert oqd.measure_words_matched(\"12345 10% _f  7fox -brown   | words\") == 1.0\n\n    assert oqd.measure_words_matched(\"quick quick quick\") == 1.0", "func_code_string": "def test_quality_measurement():\n    oqd = qual.OcrQualityDictionary(\n        wordlist=[\"words\", \"words\", \"quick\", \"brown\", \"fox\", \"dog\", \"lazy\"]\n    )\n    assert len(oqd.dictionary) == 6            \n\n    assert (\n        oqd.measure_words_matched(\"The quick brown fox jumps quickly over the lazy dog\")\n        == 0.5\n    )\n    assert oqd.measure_words_matched(\"12345 10% _f  7fox -brown   | words\") == 1.0\n\n    assert oqd.measure_words_matched(\"quick quick quick\") == 1.0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "FixedRotateNoopOcrEngine", "whole_func_string": "class FixedRotateNoopOcrEngine(OcrEngine):\n    @staticmethod\n    def version():\n        return '4.1.1'\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {FixedRotateNoopOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"NO-OP {FixedRotateNoopOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return {'eng'}\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_code_string": "class FixedRotateNoopOcrEngine(OcrEngine):\n    @staticmethod\n    def version():\n        return '4.1.1'\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {FixedRotateNoopOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"NO-OP {FixedRotateNoopOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return {'eng'}\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return FixedRotateNoopOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return FixedRotateNoopOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "version", "whole_func_string": "def version():\n        return '4.1.1'", "func_code_string": "def version():\n        return '4.1.1'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "creator_tag", "whole_func_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {FixedRotateNoopOcrEngine.version()}\"", "func_code_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {FixedRotateNoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n        return f\"NO-OP {FixedRotateNoopOcrEngine.version()}\"", "func_code_string": "def __str__(self):\n        return f\"NO-OP {FixedRotateNoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "languages", "whole_func_string": "def languages(options):\n        return {'eng'}", "func_code_string": "def languages(options):\n        return {'eng'}", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)", "func_code_string": "def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "raise_crash", "whole_func_string": "def raise_crash(*args, **kwargs):\n    raise CalledProcessError(\n        128 + signal.SIGABRT,\n        'tesseract',\n        output=b\"\",\n        stderr=b\"libc++abi.dylib: terminating with uncaught exception of type \"\n        + b\"std::bad_alloc: std::bad_alloc\",\n    )", "func_code_string": "def raise_crash(*args, **kwargs):\n    raise CalledProcessError(\n        128 + signal.SIGABRT,\n        'tesseract',\n        output=b\"\",\n        stderr=b\"libc++abi.dylib: terminating with uncaught exception of type \"\n        + b\"std::bad_alloc: std::bad_alloc\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "patch_tesseract_run", "whole_func_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = raise_crash\n        yield\n        mock.assert_called()", "func_code_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = raise_crash\n        yield\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "CrashOcrEngine", "whole_func_string": "class CrashOcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class CrashOcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return CrashOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return CrashOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_code_string": "def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "NoopOcrEngine", "whole_func_string": "class NoopOcrEngine(OcrEngine):\n    @staticmethod\n    def version():\n        return '4.1.1'\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return {'eng'}\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        return OrientationConfidence(angle=0, confidence=0.0)\n\n    @staticmethod\n    def get_deskew(input_file, options):\n        return 0.0\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_code_string": "class NoopOcrEngine(OcrEngine):\n    @staticmethod\n    def version():\n        return '4.1.1'\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return {'eng'}\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        return OrientationConfidence(angle=0, confidence=0.0)\n\n    @staticmethod\n    def get_deskew(input_file, options):\n        return 0.0\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return NoopOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return NoopOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "version", "whole_func_string": "def version():\n        return '4.1.1'", "func_code_string": "def version():\n        return '4.1.1'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "creator_tag", "whole_func_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"", "func_code_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"", "func_code_string": "def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "languages", "whole_func_string": "def languages(options):\n        return {'eng'}", "func_code_string": "def languages(options):\n        return {'eng'}", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        return OrientationConfidence(angle=0, confidence=0.0)", "func_code_string": "def get_orientation(input_file, options):\n        return OrientationConfidence(angle=0, confidence=0.0)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "get_deskew", "whole_func_string": "def get_deskew(input_file, options):\n        return 0.0", "func_code_string": "def get_deskew(input_file, options):\n        return 0.0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "get_cache_folder", "whole_func_string": "def get_cache_folder(source_pdf, run_args, parsed_args):\n    def slugs():\n        yield ''                                                         \n        for arg in run_args[1:]:\n            if arg == parsed_args.imagename:\n                yield Path(parsed_args.imagename).name\n            elif arg == parsed_args.outputbase:\n                yield Path(parsed_args.outputbase).name\n            elif arg == '-c' or arg.startswith('textonly'):\n                pass\n            else:\n                yield arg\n\n    argv_slug = '__'.join(slugs())\n    argv_slug = argv_slug.replace('/', '___')\n\n    return Path(CACHE_ROOT) / Path(source_pdf).stem / argv_slug", "func_code_string": "def get_cache_folder(source_pdf, run_args, parsed_args):\n    def slugs():\n        yield ''                                                         \n        for arg in run_args[1:]:\n            if arg == parsed_args.imagename:\n                yield Path(parsed_args.imagename).name\n            elif arg == parsed_args.outputbase:\n                yield Path(parsed_args.outputbase).name\n            elif arg == '-c' or arg.startswith('textonly'):\n                pass\n            else:\n                yield arg\n\n    argv_slug = '__'.join(slugs())\n    argv_slug = argv_slug.replace('/', '___')\n\n    return Path(CACHE_ROOT) / Path(source_pdf).stem / argv_slug", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "cached_run", "whole_func_string": "def cached_run(options, run_args, **run_kwargs):\n    run_args = [str(arg) for arg in run_args]                      \n    args = parser.parse_args(run_args[1:])\n\n    if args.imagename in ('stdin', '-'):\n        return run(run_args, **run_kwargs)\n\n    source_file = options.input_file\n    cache_folder = get_cache_folder(source_file, run_args, args)\n    cache_folder.mkdir(parents=True, exist_ok=True)\n\n    log.debug(f\"Using Tesseract cache {cache_folder}\")\n\n    if (cache_folder / 'stderr.bin').exists():\n        log.debug(\"Cache HIT\")\n\n                              \n        if args.outputbase != 'stdout':\n            if not args.configfiles:\n                args.configfiles.append('txt')\n            for configfile in args.configfiles:\n                                    \n                tessfile = args.outputbase + '.' + configfile\n                shutil.copy(str(cache_folder / configfile) + '.bin', tessfile)\n        return CompletedProcess(\n            args=run_args,\n            returncode=0,\n            stdout=(cache_folder / 'stdout.bin').read_bytes(),\n            stderr=(cache_folder / 'stderr.bin').read_bytes(),\n        )\n\n    log.debug(\"Cache MISS\")\n\n    cache_kwargs = {\n        k: v for k, v in run_kwargs.items() if k not in ('stdout', 'stderr')\n    }\n    assert cache_kwargs['check']\n    try:\n        p = run(run_args, stdout=PIPE, stderr=PIPE, **cache_kwargs)\n    except CalledProcessError as e:\n        log.exception(e)\n        raise                         \n\n                  \n    (cache_folder / 'stdout.bin').write_bytes(p.stdout)\n    (cache_folder / 'stderr.bin').write_bytes(p.stderr)\n\n    if args.outputbase != 'stdout':\n        if not args.configfiles:\n            args.configfiles.append('txt')\n\n        for configfile in args.configfiles:\n            if configfile not in ('hocr', 'pdf', 'txt'):\n                continue\n                                                                      \n            tessfile = args.outputbase + '.' + configfile\n            shutil.copy(tessfile, str(cache_folder / configfile) + '.bin')\n\n    def clean_sys_argv():\n        for arg in run_args[1:]:\n            yield re.sub(r'.*/ocrmypdf[.]io[.][^/]+[/](.*)', r'$TMPDIR/\\1', arg)\n\n    manifest = {\n        'tesseract_version': TesseractOcrEngine.version().replace('\\n', ' '),\n        'system': platform.system(),\n        'python': platform.python_version(),\n        'argv_slug': cache_folder.name,\n        'sourcefile': str(Path(source_file).relative_to(TESTS_ROOT)),\n        'args': list(clean_sys_argv()),\n    }\n\n    with (Path(CACHE_ROOT) / 'manifest.jsonl').open('a') as f:\n        json.dump(manifest, f)\n        f.write('\\n')\n        f.flush()\n    return p", "func_code_string": "def cached_run(options, run_args, **run_kwargs):\n    run_args = [str(arg) for arg in run_args]                      \n    args = parser.parse_args(run_args[1:])\n\n    if args.imagename in ('stdin', '-'):\n        return run(run_args, **run_kwargs)\n\n    source_file = options.input_file\n    cache_folder = get_cache_folder(source_file, run_args, args)\n    cache_folder.mkdir(parents=True, exist_ok=True)\n\n    log.debug(f\"Using Tesseract cache {cache_folder}\")\n\n    if (cache_folder / 'stderr.bin').exists():\n        log.debug(\"Cache HIT\")\n\n                              \n        if args.outputbase != 'stdout':\n            if not args.configfiles:\n                args.configfiles.append('txt')\n            for configfile in args.configfiles:\n                                    \n                tessfile = args.outputbase + '.' + configfile\n                shutil.copy(str(cache_folder / configfile) + '.bin', tessfile)\n        return CompletedProcess(\n            args=run_args,\n            returncode=0,\n            stdout=(cache_folder / 'stdout.bin').read_bytes(),\n            stderr=(cache_folder / 'stderr.bin').read_bytes(),\n        )\n\n    log.debug(\"Cache MISS\")\n\n    cache_kwargs = {\n        k: v for k, v in run_kwargs.items() if k not in ('stdout', 'stderr')\n    }\n    assert cache_kwargs['check']\n    try:\n        p = run(run_args, stdout=PIPE, stderr=PIPE, **cache_kwargs)\n    except CalledProcessError as e:\n        log.exception(e)\n        raise                         \n\n                  \n    (cache_folder / 'stdout.bin').write_bytes(p.stdout)\n    (cache_folder / 'stderr.bin').write_bytes(p.stderr)\n\n    if args.outputbase != 'stdout':\n        if not args.configfiles:\n            args.configfiles.append('txt')\n\n        for configfile in args.configfiles:\n            if configfile not in ('hocr', 'pdf', 'txt'):\n                continue\n                                                                      \n            tessfile = args.outputbase + '.' + configfile\n            shutil.copy(tessfile, str(cache_folder / configfile) + '.bin')\n\n    def clean_sys_argv():\n        for arg in run_args[1:]:\n            yield re.sub(r'.*/ocrmypdf[.]io[.][^/]+[/](.*)', r'$TMPDIR/\\1', arg)\n\n    manifest = {\n        'tesseract_version': TesseractOcrEngine.version().replace('\\n', ' '),\n        'system': platform.system(),\n        'python': platform.python_version(),\n        'argv_slug': cache_folder.name,\n        'sourcefile': str(Path(source_file).relative_to(TESTS_ROOT)),\n        'args': list(clean_sys_argv()),\n    }\n\n    with (Path(CACHE_ROOT) / 'manifest.jsonl').open('a') as f:\n        json.dump(manifest, f)\n        f.write('\\n')\n        f.flush()\n    return p", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "CacheOcrEngine", "whole_func_string": "class CacheOcrEngine(TesseractOcrEngine):\n                                                                              \n                                                                         \n                                                                                    \n                                                   \n    lock = threading.Lock()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class CacheOcrEngine(TesseractOcrEngine):\n                                                                              \n                                                                         \n                                                                                    \n                                                   \n    lock = threading.Lock()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return CacheOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return CacheOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "slugs", "whole_func_string": "def slugs():\n        yield ''                                                         \n        for arg in run_args[1:]:\n            if arg == parsed_args.imagename:\n                yield Path(parsed_args.imagename).name\n            elif arg == parsed_args.outputbase:\n                yield Path(parsed_args.outputbase).name\n            elif arg == '-c' or arg.startswith('textonly'):\n                pass\n            else:\n                yield arg", "func_code_string": "def slugs():\n        yield ''                                                         \n        for arg in run_args[1:]:\n            if arg == parsed_args.imagename:\n                yield Path(parsed_args.imagename).name\n            elif arg == parsed_args.outputbase:\n                yield Path(parsed_args.outputbase).name\n            elif arg == '-c' or arg.startswith('textonly'):\n                pass\n            else:\n                yield arg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "clean_sys_argv", "whole_func_string": "def clean_sys_argv():\n        for arg in run_args[1:]:\n            yield re.sub(r'.*/ocrmypdf[.]io[.][^/]+[/](.*)', r'$TMPDIR/\\1', arg)", "func_code_string": "def clean_sys_argv():\n        for arg in run_args[1:]:\n            yield re.sub(r'.*/ocrmypdf[.]io[.][^/]+[/](.*)', r'$TMPDIR/\\1', arg)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_code_string": "def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "get_deskew", "whole_func_string": "def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)", "func_code_string": "def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "raise_size_exception", "whole_func_string": "def raise_size_exception(*args, **kwargs):\n    raise CalledProcessError(\n        1,\n        'tesseract',\n        output=b\"Image too large: (33830, 14959)\\nError during processing.\",\n        stderr=b\"\",\n    )", "func_code_string": "def raise_size_exception(*args, **kwargs):\n    raise CalledProcessError(\n        1,\n        'tesseract',\n        output=b\"Image too large: (33830, 14959)\\nError during processing.\",\n        stderr=b\"\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "patch_tesseract_run", "whole_func_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = raise_size_exception\n        yield\n        mock.assert_called()", "func_code_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = raise_size_exception\n        yield\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "BigImageErrorOcrEngine", "whole_func_string": "class BigImageErrorOcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class BigImageErrorOcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return BigImageErrorOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return BigImageErrorOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_code_string": "def get_orientation(input_file, options):\n        with patch_tesseract_run():\n            return TesseractOcrEngine.get_orientation(input_file, options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_big_image_error.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_render_failure.py", "func_name": "raise_gs_fail", "whole_func_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_render_failure.py\"\n    )", "func_code_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_render_failure.py\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_render_failure.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = raise_gs_fail\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = raise_gs_fail\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_soft_error.py", "func_name": "fail_if_stoponerror", "whole_func_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run(args, **kwargs)", "func_code_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run(args, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_soft_error.py", "func_name": "rasterize_pdf_page", "whole_func_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "bad_utf8", "whole_func_string": "def bad_utf8(*args, **kwargs):\n    raise CalledProcessError(\n        1,\n        'tesseract',\n        output=b'\\x96\\xb3\\x8c\\xf8\\x82\\xc8UTF-8\\x0a',                                \n        stderr=b\"\",\n    )", "func_code_string": "def bad_utf8(*args, **kwargs):\n    raise CalledProcessError(\n        1,\n        'tesseract',\n        output=b'\\x96\\xb3\\x8c\\xf8\\x82\\xc8UTF-8\\x0a',                                \n        stderr=b\"\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "patch_tesseract_run", "whole_func_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = bad_utf8\n        yield\n        mock.assert_called()", "func_code_string": "def patch_tesseract_run():\n    with patch('ocrmypdf._exec.tesseract.run') as mock:\n        mock.side_effect = bad_utf8\n        yield\n        mock.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "BadUtf8OcrEngine", "whole_func_string": "class BadUtf8OcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class BadUtf8OcrEngine(TesseractOcrEngine):\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return BadUtf8OcrEngine()", "func_code_string": "def get_ocr_engine():\n    return BadUtf8OcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with patch_tesseract_run():\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_pdfa_failure.py", "func_name": "run_rig_args", "whole_func_string": "def run_rig_args(args, **kwargs):\n                                                                      \n                                                                    \n                                     \n    new_args = [\n        arg for arg in args if not arg.startswith('-dPDFA') and not arg.endswith('.ps')\n    ]\n    proc = run_polling_stderr(new_args, **kwargs)\n    return proc", "func_code_string": "def run_rig_args(args, **kwargs):\n                                                                      \n                                                                    \n                                     \n    new_args = [\n        arg for arg in args if not arg.startswith('-dPDFA') and not arg.endswith('.ps')\n    ]\n    proc = run_polling_stderr(new_args, **kwargs)\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_pdfa_failure.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = run_rig_args\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = run_rig_args\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_feature_elision.py", "func_name": "run_append_stderr", "whole_func_string": "def run_append_stderr(*args, **kwargs):\n    proc = run_polling_stderr(*args, **kwargs)\n    proc.stderr += '\\n' + ELISION_WARNING + '\\n'\n    return proc", "func_code_string": "def run_append_stderr(*args, **kwargs):\n    proc = run_polling_stderr(*args, **kwargs)\n    proc.stderr += '\\n' + ELISION_WARNING + '\\n'\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_feature_elision.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = run_append_stderr\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called_once()\n    return output_file", "func_code_string": "def generate_pdfa(pdf_pages, pdfmark, output_file, context, pdf_version, pdfa_part):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = run_append_stderr\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called_once()\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "Page4Engine", "whole_func_string": "class Page4Engine(NoopOcrEngine):                \n    def __str__(self):\n        return f\"NO-OP Page 4 {NoopOcrEngine.version()}\"\n\n    @staticmethod\n    def generate_hocr(input_file: Path, output_hocr, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class Page4Engine(NoopOcrEngine):                \n    def __str__(self):\n        return f\"NO-OP Page 4 {NoopOcrEngine.version()}\"\n\n    @staticmethod\n    def generate_hocr(input_file: Path, output_hocr, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "check_options", "whole_func_string": "def check_options(options):\n    if options.use_threads:\n        raise ValueError(\"I'm not compatible with use_threads\")", "func_code_string": "def check_options(options):\n    if options.use_threads:\n        raise ValueError(\"I'm not compatible with use_threads\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return Page4Engine()", "func_code_string": "def get_ocr_engine():\n    return Page4Engine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n        return f\"NO-OP Page 4 {NoopOcrEngine.version()}\"", "func_code_string": "def __str__(self):\n        return f\"NO-OP Page 4 {NoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file: Path, output_hocr, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_code_string": "def generate_hocr(input_file: Path, output_hocr, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_simulate_oom_killer.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        if input_file.stem.startswith('000004'):\n                     \n            os.kill(os.getpid(), signal.SIGKILL)\n        else:\n            return NoopOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_render_soft_error.py", "func_name": "fail_if_stoponerror", "whole_func_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run_polling_stderr(args, **kwargs)", "func_code_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run_polling_stderr(args, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_render_soft_error.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(\n    pdf_pages,\n    pdfmark,\n    output_file,\n    context,\n    pdf_version,\n    pdfa_part,\n    stop_on_soft_error,\n):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def generate_pdfa(\n    pdf_pages,\n    pdfmark,\n    output_file,\n    context,\n    pdf_version,\n    pdfa_part,\n    stop_on_soft_error,\n):\n    with patch('ocrmypdf._exec.ghostscript.run_polling_stderr') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.generate_pdfa(\n            pdf_pages=pdf_pages,\n            pdfmark=pdfmark,\n            output_file=output_file,\n            context=context,\n            pdf_version=pdf_version,\n            pdfa_part=pdfa_part,\n            progressbar_class=None,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_failure.py", "func_name": "raise_gs_fail", "whole_func_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_raster_failure.py\"\n    )", "func_code_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_raster_failure.py\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_failure.py", "func_name": "rasterize_pdf_page", "whole_func_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi=None,\n    rotation=None,\n    filter_vector=False,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = raise_gs_fail\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi=None,\n    rotation=None,\n    filter_vector=False,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = raise_gs_fail\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=True,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "docs/conf.py", "func_name": "Mock", "whole_func_string": "class Mock(MagicMock):\n        @classmethod\n        def __getattr__(cls, name):\n            return MagicMock()", "func_code_string": "class Mock(MagicMock):\n        @classmethod\n        def __getattr__(cls, name):\n            return MagicMock()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "docs/conf.py", "func_name": "__getattr__", "whole_func_string": "def __getattr__(cls, name):\n            return MagicMock()", "func_code_string": "def __getattr__(cls, name):\n            return MagicMock()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "XrefExt", "whole_func_string": "class XrefExt(NamedTuple):\n                                              \n\n    xref: Xref\n    ext: str", "func_code_string": "class XrefExt(NamedTuple):\n                                              \n\n    xref: Xref\n    ext: str", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "img_name", "whole_func_string": "def img_name(root: Path, xref: Xref, ext: str) -> Path:\n                                                                          \n    return root / f'{xref:08d}{ext}'", "func_code_string": "def img_name(root: Path, xref: Xref, ext: str) -> Path:\n                                                                          \n    return root / f'{xref:08d}{ext}'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "png_name", "whole_func_string": "def png_name(root: Path, xref: Xref) -> Path:\n                                                         \n    return img_name(root, xref, '.png')", "func_code_string": "def png_name(root: Path, xref: Xref) -> Path:\n                                                         \n    return img_name(root, xref, '.png')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "jpg_name", "whole_func_string": "def jpg_name(root: Path, xref: Xref) -> Path:\n                                                          \n    return img_name(root, xref, '.jpg')", "func_code_string": "def jpg_name(root: Path, xref: Xref) -> Path:\n                                                          \n    return img_name(root, xref, '.jpg')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_image_filter", "whole_func_string": "def extract_image_filter(\n    image: Stream, xref: Xref\n) -> tuple[PdfImage, tuple[Name, Object]] | None:\n                                               \n    if image.Subtype != Name.Image:\n        return None\n    if not isinstance(image.Length, int) or image.Length < 100:\n        log.debug(f\"xref {xref}: skipping image with small stream size\")\n        return None\n    if (\n        not isinstance(image.Width, int)\n        or not isinstance(image.Height, int)\n        or image.Width < 8\n        or image.Height < 8\n    ):             \n        log.debug(f\"xref {xref}: skipping image with unusually small dimensions\")\n        return None\n\n    pim = PdfImage(image)\n\n    if len(pim.filter_decodeparms) > 1:\n        first_filtdp = pim.filter_decodeparms[0]\n        second_filtdp = pim.filter_decodeparms[1]\n        if (\n            len(pim.filter_decodeparms) == 2\n            and first_filtdp[0] == Name.FlateDecode\n            and first_filtdp[1] is not None\n            and first_filtdp[1].get(Name.Predictor, 1) == 1\n            and second_filtdp[0] == Name.DCTDecode\n            and not second_filtdp[1]\n        ):\n            log.debug(\n                f\"xref {xref}: found image compressed as /FlateDecode /DCTDecode, \"\n                \"marked for JPEG optimization\"\n            )\n            filtdp = pim.filter_decodeparms[1]\n        else:\n            log.debug(f\"xref {xref}: skipping image with multiple compression filters\")\n            return None\n    else:\n        filtdp = pim.filter_decodeparms[0]\n\n    if pim.bits_per_component > 8:\n        log.debug(f\"xref {xref}: skipping wide gamut image\")\n        return None                                     \n\n    if filtdp[0] == Name.JPXDecode:\n        log.debug(f\"xref {xref}: skipping JPEG2000 image\")\n        return None                     \n\n    if filtdp[0] == Name.CCITTFaxDecode and filtdp[1].get('/K', 0) >= 0:\n        log.debug(f\"xref {xref}: skipping CCITT Group 3 image\")\n        return None                                       \n\n    if Name.Decode in image:\n        log.debug(f\"xref {xref}: skipping image with Decode table\")\n        return None                                        \n\n    return pim, filtdp", "func_code_string": "def extract_image_filter(\n    image: Stream, xref: Xref\n) -> tuple[PdfImage, tuple[Name, Object]] | None:\n                                               \n    if image.Subtype != Name.Image:\n        return None\n    if not isinstance(image.Length, int) or image.Length < 100:\n        log.debug(f\"xref {xref}: skipping image with small stream size\")\n        return None\n    if (\n        not isinstance(image.Width, int)\n        or not isinstance(image.Height, int)\n        or image.Width < 8\n        or image.Height < 8\n    ):             \n        log.debug(f\"xref {xref}: skipping image with unusually small dimensions\")\n        return None\n\n    pim = PdfImage(image)\n\n    if len(pim.filter_decodeparms) > 1:\n        first_filtdp = pim.filter_decodeparms[0]\n        second_filtdp = pim.filter_decodeparms[1]\n        if (\n            len(pim.filter_decodeparms) == 2\n            and first_filtdp[0] == Name.FlateDecode\n            and first_filtdp[1] is not None\n            and first_filtdp[1].get(Name.Predictor, 1) == 1\n            and second_filtdp[0] == Name.DCTDecode\n            and not second_filtdp[1]\n        ):\n            log.debug(\n                f\"xref {xref}: found image compressed as /FlateDecode /DCTDecode, \"\n                \"marked for JPEG optimization\"\n            )\n            filtdp = pim.filter_decodeparms[1]\n        else:\n            log.debug(f\"xref {xref}: skipping image with multiple compression filters\")\n            return None\n    else:\n        filtdp = pim.filter_decodeparms[0]\n\n    if pim.bits_per_component > 8:\n        log.debug(f\"xref {xref}: skipping wide gamut image\")\n        return None                                     \n\n    if filtdp[0] == Name.JPXDecode:\n        log.debug(f\"xref {xref}: skipping JPEG2000 image\")\n        return None                     \n\n    if filtdp[0] == Name.CCITTFaxDecode and filtdp[1].get('/K', 0) >= 0:\n        log.debug(f\"xref {xref}: skipping CCITT Group 3 image\")\n        return None                                       \n\n    if Name.Decode in image:\n        log.debug(f\"xref {xref}: skipping image with Decode table\")\n        return None                                        \n\n    return pim, filtdp", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_image_jbig2", "whole_func_string": "def extract_image_jbig2(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                                      \n    del options              \n\n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n    if (\n        pim.bits_per_component == 1\n        and filtdp[0] != Name.JBIG2Decode\n        and jbig2enc.available()\n    ):\n                                                                   \n                                                                      \n                                                                         \n                                                                          \n                           \n        colorspace = pim.obj.get(Name.ColorSpace, None)\n        if colorspace is not None or pim.image_mask:\n            try:\n                                                                     \n                pim.obj.ColorSpace = Name.DeviceGray\n                imgname = root / f'{xref:08d}'\n                with imgname.open('wb') as f:\n                    ext = pim.extract_to(stream=f)\n                                                                   \n                                                                      \n                                                        \n                imgname.rename(imgname.with_suffix(\".prejbig2\" + ext))\n            except NotImplementedError as e:\n                if '/Decode' in str(e):\n                    log.debug(\n                        f\"xref {xref}: skipping image with unsupported Decode table\"\n                    )\n                    return None\n                raise\n            except UnsupportedImageTypeError:\n                return None\n            finally:\n                                                                                     \n                if colorspace is not None:\n                    pim.obj.ColorSpace = colorspace\n                else:\n                    del pim.obj.ColorSpace\n            return XrefExt(xref, \".prejbig2\" + ext)\n    return None", "func_code_string": "def extract_image_jbig2(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                                      \n    del options              \n\n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n    if (\n        pim.bits_per_component == 1\n        and filtdp[0] != Name.JBIG2Decode\n        and jbig2enc.available()\n    ):\n                                                                   \n                                                                      \n                                                                         \n                                                                          \n                           \n        colorspace = pim.obj.get(Name.ColorSpace, None)\n        if colorspace is not None or pim.image_mask:\n            try:\n                                                                     \n                pim.obj.ColorSpace = Name.DeviceGray\n                imgname = root / f'{xref:08d}'\n                with imgname.open('wb') as f:\n                    ext = pim.extract_to(stream=f)\n                                                                   \n                                                                      \n                                                        \n                imgname.rename(imgname.with_suffix(\".prejbig2\" + ext))\n            except NotImplementedError as e:\n                if '/Decode' in str(e):\n                    log.debug(\n                        f\"xref {xref}: skipping image with unsupported Decode table\"\n                    )\n                    return None\n                raise\n            except UnsupportedImageTypeError:\n                return None\n            finally:\n                                                                                     \n                if colorspace is not None:\n                    pim.obj.ColorSpace = colorspace\n                else:\n                    del pim.obj.ColorSpace\n            return XrefExt(xref, \".prejbig2\" + ext)\n    return None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_image_generic", "whole_func_string": "def extract_image_generic(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                   \n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n                                                                        \n    if pim.bits_per_component == 1:\n        return None\n\n    if filtdp[0] == Name.DCTDecode and options.optimize >= 2:\n                                                                              \n                                                                          \n                                                                             \n                   \n                                                          \n                                                                    \n                                        \n                         \n        try:\n            imgname = root / f'{xref:08d}'\n            with imgname.open('wb') as f:\n                ext = pim.extract_to(stream=f)\n            imgname.rename(imgname.with_suffix(ext))\n        except (UnsupportedImageTypeError, HifiPrintImageNotTranscodableError):\n            return None\n        return XrefExt(xref, ext)\n    elif (\n        pim.indexed\n        and pim.colorspace in pim.SIMPLE_COLORSPACES\n        and options.optimize >= 3\n    ):\n                                                                           \n                             \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n    elif not pim.indexed and pim.colorspace in pim.SIMPLE_COLORSPACES:\n                                                                            \n                                               \n        try:\n            pim.as_pil_image().save(png_name(root, xref))\n        except NotImplementedError:\n            log.warning(\"PDF contains an atypical image that cannot be optimized.\")\n            return None\n        return XrefExt(xref, '.png')\n    elif (\n        not pim.indexed\n        and pim.colorspace == Name.ICCBased\n        and pim.bits_per_component == 1\n        and not options.jbig2_lossy\n    ):\n                                                                           \n                                                                           \n                     \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n\n    return None", "func_code_string": "def extract_image_generic(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                   \n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n                                                                        \n    if pim.bits_per_component == 1:\n        return None\n\n    if filtdp[0] == Name.DCTDecode and options.optimize >= 2:\n                                                                              \n                                                                          \n                                                                             \n                   \n                                                          \n                                                                    \n                                        \n                         \n        try:\n            imgname = root / f'{xref:08d}'\n            with imgname.open('wb') as f:\n                ext = pim.extract_to(stream=f)\n            imgname.rename(imgname.with_suffix(ext))\n        except (UnsupportedImageTypeError, HifiPrintImageNotTranscodableError):\n            return None\n        return XrefExt(xref, ext)\n    elif (\n        pim.indexed\n        and pim.colorspace in pim.SIMPLE_COLORSPACES\n        and options.optimize >= 3\n    ):\n                                                                           \n                             \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n    elif not pim.indexed and pim.colorspace in pim.SIMPLE_COLORSPACES:\n                                                                            \n                                               \n        try:\n            pim.as_pil_image().save(png_name(root, xref))\n        except NotImplementedError:\n            log.warning(\"PDF contains an atypical image that cannot be optimized.\")\n            return None\n        return XrefExt(xref, '.png')\n    elif (\n        not pim.indexed\n        and pim.colorspace == Name.ICCBased\n        and pim.bits_per_component == 1\n        and not options.jbig2_lossy\n    ):\n                                                                           \n                                                                           \n                     \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n\n    return None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_find_image_xrefs_container", "whole_func_string": "def _find_image_xrefs_container(\n    pdf: Pdf,\n    container: Object,\n    pageno: int,\n    include_xrefs: MutableSet[Xref],\n    exclude_xrefs: MutableSet[Xref],\n    pageno_for_xref: dict[Xref, int],\n    depth: int = 0,\n):\n                                                                                   \n    if depth > 10:\n        log.warning(\"Recursion depth exceeded in _find_image_xrefs_page\")\n        return\n    try:\n        xobjs = container.Resources.XObject\n    except AttributeError:\n        return\n    for _imname, image in dict(xobjs).items():\n        if image.objgen[1] != 0:\n            continue                                       \n        xref = Xref(image.objgen[0])\n        if xref in include_xrefs or xref in exclude_xrefs:\n            continue                     \n        if Name.Subtype in image and image.Subtype == Name.Form:\n                                        \n            log.debug(f\"Recursing into Form XObject {_imname} in page {pageno}\")\n            _find_image_xrefs_container(\n                pdf,\n                image,\n                pageno,\n                include_xrefs,\n                exclude_xrefs,\n                pageno_for_xref,\n                depth + 1,\n            )\n            continue\n        if Name.SMask in image:\n                               \n            smask_xref = Xref(image.SMask.objgen[0])\n            exclude_xrefs.add(smask_xref)\n            log.debug(f\"xref {smask_xref}: skipping image because it is an SMask\")\n        include_xrefs.add(xref)\n        log.debug(f\"xref {xref}: treating as an optimization candidate\")\n        if xref not in pageno_for_xref:\n            pageno_for_xref[xref] = pageno", "func_code_string": "def _find_image_xrefs_container(\n    pdf: Pdf,\n    container: Object,\n    pageno: int,\n    include_xrefs: MutableSet[Xref],\n    exclude_xrefs: MutableSet[Xref],\n    pageno_for_xref: dict[Xref, int],\n    depth: int = 0,\n):\n                                                                                   \n    if depth > 10:\n        log.warning(\"Recursion depth exceeded in _find_image_xrefs_page\")\n        return\n    try:\n        xobjs = container.Resources.XObject\n    except AttributeError:\n        return\n    for _imname, image in dict(xobjs).items():\n        if image.objgen[1] != 0:\n            continue                                       \n        xref = Xref(image.objgen[0])\n        if xref in include_xrefs or xref in exclude_xrefs:\n            continue                     \n        if Name.Subtype in image and image.Subtype == Name.Form:\n                                        \n            log.debug(f\"Recursing into Form XObject {_imname} in page {pageno}\")\n            _find_image_xrefs_container(\n                pdf,\n                image,\n                pageno,\n                include_xrefs,\n                exclude_xrefs,\n                pageno_for_xref,\n                depth + 1,\n            )\n            continue\n        if Name.SMask in image:\n                               \n            smask_xref = Xref(image.SMask.objgen[0])\n            exclude_xrefs.add(smask_xref)\n            log.debug(f\"xref {smask_xref}: skipping image because it is an SMask\")\n        include_xrefs.add(xref)\n        log.debug(f\"xref {xref}: treating as an optimization candidate\")\n        if xref not in pageno_for_xref:\n            pageno_for_xref[xref] = pageno", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_find_image_xrefs", "whole_func_string": "def _find_image_xrefs(pdf: Pdf):\n    include_xrefs: MutableSet[Xref] = set()\n    exclude_xrefs: MutableSet[Xref] = set()\n    pageno_for_xref: dict[Xref, int] = {}\n\n    for pageno, page in enumerate(pdf.pages):\n        _find_image_xrefs_container(\n            pdf, page.obj, pageno, include_xrefs, exclude_xrefs, pageno_for_xref\n        )\n\n    working_xrefs = include_xrefs - exclude_xrefs\n    return working_xrefs, pageno_for_xref", "func_code_string": "def _find_image_xrefs(pdf: Pdf):\n    include_xrefs: MutableSet[Xref] = set()\n    exclude_xrefs: MutableSet[Xref] = set()\n    pageno_for_xref: dict[Xref, int] = {}\n\n    for pageno, page in enumerate(pdf.pages):\n        _find_image_xrefs_container(\n            pdf, page.obj, pageno, include_xrefs, exclude_xrefs, pageno_for_xref\n        )\n\n    working_xrefs = include_xrefs - exclude_xrefs\n    return working_xrefs, pageno_for_xref", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_images", "whole_func_string": "def extract_images(\n    pdf: Pdf,\n    root: Path,\n    options,\n    extract_fn: Callable[..., XrefExt | None],\n) -> Iterator[tuple[int, XrefExt]]:\n           \n    errors = 0\n    working_xrefs, pageno_for_xref = _find_image_xrefs(pdf)\n    for xref in working_xrefs:\n        image = pdf.get_object((xref, 0))\n        try:\n            result = extract_fn(\n                pdf=pdf, root=root, image=image, xref=xref, options=options\n            )\n        except Exception:                                \n            log.exception(\n                f\"xref {xref}: While extracting this image, an error occurred\"\n            )\n            errors += 1\n        else:\n            if result:\n                _, ext = result\n                yield pageno_for_xref[xref], XrefExt(xref, ext)", "func_code_string": "def extract_images(\n    pdf: Pdf,\n    root: Path,\n    options,\n    extract_fn: Callable[..., XrefExt | None],\n) -> Iterator[tuple[int, XrefExt]]:\n           \n    errors = 0\n    working_xrefs, pageno_for_xref = _find_image_xrefs(pdf)\n    for xref in working_xrefs:\n        image = pdf.get_object((xref, 0))\n        try:\n            result = extract_fn(\n                pdf=pdf, root=root, image=image, xref=xref, options=options\n            )\n        except Exception:                                \n            log.exception(\n                f\"xref {xref}: While extracting this image, an error occurred\"\n            )\n            errors += 1\n        else:\n            if result:\n                _, ext = result\n                yield pageno_for_xref[xref], XrefExt(xref, ext)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_images_generic", "whole_func_string": "def extract_images_generic(\n    pdf: Pdf, root: Path, options\n) -> tuple[list[Xref], list[Xref]]:\n                                                           \n    jpegs = []\n    pngs = []\n    for _, xref_ext in extract_images(pdf, root, options, extract_image_generic):\n        log.debug('%s', xref_ext)\n        if xref_ext.ext == '.png':\n            pngs.append(xref_ext.xref)\n        elif xref_ext.ext == '.jpg':\n            jpegs.append(xref_ext.xref)\n    log.debug(f\"Optimizable images: JPEGs: {len(jpegs)} PNGs: {len(pngs)}\")\n    return jpegs, pngs", "func_code_string": "def extract_images_generic(\n    pdf: Pdf, root: Path, options\n) -> tuple[list[Xref], list[Xref]]:\n                                                           \n    jpegs = []\n    pngs = []\n    for _, xref_ext in extract_images(pdf, root, options, extract_image_generic):\n        log.debug('%s', xref_ext)\n        if xref_ext.ext == '.png':\n            pngs.append(xref_ext.xref)\n        elif xref_ext.ext == '.jpg':\n            jpegs.append(xref_ext.xref)\n    log.debug(f\"Optimizable images: JPEGs: {len(jpegs)} PNGs: {len(pngs)}\")\n    return jpegs, pngs", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_images_jbig2", "whole_func_string": "def extract_images_jbig2(pdf: Pdf, root: Path, options) -> dict[int, list[XrefExt]]:\n                                                                          \n    jbig2_groups = defaultdict(list)\n    for pageno, xref_ext in extract_images(pdf, root, options, extract_image_jbig2):\n        group = pageno // options.jbig2_page_group_size\n        jbig2_groups[group].append(xref_ext)\n\n    log.debug(f\"Optimizable images: JBIG2 groups: {len(jbig2_groups)}\")\n    return jbig2_groups", "func_code_string": "def extract_images_jbig2(pdf: Pdf, root: Path, options) -> dict[int, list[XrefExt]]:\n                                                                          \n    jbig2_groups = defaultdict(list)\n    for pageno, xref_ext in extract_images(pdf, root, options, extract_image_jbig2):\n        group = pageno // options.jbig2_page_group_size\n        jbig2_groups[group].append(xref_ext)\n\n    log.debug(f\"Optimizable images: JBIG2 groups: {len(jbig2_groups)}\")\n    return jbig2_groups", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_produce_jbig2_images", "whole_func_string": "def _produce_jbig2_images(\n    jbig2_groups: dict[int, list[XrefExt]], root: Path, options, executor: Executor\n) -> None:\n                                                 \n\n    def jbig2_group_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n            yield (\n                fspath(root),        \n                (img_name(root, xref, ext) for xref, ext in xref_exts),            \n                prefix,               \n                options.jbig2_threshold,\n            )\n\n    def jbig2_single_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n                                                                            \n            for n, xref_ext in enumerate(xref_exts):\n                xref, ext = xref_ext\n                yield (\n                    fspath(root),\n                    img_name(root, xref, ext),\n                    root / f'{prefix}.{n:04d}',\n                    options.jbig2_threshold,\n                )\n\n    if options.jbig2_page_group_size > 1:\n        jbig2_args = jbig2_group_args\n        jbig2_convert = jbig2enc.convert_group\n    else:\n        jbig2_args = jbig2_single_args\n        jbig2_convert = jbig2enc.convert_single\n\n    executor(\n        use_threads=True,\n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            total=len(jbig2_groups),\n            desc=\"JBIG2\",\n            unit='item',\n            disable=not options.progress_bar,\n        ),\n        task=jbig2_convert,\n        task_arguments=jbig2_args(root, jbig2_groups),\n    )", "func_code_string": "def _produce_jbig2_images(\n    jbig2_groups: dict[int, list[XrefExt]], root: Path, options, executor: Executor\n) -> None:\n                                                 \n\n    def jbig2_group_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n            yield (\n                fspath(root),        \n                (img_name(root, xref, ext) for xref, ext in xref_exts),            \n                prefix,               \n                options.jbig2_threshold,\n            )\n\n    def jbig2_single_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n                                                                            \n            for n, xref_ext in enumerate(xref_exts):\n                xref, ext = xref_ext\n                yield (\n                    fspath(root),\n                    img_name(root, xref, ext),\n                    root / f'{prefix}.{n:04d}',\n                    options.jbig2_threshold,\n                )\n\n    if options.jbig2_page_group_size > 1:\n        jbig2_args = jbig2_group_args\n        jbig2_convert = jbig2enc.convert_group\n    else:\n        jbig2_args = jbig2_single_args\n        jbig2_convert = jbig2enc.convert_single\n\n    executor(\n        use_threads=True,\n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            total=len(jbig2_groups),\n            desc=\"JBIG2\",\n            unit='item',\n            disable=not options.progress_bar,\n        ),\n        task=jbig2_convert,\n        task_arguments=jbig2_args(root, jbig2_groups),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "convert_to_jbig2", "whole_func_string": "def convert_to_jbig2(\n    pdf: Pdf,\n    jbig2_groups: dict[int, list[XrefExt]],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n           \n    jbig2_globals_dict: Dictionary | None\n\n    _produce_jbig2_images(jbig2_groups, root, options, executor)\n\n    for group, xref_exts in jbig2_groups.items():\n        prefix = f'group{group:08d}'\n        jbig2_symfile = root / (prefix + '.sym')\n        if jbig2_symfile.exists():\n            jbig2_globals_data = jbig2_symfile.read_bytes()\n            jbig2_globals = Stream(pdf, jbig2_globals_data)\n            jbig2_globals_dict = Dictionary(JBIG2Globals=jbig2_globals)\n        elif options.jbig2_page_group_size == 1:\n            jbig2_globals_dict = None\n        else:\n            raise FileNotFoundError(jbig2_symfile)\n\n        for n, xref_ext in enumerate(xref_exts):\n            xref, _ = xref_ext\n            jbig2_im_file = root / (prefix + f'.{n:04d}')\n            jbig2_im_data = jbig2_im_file.read_bytes()\n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(\n                jbig2_im_data, filter=Name.JBIG2Decode, decode_parms=jbig2_globals_dict\n            )", "func_code_string": "def convert_to_jbig2(\n    pdf: Pdf,\n    jbig2_groups: dict[int, list[XrefExt]],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n           \n    jbig2_globals_dict: Dictionary | None\n\n    _produce_jbig2_images(jbig2_groups, root, options, executor)\n\n    for group, xref_exts in jbig2_groups.items():\n        prefix = f'group{group:08d}'\n        jbig2_symfile = root / (prefix + '.sym')\n        if jbig2_symfile.exists():\n            jbig2_globals_data = jbig2_symfile.read_bytes()\n            jbig2_globals = Stream(pdf, jbig2_globals_data)\n            jbig2_globals_dict = Dictionary(JBIG2Globals=jbig2_globals)\n        elif options.jbig2_page_group_size == 1:\n            jbig2_globals_dict = None\n        else:\n            raise FileNotFoundError(jbig2_symfile)\n\n        for n, xref_ext in enumerate(xref_exts):\n            xref, _ = xref_ext\n            jbig2_im_file = root / (prefix + f'.{n:04d}')\n            jbig2_im_data = jbig2_im_file.read_bytes()\n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(\n                jbig2_im_data, filter=Name.JBIG2Decode, decode_parms=jbig2_globals_dict\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_optimize_jpeg", "whole_func_string": "def _optimize_jpeg(\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\n) -> tuple[Xref, Path | None]:\n    with Image.open(in_jpg) as im:\n        im.save(opt_jpg, optimize=True, quality=jpeg_quality)\n\n    if opt_jpg.stat().st_size > in_jpg.stat().st_size:\n        log.debug(f\"xref {xref}, jpeg, made larger - skip\")\n        opt_jpg.unlink()\n        return xref, None\n    return xref, opt_jpg", "func_code_string": "def _optimize_jpeg(\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\n) -> tuple[Xref, Path | None]:\n    with Image.open(in_jpg) as im:\n        im.save(opt_jpg, optimize=True, quality=jpeg_quality)\n\n    if opt_jpg.stat().st_size > in_jpg.stat().st_size:\n        log.debug(f\"xref {xref}, jpeg, made larger - skip\")\n        opt_jpg.unlink()\n        return xref, None\n    return xref, opt_jpg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "transcode_jpegs", "whole_func_string": "def transcode_jpegs(\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\n) -> None:\n                                                            \n\n    def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality\n\n    def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                   \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Recompressing JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_optimize_jpeg,\n        task_arguments=jpeg_args(),\n        task_finished=finish_jpeg,\n    )", "func_code_string": "def transcode_jpegs(\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\n) -> None:\n                                                            \n\n    def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality\n\n    def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                   \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Recompressing JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_optimize_jpeg,\n        task_arguments=jpeg_args(),\n        task_finished=finish_jpeg,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_find_deflatable_jpeg", "whole_func_string": "def _find_deflatable_jpeg(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    _pim, filtdp = result\n\n    if filtdp[0] == Name.DCTDecode and not filtdp[1] and options.optimize >= 1:\n        return XrefExt(xref, '.memory')\n\n    return None", "func_code_string": "def _find_deflatable_jpeg(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    _pim, filtdp = result\n\n    if filtdp[0] == Name.DCTDecode and not filtdp[1] and options.optimize >= 1:\n        return XrefExt(xref, '.memory')\n\n    return None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_deflate_jpeg", "whole_func_string": "def _deflate_jpeg(\n    pdf: Pdf, lock: threading.Lock, xref: Xref, complevel: int\n) -> tuple[Xref, bytes]:\n    with lock:\n        xobj = pdf.get_object(xref, 0)\n        try:\n            data = xobj.read_raw_bytes()\n        except PdfError:\n            return xref, b''\n    compdata = compress(data, complevel)\n    if len(compdata) >= len(data):\n        return xref, b''\n    return xref, compdata", "func_code_string": "def _deflate_jpeg(\n    pdf: Pdf, lock: threading.Lock, xref: Xref, complevel: int\n) -> tuple[Xref, bytes]:\n    with lock:\n        xobj = pdf.get_object(xref, 0)\n        try:\n            data = xobj.read_raw_bytes()\n        except PdfError:\n            return xref, b''\n    compdata = compress(data, complevel)\n    if len(compdata) >= len(data):\n        return xref, b''\n    return xref, compdata", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "deflate_jpegs", "whole_func_string": "def deflate_jpegs(pdf: Pdf, root: Path, options, executor: Executor) -> None:\n           \n    jpegs = []\n    for _pageno, xref_ext in extract_images(pdf, root, options, _find_deflatable_jpeg):\n        xref = xref_ext.xref\n        log.debug(f'xref {xref}: marking this JPEG as deflatable')\n        jpegs.append(xref)\n\n    complevel = 9 if options.optimize == 3 else 6\n\n                                                             \n    lock = threading.Lock()\n\n    def deflate_args() -> Iterator:\n        for xref in jpegs:\n            yield pdf, lock, xref, complevel\n\n    def finish(result: tuple[Xref, bytes], pbar: ProgressBar):\n        xref, compdata = result\n        if len(compdata) > 0:\n            with lock:\n                xobj = pdf.get_object(xref, 0)\n                xobj.write(compdata, filter=[Name.FlateDecode, Name.DCTDecode])\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                    \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Deflating JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_deflate_jpeg,\n        task_arguments=deflate_args(),\n        task_finished=finish,\n    )", "func_code_string": "def deflate_jpegs(pdf: Pdf, root: Path, options, executor: Executor) -> None:\n           \n    jpegs = []\n    for _pageno, xref_ext in extract_images(pdf, root, options, _find_deflatable_jpeg):\n        xref = xref_ext.xref\n        log.debug(f'xref {xref}: marking this JPEG as deflatable')\n        jpegs.append(xref)\n\n    complevel = 9 if options.optimize == 3 else 6\n\n                                                             \n    lock = threading.Lock()\n\n    def deflate_args() -> Iterator:\n        for xref in jpegs:\n            yield pdf, lock, xref, complevel\n\n    def finish(result: tuple[Xref, bytes], pbar: ProgressBar):\n        xref, compdata = result\n        if len(compdata) > 0:\n            with lock:\n                xobj = pdf.get_object(xref, 0)\n                xobj.write(compdata, filter=[Name.FlateDecode, Name.DCTDecode])\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                    \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Deflating JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_deflate_jpeg,\n        task_arguments=deflate_args(),\n        task_finished=finish,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_transcode_png", "whole_func_string": "def _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\n    output = filename.with_suffix('.png.pdf')\n    with output.open('wb') as f:\n        img2pdf.convert(fspath(filename), outputstream=f, **IMG2PDF_KWARGS)\n\n    with Pdf.open(output) as pdf_image:\n        foreign_image = next(iter(pdf_image.pages[0].images.values()))\n        local_image = pdf.copy_foreign(foreign_image)\n\n        im_obj = pdf.get_object(xref, 0)\n        im_obj.write(\n            local_image.read_raw_bytes(),\n            filter=local_image.Filter,\n            decode_parms=local_image.DecodeParms,\n        )\n\n                                               \n        del_keys = set(im_obj.keys()) - set(local_image.keys())\n                                                                          \n                                                                          \n                                                                         \n        keep_fields = {\n            '/ID',\n            '/Intent',\n            '/Interpolate',\n            '/Mask',\n            '/Metadata',\n            '/OC',\n            '/OPI',\n            '/SMask',\n            '/StructParent',\n        }\n        del_keys -= keep_fields\n        for key in local_image.keys():\n            if key != Name.Length and str(key) not in keep_fields:\n                im_obj[key] = local_image[key]\n        for key in del_keys:\n            del im_obj[key]\n    return True", "func_code_string": "def _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\n    output = filename.with_suffix('.png.pdf')\n    with output.open('wb') as f:\n        img2pdf.convert(fspath(filename), outputstream=f, **IMG2PDF_KWARGS)\n\n    with Pdf.open(output) as pdf_image:\n        foreign_image = next(iter(pdf_image.pages[0].images.values()))\n        local_image = pdf.copy_foreign(foreign_image)\n\n        im_obj = pdf.get_object(xref, 0)\n        im_obj.write(\n            local_image.read_raw_bytes(),\n            filter=local_image.Filter,\n            decode_parms=local_image.DecodeParms,\n        )\n\n                                               \n        del_keys = set(im_obj.keys()) - set(local_image.keys())\n                                                                          \n                                                                          \n                                                                         \n        keep_fields = {\n            '/ID',\n            '/Intent',\n            '/Interpolate',\n            '/Mask',\n            '/Metadata',\n            '/OC',\n            '/OPI',\n            '/SMask',\n            '/StructParent',\n        }\n        del_keys -= keep_fields\n        for key in local_image.keys():\n            if key != Name.Length and str(key) not in keep_fields:\n                im_obj[key] = local_image[key]\n        for key in del_keys:\n            del im_obj[key]\n    return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "transcode_pngs", "whole_func_string": "def transcode_pngs(\n    pdf: Pdf,\n    images: Sequence[Xref],\n    image_name_fn: Callable[[Path, Xref], Path],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n                                          \n    modified: MutableSet[Xref] = set()\n    if options.optimize >= 2:\n        png_quality = (\n            max(10, options.png_quality - 10),\n            min(100, options.png_quality + 10),\n        )\n\n        def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)\n\n        executor(\n            use_threads=True,\n            max_workers=options.jobs,\n            progress_kwargs=dict(\n                desc=\"PNGs\",\n                total=len(images),\n                unit='image',\n                disable=not options.progress_bar,\n            ),\n            task=pngquant.quantize,\n            task_arguments=pngquant_args(),\n        )\n\n    for xref in modified:\n        filename = png_name(root, xref)\n        _transcode_png(pdf, filename, xref)", "func_code_string": "def transcode_pngs(\n    pdf: Pdf,\n    images: Sequence[Xref],\n    image_name_fn: Callable[[Path, Xref], Path],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n                                          \n    modified: MutableSet[Xref] = set()\n    if options.optimize >= 2:\n        png_quality = (\n            max(10, options.png_quality - 10),\n            min(100, options.png_quality + 10),\n        )\n\n        def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)\n\n        executor(\n            use_threads=True,\n            max_workers=options.jobs,\n            progress_kwargs=dict(\n                desc=\"PNGs\",\n                total=len(images),\n                unit='image',\n                disable=not options.progress_bar,\n            ),\n            task=pngquant.quantize,\n            task_arguments=pngquant_args(),\n        )\n\n    for xref in modified:\n        filename = png_name(root, xref)\n        _transcode_png(pdf, filename, xref)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "optimize", "whole_func_string": "def optimize(\n    input_file: Path,\n    output_file: Path,\n    context: PdfContext,\n    save_settings: dict[str, Any],\n    executor: Executor = DEFAULT_EXECUTOR,\n) -> Path:\n                                        \n    options = context.options\n    if options.optimize == 0:\n        safe_symlink(input_file, output_file)\n        return output_file\n\n    if options.jpeg_quality == 0:\n        options.jpeg_quality = DEFAULT_JPEG_QUALITY if options.optimize < 3 else 40\n    if options.png_quality == 0:\n        options.png_quality = DEFAULT_PNG_QUALITY if options.optimize < 3 else 30\n    if options.jbig2_page_group_size == 0:\n        options.jbig2_page_group_size = 10 if options.jbig2_lossy else 1\n\n    with Pdf.open(input_file) as pdf:\n        root = output_file.parent / 'images'\n        root.mkdir(exist_ok=True)\n\n        jpegs, pngs = extract_images_generic(pdf, root, options)\n        transcode_jpegs(pdf, jpegs, root, options, executor)\n        deflate_jpegs(pdf, root, options, executor)\n                                   \n                                 \n                                                                \n        transcode_pngs(pdf, pngs, png_name, root, options, executor)\n\n        jbig2_groups = extract_images_jbig2(pdf, root, options)\n        convert_to_jbig2(pdf, jbig2_groups, root, options, executor)\n\n        target_file = output_file.with_suffix('.opt.pdf')\n        pdf.remove_unreferenced_resources()\n        pdf.save(target_file, **save_settings)\n\n    input_size = input_file.stat().st_size\n    output_size = target_file.stat().st_size\n    if output_size == 0:\n        raise OutputFileAccessError(\n            f\"Output file not created after optimizing. We probably ran \"\n            f\"out of disk space in the temporary folder: {tempfile.gettempdir()}.\"\n        )\n    savings = 1 - output_size / input_size\n\n    if savings < 0:\n        log.info(\n            \"Image optimization did not improve the file - \"\n            \"optimizations will not be used\"\n        )\n                                        \n        with Pdf.open(input_file) as pdf:\n            pdf.remove_unreferenced_resources()\n            pdf.save(output_file, **save_settings)\n    else:\n        safe_symlink(target_file, output_file)\n\n    return output_file", "func_code_string": "def optimize(\n    input_file: Path,\n    output_file: Path,\n    context: PdfContext,\n    save_settings: dict[str, Any],\n    executor: Executor = DEFAULT_EXECUTOR,\n) -> Path:\n                                        \n    options = context.options\n    if options.optimize == 0:\n        safe_symlink(input_file, output_file)\n        return output_file\n\n    if options.jpeg_quality == 0:\n        options.jpeg_quality = DEFAULT_JPEG_QUALITY if options.optimize < 3 else 40\n    if options.png_quality == 0:\n        options.png_quality = DEFAULT_PNG_QUALITY if options.optimize < 3 else 30\n    if options.jbig2_page_group_size == 0:\n        options.jbig2_page_group_size = 10 if options.jbig2_lossy else 1\n\n    with Pdf.open(input_file) as pdf:\n        root = output_file.parent / 'images'\n        root.mkdir(exist_ok=True)\n\n        jpegs, pngs = extract_images_generic(pdf, root, options)\n        transcode_jpegs(pdf, jpegs, root, options, executor)\n        deflate_jpegs(pdf, root, options, executor)\n                                   \n                                 \n                                                                \n        transcode_pngs(pdf, pngs, png_name, root, options, executor)\n\n        jbig2_groups = extract_images_jbig2(pdf, root, options)\n        convert_to_jbig2(pdf, jbig2_groups, root, options, executor)\n\n        target_file = output_file.with_suffix('.opt.pdf')\n        pdf.remove_unreferenced_resources()\n        pdf.save(target_file, **save_settings)\n\n    input_size = input_file.stat().st_size\n    output_size = target_file.stat().st_size\n    if output_size == 0:\n        raise OutputFileAccessError(\n            f\"Output file not created after optimizing. We probably ran \"\n            f\"out of disk space in the temporary folder: {tempfile.gettempdir()}.\"\n        )\n    savings = 1 - output_size / input_size\n\n    if savings < 0:\n        log.info(\n            \"Image optimization did not improve the file - \"\n            \"optimizations will not be used\"\n        )\n                                        \n        with Pdf.open(input_file) as pdf:\n            pdf.remove_unreferenced_resources()\n            pdf.save(output_file, **save_settings)\n    else:\n        safe_symlink(target_file, output_file)\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "main", "whole_func_string": "def main(infile, outfile, level, jobs=1):\n                                                        \n    from shutil import copy                                           \n    from tempfile import TemporaryDirectory                                           \n\n    class OptimizeOptions:\n                                         \n\n        def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False\n\n    infile = Path(infile)\n    options = OptimizeOptions(\n        input_file=infile,\n        jobs=jobs,\n        optimize_=int(level),\n        jpeg_quality=0,               \n        png_quality=0,\n        jb2lossy=False,\n    )\n\n    with TemporaryDirectory() as tmpdir:\n        context = PdfContext(options, tmpdir, infile, None, None)\n        tmpout = Path(tmpdir) / 'out.pdf'\n        optimize(\n            infile,\n            tmpout,\n            context,\n            dict(\n                compress_streams=True,\n                preserve_pdfa=True,\n                object_stream_mode=ObjectStreamMode.generate,\n            ),\n        )\n        copy(fspath(tmpout), fspath(outfile))", "func_code_string": "def main(infile, outfile, level, jobs=1):\n                                                        \n    from shutil import copy                                           \n    from tempfile import TemporaryDirectory                                           \n\n    class OptimizeOptions:\n                                         \n\n        def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False\n\n    infile = Path(infile)\n    options = OptimizeOptions(\n        input_file=infile,\n        jobs=jobs,\n        optimize_=int(level),\n        jpeg_quality=0,               \n        png_quality=0,\n        jb2lossy=False,\n    )\n\n    with TemporaryDirectory() as tmpdir:\n        context = PdfContext(options, tmpdir, infile, None, None)\n        tmpout = Path(tmpdir) / 'out.pdf'\n        optimize(\n            infile,\n            tmpout,\n            context,\n            dict(\n                compress_streams=True,\n                preserve_pdfa=True,\n                object_stream_mode=ObjectStreamMode.generate,\n            ),\n        )\n        copy(fspath(tmpout), fspath(outfile))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "jbig2_group_args", "whole_func_string": "def jbig2_group_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n            yield (\n                fspath(root),        \n                (img_name(root, xref, ext) for xref, ext in xref_exts),            \n                prefix,               \n                options.jbig2_threshold,\n            )", "func_code_string": "def jbig2_group_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n            yield (\n                fspath(root),        \n                (img_name(root, xref, ext) for xref, ext in xref_exts),            \n                prefix,               \n                options.jbig2_threshold,\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "jbig2_single_args", "whole_func_string": "def jbig2_single_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n                                                                            \n            for n, xref_ext in enumerate(xref_exts):\n                xref, ext = xref_ext\n                yield (\n                    fspath(root),\n                    img_name(root, xref, ext),\n                    root / f'{prefix}.{n:04d}',\n                    options.jbig2_threshold,\n                )", "func_code_string": "def jbig2_single_args(root: Path, groups: dict[int, list[XrefExt]]):\n        for group, xref_exts in groups.items():\n            prefix = f'group{group:08d}'\n                                                                            \n            for n, xref_ext in enumerate(xref_exts):\n                xref, ext = xref_ext\n                yield (\n                    fspath(root),\n                    img_name(root, xref, ext),\n                    root / f'{prefix}.{n:04d}',\n                    options.jbig2_threshold,\n                )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "jpeg_args", "whole_func_string": "def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality", "func_code_string": "def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "finish_jpeg", "whole_func_string": "def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()", "func_code_string": "def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "deflate_args", "whole_func_string": "def deflate_args() -> Iterator:\n        for xref in jpegs:\n            yield pdf, lock, xref, complevel", "func_code_string": "def deflate_args() -> Iterator:\n        for xref in jpegs:\n            yield pdf, lock, xref, complevel", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "finish", "whole_func_string": "def finish(result: tuple[Xref, bytes], pbar: ProgressBar):\n        xref, compdata = result\n        if len(compdata) > 0:\n            with lock:\n                xobj = pdf.get_object(xref, 0)\n                xobj.write(compdata, filter=[Name.FlateDecode, Name.DCTDecode])\n        pbar.update()", "func_code_string": "def finish(result: tuple[Xref, bytes], pbar: ProgressBar):\n        xref, compdata = result\n        if len(compdata) > 0:\n            with lock:\n                xobj = pdf.get_object(xref, 0)\n                xobj.write(compdata, filter=[Name.FlateDecode, Name.DCTDecode])\n        pbar.update()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "OptimizeOptions", "whole_func_string": "class OptimizeOptions:\n                                         \n\n        def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False", "func_code_string": "class OptimizeOptions:\n                                         \n\n        def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "pngquant_args", "whole_func_string": "def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)", "func_code_string": "def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "__init__", "whole_func_string": "def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False", "func_code_string": "def __init__(\n            self, input_file, jobs, optimize_, jpeg_quality, png_quality, jb2lossy\n        ):\n            self.input_file = input_file\n            self.jobs = jobs\n            self.optimize = optimize_\n            self.jpeg_quality = jpeg_quality\n            self.png_quality = png_quality\n            self.jbig2_page_group_size = 0\n            self.jbig2_lossy = jb2lossy\n            self.jbig2_threshold = 0.85\n            self.quiet = True\n            self.progress_bar = False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "get_docinfo", "whole_func_string": "def get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\n                                                              \n    options = context.options\n\n    def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''\n\n    pdfmark = {\n        k: from_document_info(k)\n        for k in ('/Title', '/Author', '/Keywords', '/Subject', '/CreationDate')\n    }\n    if options.title:\n        pdfmark['/Title'] = options.title\n    if options.author:\n        pdfmark['/Author'] = options.author\n    if options.keywords:\n        pdfmark['/Keywords'] = options.keywords\n    if options.subject:\n        pdfmark['/Subject'] = options.subject\n\n    creator_tag = context.plugin_manager.hook.get_ocr_engine().creator_tag(options)\n\n    pdfmark['/Creator'] = f'{PROGRAM_NAME} {OCRMYPF_VERSION} / {creator_tag}'\n    pdfmark['/Producer'] = f'pikepdf {PIKEPDF_VERSION}'\n    pdfmark['/ModDate'] = encode_pdf_date(datetime.now(timezone.utc))\n    return pdfmark", "func_code_string": "def get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\n                                                              \n    options = context.options\n\n    def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''\n\n    pdfmark = {\n        k: from_document_info(k)\n        for k in ('/Title', '/Author', '/Keywords', '/Subject', '/CreationDate')\n    }\n    if options.title:\n        pdfmark['/Title'] = options.title\n    if options.author:\n        pdfmark['/Author'] = options.author\n    if options.keywords:\n        pdfmark['/Keywords'] = options.keywords\n    if options.subject:\n        pdfmark['/Subject'] = options.subject\n\n    creator_tag = context.plugin_manager.hook.get_ocr_engine().creator_tag(options)\n\n    pdfmark['/Creator'] = f'{PROGRAM_NAME} {OCRMYPF_VERSION} / {creator_tag}'\n    pdfmark['/Producer'] = f'pikepdf {PIKEPDF_VERSION}'\n    pdfmark['/ModDate'] = encode_pdf_date(datetime.now(timezone.utc))\n    return pdfmark", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "report_on_metadata", "whole_func_string": "def report_on_metadata(options, missing):\n    if not missing:\n        return\n    if options.output_type.startswith('pdfa'):\n        log.warning(\n            \"Some input metadata could not be copied because it is not \"\n            \"permitted in PDF/A. You may wish to examine the output \"\n            \"PDF's XMP metadata.\"\n        )\n        log.debug(\"The following metadata fields were not copied: %r\", missing)\n    else:\n        log.error(\n            \"Some input metadata could not be copied.\"\n            \"You may wish to examine the output PDF's XMP metadata.\"\n        )\n        log.info(\"The following metadata fields were not copied: %r\", missing)", "func_code_string": "def report_on_metadata(options, missing):\n    if not missing:\n        return\n    if options.output_type.startswith('pdfa'):\n        log.warning(\n            \"Some input metadata could not be copied because it is not \"\n            \"permitted in PDF/A. You may wish to examine the output \"\n            \"PDF's XMP metadata.\"\n        )\n        log.debug(\"The following metadata fields were not copied: %r\", missing)\n    else:\n        log.error(\n            \"Some input metadata could not be copied.\"\n            \"You may wish to examine the output PDF's XMP metadata.\"\n        )\n        log.info(\"The following metadata fields were not copied: %r\", missing)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "repair_docinfo_nuls", "whole_func_string": "def repair_docinfo_nuls(pdf):\n           \n    modified = False\n    try:\n        if not isinstance(pdf.docinfo, Dictionary):\n            raise TypeError(\"DocumentInfo is not a dictionary\")\n        for k, v in pdf.docinfo.items():\n            if isinstance(v, str) and b'\\x00' in bytes(v):\n                pdf.docinfo[k] = bytes(v).replace(b'\\x00', b'')\n                modified = True\n    except TypeError:\n                                                                               \n        log.error(\"File contains a malformed DocumentInfo block - continuing anyway.\")\n    return modified", "func_code_string": "def repair_docinfo_nuls(pdf):\n           \n    modified = False\n    try:\n        if not isinstance(pdf.docinfo, Dictionary):\n            raise TypeError(\"DocumentInfo is not a dictionary\")\n        for k, v in pdf.docinfo.items():\n            if isinstance(v, str) and b'\\x00' in bytes(v):\n                pdf.docinfo[k] = bytes(v).replace(b'\\x00', b'')\n                modified = True\n    except TypeError:\n                                                                               \n        log.error(\"File contains a malformed DocumentInfo block - continuing anyway.\")\n    return modified", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "should_linearize", "whole_func_string": "def should_linearize(working_file: Path, context: PdfContext) -> bool:\n           \n    filesize = os.stat(working_file).st_size\n    if filesize > (context.options.fast_web_view * 1_000_000):\n        return True\n    return False", "func_code_string": "def should_linearize(working_file: Path, context: PdfContext) -> bool:\n           \n    filesize = os.stat(working_file).st_size\n    if filesize > (context.options.fast_web_view * 1_000_000):\n        return True\n    return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "_fix_metadata", "whole_func_string": "def _fix_metadata(meta_original: PdfMetadata, meta_pdf: PdfMetadata):\n                                                                \n                                          \n    if 'xmp:CreateDate' not in meta_pdf:\n        meta_pdf['xmp:CreateDate'] = meta_pdf.get('xmp:ModifyDate', '')\n    if meta_pdf.get('dc:title') == 'Untitled':\n                                                                           \n                                                                       \n                                                           \n        if 'dc:title' not in meta_original:\n            del meta_pdf['dc:title']", "func_code_string": "def _fix_metadata(meta_original: PdfMetadata, meta_pdf: PdfMetadata):\n                                                                \n                                          \n    if 'xmp:CreateDate' not in meta_pdf:\n        meta_pdf['xmp:CreateDate'] = meta_pdf.get('xmp:ModifyDate', '')\n    if meta_pdf.get('dc:title') == 'Untitled':\n                                                                           \n                                                                       \n                                                           \n        if 'dc:title' not in meta_original:\n            del meta_pdf['dc:title']", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "_unset_empty_metadata", "whole_func_string": "def _unset_empty_metadata(meta: PdfMetadata, options):\n           \n    if options.title == '' and 'dc:title' in meta:\n        del meta['dc:title']                 \n    if options.author == '':\n        if 'dc:creator' in meta:\n            del meta['dc:creator']                               \n        if 'pdf:Author' in meta:\n            del meta['pdf:Author']       \n    if options.subject == '':\n        if 'dc:description' in meta:\n            del meta['dc:description']         \n        if 'dc:subject' in meta:\n            del meta['dc:subject']       \n    if options.keywords == '' and 'pdf:Keywords' in meta:\n        del meta['pdf:Keywords']", "func_code_string": "def _unset_empty_metadata(meta: PdfMetadata, options):\n           \n    if options.title == '' and 'dc:title' in meta:\n        del meta['dc:title']                 \n    if options.author == '':\n        if 'dc:creator' in meta:\n            del meta['dc:creator']                               \n        if 'pdf:Author' in meta:\n            del meta['pdf:Author']       \n    if options.subject == '':\n        if 'dc:description' in meta:\n            del meta['dc:description']         \n        if 'dc:subject' in meta:\n            del meta['dc:subject']       \n    if options.keywords == '' and 'pdf:Keywords' in meta:\n        del meta['pdf:Keywords']", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "_set_language", "whole_func_string": "def _set_language(pdf: Pdf, languages: list[str]):\n                                      \n    if Name.Lang in pdf.Root or not languages:\n        return                               \n    primary_language_iso639_3 = languages[0]\n    if not primary_language_iso639_3:\n        return\n    iso639_2 = iso_639_2_from_3(primary_language_iso639_3)\n    if not iso639_2:\n        return\n    pdf.Root.Lang = iso639_2", "func_code_string": "def _set_language(pdf: Pdf, languages: list[str]):\n                                      \n    if Name.Lang in pdf.Root or not languages:\n        return                               \n    primary_language_iso639_3 = languages[0]\n    if not primary_language_iso639_3:\n        return\n    iso639_2 = iso_639_2_from_3(primary_language_iso639_3)\n    if not iso639_2:\n        return\n    pdf.Root.Lang = iso639_2", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "MetadataProgress", "whole_func_string": "class MetadataProgress:\n    def __init__(self, progressbar_class, enable: bool = True):\n        self.progressbar_class = progressbar_class\n        self.progressbar = self.progressbar_class(\n            total=100, desc=\"Linearizing\", unit='%', disable=not enable\n        )\n\n    def __enter__(self):\n        self.progressbar.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)\n\n    def __call__(self, percent: int):\n        if not self.progressbar_class:\n            return\n        self.progressbar.update(completed=percent)", "func_code_string": "class MetadataProgress:\n    def __init__(self, progressbar_class, enable: bool = True):\n        self.progressbar_class = progressbar_class\n        self.progressbar = self.progressbar_class(\n            total=100, desc=\"Linearizing\", unit='%', disable=not enable\n        )\n\n    def __enter__(self):\n        self.progressbar.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)\n\n    def __call__(self, percent: int):\n        if not self.progressbar_class:\n            return\n        self.progressbar.update(completed=percent)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "metadata_fixup", "whole_func_string": "def metadata_fixup(\n    working_file: Path, context: PdfContext, pdf_save_settings: dict[str, Any]\n) -> Path:\n           \n    output_file = context.get_path('metafix.pdf')\n    options = context.options\n\n    pbar_class = context.plugin_manager.hook.get_progressbar_class()\n    with (\n        Pdf.open(context.origin) as original,\n        Pdf.open(working_file) as pdf,\n        MetadataProgress(pbar_class, options.progress_bar) as pbar,\n    ):\n        docinfo = get_docinfo(original, context)\n        with (\n            original.open_metadata(\n                set_pikepdf_as_editor=False, update_docinfo=False, strict=False\n            ) as meta_original,\n            pdf.open_metadata() as meta_pdf,\n        ):\n            meta_pdf.load_from_docinfo(\n                docinfo, delete_missing=False, raise_failure=False\n            )\n            _fix_metadata(meta_original, meta_pdf)\n            _unset_empty_metadata(meta_original, options)\n            _unset_empty_metadata(meta_pdf, options)\n            meta_missing = set(meta_original.keys()) - set(meta_pdf.keys())\n            report_on_metadata(options, meta_missing)\n\n        _set_language(pdf, options.languages)\n        pdf.save(output_file, progress=pbar, **pdf_save_settings)\n\n    return output_file", "func_code_string": "def metadata_fixup(\n    working_file: Path, context: PdfContext, pdf_save_settings: dict[str, Any]\n) -> Path:\n           \n    output_file = context.get_path('metafix.pdf')\n    options = context.options\n\n    pbar_class = context.plugin_manager.hook.get_progressbar_class()\n    with (\n        Pdf.open(context.origin) as original,\n        Pdf.open(working_file) as pdf,\n        MetadataProgress(pbar_class, options.progress_bar) as pbar,\n    ):\n        docinfo = get_docinfo(original, context)\n        with (\n            original.open_metadata(\n                set_pikepdf_as_editor=False, update_docinfo=False, strict=False\n            ) as meta_original,\n            pdf.open_metadata() as meta_pdf,\n        ):\n            meta_pdf.load_from_docinfo(\n                docinfo, delete_missing=False, raise_failure=False\n            )\n            _fix_metadata(meta_original, meta_pdf)\n            _unset_empty_metadata(meta_original, options)\n            _unset_empty_metadata(meta_pdf, options)\n            meta_missing = set(meta_original.keys()) - set(meta_pdf.keys())\n            report_on_metadata(options, meta_missing)\n\n        _set_language(pdf, options.languages)\n        pdf.save(output_file, progress=pbar, **pdf_save_settings)\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "from_document_info", "whole_func_string": "def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''", "func_code_string": "def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "__init__", "whole_func_string": "def __init__(self, progressbar_class, enable: bool = True):\n        self.progressbar_class = progressbar_class\n        self.progressbar = self.progressbar_class(\n            total=100, desc=\"Linearizing\", unit='%', disable=not enable\n        )", "func_code_string": "def __init__(self, progressbar_class, enable: bool = True):\n        self.progressbar_class = progressbar_class\n        self.progressbar = self.progressbar_class(\n            total=100, desc=\"Linearizing\", unit='%', disable=not enable\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "__enter__", "whole_func_string": "def __enter__(self):\n        self.progressbar.__enter__()\n        return self", "func_code_string": "def __enter__(self):\n        self.progressbar.__enter__()\n        return self", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "__call__", "whole_func_string": "def __call__(self, percent: int):\n        if not self.progressbar_class:\n            return\n        self.progressbar.update(completed=percent)", "func_code_string": "def __call__(self, percent: int):\n        if not self.progressbar_class:\n            return\n        self.progressbar.update(completed=percent)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_logging.py", "func_name": "PageNumberFilter", "whole_func_string": "class PageNumberFilter(logging.Filter):\n                                                                        \n\n    def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_code_string": "class PageNumberFilter(logging.Filter):\n                                                                        \n\n    def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_logging.py", "func_name": "RichLoggingHandler", "whole_func_string": "class RichLoggingHandler(RichHandler):\n    def __init__(self, console: Console, **kwargs):\n        super().__init__(\n            console=console, show_level=False, show_time=False, markup=False, **kwargs\n        )", "func_code_string": "class RichLoggingHandler(RichHandler):\n    def __init__(self, console: Console, **kwargs):\n        super().__init__(\n            console=console, show_level=False, show_time=False, markup=False, **kwargs\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_logging.py", "func_name": "filter", "whole_func_string": "def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_code_string": "def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_logging.py", "func_name": "__init__", "whole_func_string": "def __init__(self, console: Console, **kwargs):\n        super().__init__(\n            console=console, show_level=False, show_time=False, markup=False, **kwargs\n        )", "func_code_string": "def __init__(self, console: Console, **kwargs):\n        super().__init__(\n            console=console, show_level=False, show_time=False, markup=False, **kwargs\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "RenderMode", "whole_func_string": "class RenderMode(Enum):\n    ON_TOP = 0\n    UNDERNEATH = 1", "func_code_string": "class RenderMode(Enum):\n    ON_TOP = 0\n    UNDERNEATH = 1", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "_ensure_dictionary", "whole_func_string": "def _ensure_dictionary(obj: Dictionary | Stream, name: Name):\n    if name not in obj:\n        obj[name] = Dictionary({})\n    return obj[name]", "func_code_string": "def _ensure_dictionary(obj: Dictionary | Stream, name: Name):\n    if name not in obj:\n        obj[name] = Dictionary({})\n    return obj[name]", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "_update_resources", "whole_func_string": "def _update_resources(\n    *,\n    obj: Dictionary | Stream,\n    font: Dictionary | None,\n    font_key: Name | None,\n):\n           \n    resources = _ensure_dictionary(obj, Name.Resources)\n    fonts = _ensure_dictionary(resources, Name.Font)\n    if font_key is not None and font_key not in fonts:\n        fonts[font_key] = font", "func_code_string": "def _update_resources(\n    *,\n    obj: Dictionary | Stream,\n    font: Dictionary | None,\n    font_key: Name | None,\n):\n           \n    resources = _ensure_dictionary(obj, Name.Resources)\n    fonts = _ensure_dictionary(resources, Name.Font)\n    if font_key is not None and font_key not in fonts:\n        fonts[font_key] = font", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "strip_invisible_text", "whole_func_string": "def strip_invisible_text(pdf: Pdf, page: Page):\n    stream = []\n    in_text_obj = False\n    render_mode = 0\n    render_mode_stack = []\n    text_objects = []\n\n    for operands, operator in parse_content_stream(page, ''):\n        if operator == Operator('Tr'):\n            render_mode = operands[0]\n\n        if operator == Operator('q'):\n            render_mode_stack.append(render_mode)\n\n        if operator == Operator('Q'):\n            try:\n                render_mode = render_mode_stack.pop()\n            except IndexError:\n                                                              \n                                     \n                pass\n\n        if not in_text_obj:\n            if operator == Operator('BT'):\n                in_text_obj = True\n                text_objects.append((operands, operator))\n            else:\n                stream.append((operands, operator))\n        else:\n            text_objects.append((operands, operator))\n            if operator == Operator('ET'):\n                in_text_obj = False\n                if render_mode != 3:\n                    stream.extend(text_objects)\n                text_objects.clear()\n\n    content_stream = unparse_content_stream(stream)\n    page.Contents = Stream(pdf, content_stream)", "func_code_string": "def strip_invisible_text(pdf: Pdf, page: Page):\n    stream = []\n    in_text_obj = False\n    render_mode = 0\n    render_mode_stack = []\n    text_objects = []\n\n    for operands, operator in parse_content_stream(page, ''):\n        if operator == Operator('Tr'):\n            render_mode = operands[0]\n\n        if operator == Operator('q'):\n            render_mode_stack.append(render_mode)\n\n        if operator == Operator('Q'):\n            try:\n                render_mode = render_mode_stack.pop()\n            except IndexError:\n                                                              \n                                     \n                pass\n\n        if not in_text_obj:\n            if operator == Operator('BT'):\n                in_text_obj = True\n                text_objects.append((operands, operator))\n            else:\n                stream.append((operands, operator))\n        else:\n            text_objects.append((operands, operator))\n            if operator == Operator('ET'):\n                in_text_obj = False\n                if render_mode != 3:\n                    stream.extend(text_objects)\n                text_objects.clear()\n\n    content_stream = unparse_content_stream(stream)\n    page.Contents = Stream(pdf, content_stream)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "OcrGrafter", "whole_func_string": "class OcrGrafter:\n                                                            \n\n    def __init__(self, context: PdfContext):\n        self.context = context\n        self.path_base = context.origin\n\n        self.pdf_base = Pdf.open(self.path_base)\n        self.font: Dictionary | None = None\n        self.font_key: Name | None = None\n\n        self.pdfinfo = context.pdfinfo\n        self.output_file = context.get_path('graft_layers.pdf')\n\n        self.emplacements = 1\n        self.interim_count = 0\n        self.render_mode = RenderMode.UNDERNEATH\n\n    def graft_page(\n        self,\n        *,\n        pageno: int,\n        image: Path | None,\n        textpdf: Path | None,\n        autorotate_correction: int,\n    ):\n        if textpdf and not self.font:\n            self.font, self.font_key = self._find_font(textpdf)\n\n        emplaced_page = False\n        content_rotation = self.pdfinfo[pageno].rotation\n        path_image = Path(image).resolve() if image else None\n        if path_image is not None and path_image != self.path_base:\n                                                                           \n                                                                    \n            log.debug(\"Emplacement update\")\n            with Pdf.open(path_image) as pdf_image:\n                self.emplacements += 1\n                foreign_image_page = pdf_image.pages[0]\n                self.pdf_base.pages.append(foreign_image_page)\n                local_image_page = self.pdf_base.pages[-1]\n                self.pdf_base.pages[pageno].emplace(\n                    local_image_page, retain=(Name.Parent,)\n                )\n                del self.pdf_base.pages[-1]\n            emplaced_page = True\n\n                                                                     \n        if emplaced_page:\n            content_rotation = autorotate_correction\n        text_rotation = autorotate_correction\n        text_misaligned = (text_rotation - content_rotation) % 360\n        log.debug(\n            f\"Text rotation: (text, autorotate, content) -> text misalignment = \"\n            f\"({text_rotation}, {autorotate_correction}, {content_rotation}) -> \"\n            f\"{text_misaligned}\"\n        )\n\n        if textpdf and self.font:\n            if self.font_key is None:\n                raise ValueError(\"Font key is not set\")\n                                                                               \n                                                                  \n            strip_old = self.context.options.redo_ocr\n            self._graft_text_layer(\n                page_num=pageno + 1,\n                textpdf=textpdf,\n                font=self.font,\n                font_key=self.font_key,\n                text_rotation=text_misaligned,\n                strip_old_text=strip_old,\n            )\n\n                                                                                    \n                     \n        page_rotation = (content_rotation - autorotate_correction) % 360\n        self.pdf_base.pages[pageno].Rotate = page_rotation\n        log.debug(\n            f\"Page rotation: (content, auto) -> page = \"\n            f\"({content_rotation}, {autorotate_correction}) -> {page_rotation}\"\n        )\n        if self.emplacements % MAX_REPLACE_PAGES == 0:\n            self.save_and_reload()\n\n    def save_and_reload(self) -> None:\n                   \n        page0 = self.pdf_base.pages[0]\n        _update_resources(obj=page0.obj, font=self.font, font_key=self.font_key)\n\n                                                                      \n                                                                                 \n                                                             \n                                            \n                                                                   \n        old_file = self.output_file.with_suffix(f'.working{self.interim_count - 1}.pdf')\n        if not self.context.options.keep_temporary_files:\n            with suppress(FileNotFoundError):\n                old_file.unlink()\n\n        next_file = self.output_file.with_suffix(\n            f'.working{self.interim_count + 1}.pdf'\n        )\n        self.pdf_base.save(next_file)\n        self.pdf_base.close()\n\n        self.pdf_base = Pdf.open(next_file)\n        self.font, self.font_key = None, None                                        \n        self.interim_count += 1\n\n    def finalize(self):\n        self.pdf_base.save(self.output_file)\n        self.pdf_base.close()\n        return self.output_file\n\n    def _find_font(self, text: Path) -> tuple[Dictionary | None, Name | None]:\n                                                               \n        font, font_key = None, None\n        possible_font_names = ('/f-0-0', '/F1')\n        try:\n            with Pdf.open(text) as pdf_text:\n                try:\n                    pdf_text_fonts = pdf_text.pages[0].Resources.get(\n                        Name.Font, Dictionary()\n                    )\n                except (AttributeError, IndexError, KeyError):\n                    return None, None\n                if not isinstance(pdf_text_fonts, Dictionary):\n                    log.warning(\"Page fonts are not stored in a dictionary\")\n                    return None, None\n                pdf_text_font = None\n                for f in possible_font_names:\n                    pdf_text_font = pdf_text_fonts.get(f, None)\n                    if pdf_text_font is not None:\n                        font_key = Name(f)\n                        break\n                if pdf_text_font:\n                    font = self.pdf_base.copy_foreign(pdf_text_font)\n                if not isinstance(font, Dictionary):\n                    log.warning(\"Font is not a dictionary\")\n                    font, font_key = None, None\n                return font, font_key\n        except (FileNotFoundError, PdfError):\n                                                                                   \n            return None, None\n\n    def _graft_text_layer(\n        self,\n        *,\n        page_num: int,\n        textpdf: Path,\n        font: Dictionary,\n        font_key: Name,\n        text_rotation: int,\n        strip_old_text: bool,\n    ):\n                                                                                \n                                      \n\n        log.debug(\"Grafting\")\n        if Path(textpdf).stat().st_size == 0:\n            return\n\n                                                                       \n        with Pdf.open(textpdf) as pdf_text:\n            pdf_text_contents = pdf_text.pages[0].Contents.read_bytes()\n\n            base_page = self.pdf_base.pages.p(page_num)\n\n                                                                                     \n                                                                                       \n                                                                                  \n                                                                                       \n            mediabox = pdf_text.pages[0].mediabox\n            wt, ht = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            mediabox = base_page.mediabox\n            wp, hp = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            translate = Matrix().translated(-wt / 2, -ht / 2)\n            untranslate = Matrix().translated(wp / 2, hp / 2)\n            corner = Matrix().translated(mediabox[0], mediabox[1])\n                                                                               \n                      \n            text_rotation = -text_rotation % 360\n            rotate = Matrix().rotated(text_rotation)\n\n                                                                               \n                                                                                  \n                              \n            if text_rotation in (90, 270):\n                wt, ht = ht, wt\n            scale_x = wp / wt\n            scale_y = hp / ht\n\n                                               \n            scale = Matrix().scaled(scale_x, scale_y)\n\n                                                                                     \n                                                                                      \n                                                                       \n            ctm = translate @ rotate @ scale @ untranslate @ corner\n            log.debug(\"Grafting with ctm %r\", ctm)\n\n            base_resources = _ensure_dictionary(base_page.obj, Name.Resources)\n            base_xobjs = _ensure_dictionary(base_resources, Name.XObject)\n            text_xobj_name = Name.random(prefix=\"OCR-\")\n            xobj = self.pdf_base.make_stream(pdf_text_contents)\n            base_xobjs[text_xobj_name] = xobj\n            xobj.Type = Name.XObject\n            xobj.Subtype = Name.Form\n            xobj.FormType = 1\n            xobj.BBox = mediabox\n            _update_resources(obj=xobj, font=font, font_key=font_key)\n\n            pdf_draw_xobj = (\n                (b'q %s cm\\n' % ctm.encode()) + (b'%s Do\\n' % text_xobj_name) + b'\\nQ\\n'\n            )\n            new_text_layer = Stream(self.pdf_base, pdf_draw_xobj)\n\n            if strip_old_text:\n                strip_invisible_text(self.pdf_base, base_page)\n            base_page.contents_coalesce()\n            if self.render_mode == RenderMode.ON_TOP:\n                                                                        \n                                                                                   \n                                        \n                original = base_page.Contents.read_bytes()\n                base_page.Contents.write(b'q\\n' + original + b'\\nQ\\n')\n            base_page.contents_add(\n                new_text_layer, prepend=self.render_mode == RenderMode.UNDERNEATH\n            )\n            base_page.contents_coalesce()\n\n            _update_resources(obj=base_page.obj, font=font, font_key=font_key)", "func_code_string": "class OcrGrafter:\n                                                            \n\n    def __init__(self, context: PdfContext):\n        self.context = context\n        self.path_base = context.origin\n\n        self.pdf_base = Pdf.open(self.path_base)\n        self.font: Dictionary | None = None\n        self.font_key: Name | None = None\n\n        self.pdfinfo = context.pdfinfo\n        self.output_file = context.get_path('graft_layers.pdf')\n\n        self.emplacements = 1\n        self.interim_count = 0\n        self.render_mode = RenderMode.UNDERNEATH\n\n    def graft_page(\n        self,\n        *,\n        pageno: int,\n        image: Path | None,\n        textpdf: Path | None,\n        autorotate_correction: int,\n    ):\n        if textpdf and not self.font:\n            self.font, self.font_key = self._find_font(textpdf)\n\n        emplaced_page = False\n        content_rotation = self.pdfinfo[pageno].rotation\n        path_image = Path(image).resolve() if image else None\n        if path_image is not None and path_image != self.path_base:\n                                                                           \n                                                                    \n            log.debug(\"Emplacement update\")\n            with Pdf.open(path_image) as pdf_image:\n                self.emplacements += 1\n                foreign_image_page = pdf_image.pages[0]\n                self.pdf_base.pages.append(foreign_image_page)\n                local_image_page = self.pdf_base.pages[-1]\n                self.pdf_base.pages[pageno].emplace(\n                    local_image_page, retain=(Name.Parent,)\n                )\n                del self.pdf_base.pages[-1]\n            emplaced_page = True\n\n                                                                     \n        if emplaced_page:\n            content_rotation = autorotate_correction\n        text_rotation = autorotate_correction\n        text_misaligned = (text_rotation - content_rotation) % 360\n        log.debug(\n            f\"Text rotation: (text, autorotate, content) -> text misalignment = \"\n            f\"({text_rotation}, {autorotate_correction}, {content_rotation}) -> \"\n            f\"{text_misaligned}\"\n        )\n\n        if textpdf and self.font:\n            if self.font_key is None:\n                raise ValueError(\"Font key is not set\")\n                                                                               \n                                                                  \n            strip_old = self.context.options.redo_ocr\n            self._graft_text_layer(\n                page_num=pageno + 1,\n                textpdf=textpdf,\n                font=self.font,\n                font_key=self.font_key,\n                text_rotation=text_misaligned,\n                strip_old_text=strip_old,\n            )\n\n                                                                                    \n                     \n        page_rotation = (content_rotation - autorotate_correction) % 360\n        self.pdf_base.pages[pageno].Rotate = page_rotation\n        log.debug(\n            f\"Page rotation: (content, auto) -> page = \"\n            f\"({content_rotation}, {autorotate_correction}) -> {page_rotation}\"\n        )\n        if self.emplacements % MAX_REPLACE_PAGES == 0:\n            self.save_and_reload()\n\n    def save_and_reload(self) -> None:\n                   \n        page0 = self.pdf_base.pages[0]\n        _update_resources(obj=page0.obj, font=self.font, font_key=self.font_key)\n\n                                                                      \n                                                                                 \n                                                             \n                                            \n                                                                   \n        old_file = self.output_file.with_suffix(f'.working{self.interim_count - 1}.pdf')\n        if not self.context.options.keep_temporary_files:\n            with suppress(FileNotFoundError):\n                old_file.unlink()\n\n        next_file = self.output_file.with_suffix(\n            f'.working{self.interim_count + 1}.pdf'\n        )\n        self.pdf_base.save(next_file)\n        self.pdf_base.close()\n\n        self.pdf_base = Pdf.open(next_file)\n        self.font, self.font_key = None, None                                        \n        self.interim_count += 1\n\n    def finalize(self):\n        self.pdf_base.save(self.output_file)\n        self.pdf_base.close()\n        return self.output_file\n\n    def _find_font(self, text: Path) -> tuple[Dictionary | None, Name | None]:\n                                                               \n        font, font_key = None, None\n        possible_font_names = ('/f-0-0', '/F1')\n        try:\n            with Pdf.open(text) as pdf_text:\n                try:\n                    pdf_text_fonts = pdf_text.pages[0].Resources.get(\n                        Name.Font, Dictionary()\n                    )\n                except (AttributeError, IndexError, KeyError):\n                    return None, None\n                if not isinstance(pdf_text_fonts, Dictionary):\n                    log.warning(\"Page fonts are not stored in a dictionary\")\n                    return None, None\n                pdf_text_font = None\n                for f in possible_font_names:\n                    pdf_text_font = pdf_text_fonts.get(f, None)\n                    if pdf_text_font is not None:\n                        font_key = Name(f)\n                        break\n                if pdf_text_font:\n                    font = self.pdf_base.copy_foreign(pdf_text_font)\n                if not isinstance(font, Dictionary):\n                    log.warning(\"Font is not a dictionary\")\n                    font, font_key = None, None\n                return font, font_key\n        except (FileNotFoundError, PdfError):\n                                                                                   \n            return None, None\n\n    def _graft_text_layer(\n        self,\n        *,\n        page_num: int,\n        textpdf: Path,\n        font: Dictionary,\n        font_key: Name,\n        text_rotation: int,\n        strip_old_text: bool,\n    ):\n                                                                                \n                                      \n\n        log.debug(\"Grafting\")\n        if Path(textpdf).stat().st_size == 0:\n            return\n\n                                                                       \n        with Pdf.open(textpdf) as pdf_text:\n            pdf_text_contents = pdf_text.pages[0].Contents.read_bytes()\n\n            base_page = self.pdf_base.pages.p(page_num)\n\n                                                                                     \n                                                                                       \n                                                                                  \n                                                                                       \n            mediabox = pdf_text.pages[0].mediabox\n            wt, ht = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            mediabox = base_page.mediabox\n            wp, hp = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            translate = Matrix().translated(-wt / 2, -ht / 2)\n            untranslate = Matrix().translated(wp / 2, hp / 2)\n            corner = Matrix().translated(mediabox[0], mediabox[1])\n                                                                               \n                      \n            text_rotation = -text_rotation % 360\n            rotate = Matrix().rotated(text_rotation)\n\n                                                                               \n                                                                                  \n                              \n            if text_rotation in (90, 270):\n                wt, ht = ht, wt\n            scale_x = wp / wt\n            scale_y = hp / ht\n\n                                               \n            scale = Matrix().scaled(scale_x, scale_y)\n\n                                                                                     \n                                                                                      \n                                                                       \n            ctm = translate @ rotate @ scale @ untranslate @ corner\n            log.debug(\"Grafting with ctm %r\", ctm)\n\n            base_resources = _ensure_dictionary(base_page.obj, Name.Resources)\n            base_xobjs = _ensure_dictionary(base_resources, Name.XObject)\n            text_xobj_name = Name.random(prefix=\"OCR-\")\n            xobj = self.pdf_base.make_stream(pdf_text_contents)\n            base_xobjs[text_xobj_name] = xobj\n            xobj.Type = Name.XObject\n            xobj.Subtype = Name.Form\n            xobj.FormType = 1\n            xobj.BBox = mediabox\n            _update_resources(obj=xobj, font=font, font_key=font_key)\n\n            pdf_draw_xobj = (\n                (b'q %s cm\\n' % ctm.encode()) + (b'%s Do\\n' % text_xobj_name) + b'\\nQ\\n'\n            )\n            new_text_layer = Stream(self.pdf_base, pdf_draw_xobj)\n\n            if strip_old_text:\n                strip_invisible_text(self.pdf_base, base_page)\n            base_page.contents_coalesce()\n            if self.render_mode == RenderMode.ON_TOP:\n                                                                        \n                                                                                   \n                                        \n                original = base_page.Contents.read_bytes()\n                base_page.Contents.write(b'q\\n' + original + b'\\nQ\\n')\n            base_page.contents_add(\n                new_text_layer, prepend=self.render_mode == RenderMode.UNDERNEATH\n            )\n            base_page.contents_coalesce()\n\n            _update_resources(obj=base_page.obj, font=font, font_key=font_key)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "__init__", "whole_func_string": "def __init__(self, context: PdfContext):\n        self.context = context\n        self.path_base = context.origin\n\n        self.pdf_base = Pdf.open(self.path_base)\n        self.font: Dictionary | None = None\n        self.font_key: Name | None = None\n\n        self.pdfinfo = context.pdfinfo\n        self.output_file = context.get_path('graft_layers.pdf')\n\n        self.emplacements = 1\n        self.interim_count = 0\n        self.render_mode = RenderMode.UNDERNEATH", "func_code_string": "def __init__(self, context: PdfContext):\n        self.context = context\n        self.path_base = context.origin\n\n        self.pdf_base = Pdf.open(self.path_base)\n        self.font: Dictionary | None = None\n        self.font_key: Name | None = None\n\n        self.pdfinfo = context.pdfinfo\n        self.output_file = context.get_path('graft_layers.pdf')\n\n        self.emplacements = 1\n        self.interim_count = 0\n        self.render_mode = RenderMode.UNDERNEATH", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "graft_page", "whole_func_string": "def graft_page(\n        self,\n        *,\n        pageno: int,\n        image: Path | None,\n        textpdf: Path | None,\n        autorotate_correction: int,\n    ):\n        if textpdf and not self.font:\n            self.font, self.font_key = self._find_font(textpdf)\n\n        emplaced_page = False\n        content_rotation = self.pdfinfo[pageno].rotation\n        path_image = Path(image).resolve() if image else None\n        if path_image is not None and path_image != self.path_base:\n                                                                           \n                                                                    \n            log.debug(\"Emplacement update\")\n            with Pdf.open(path_image) as pdf_image:\n                self.emplacements += 1\n                foreign_image_page = pdf_image.pages[0]\n                self.pdf_base.pages.append(foreign_image_page)\n                local_image_page = self.pdf_base.pages[-1]\n                self.pdf_base.pages[pageno].emplace(\n                    local_image_page, retain=(Name.Parent,)\n                )\n                del self.pdf_base.pages[-1]\n            emplaced_page = True\n\n                                                                     \n        if emplaced_page:\n            content_rotation = autorotate_correction\n        text_rotation = autorotate_correction\n        text_misaligned = (text_rotation - content_rotation) % 360\n        log.debug(\n            f\"Text rotation: (text, autorotate, content) -> text misalignment = \"\n            f\"({text_rotation}, {autorotate_correction}, {content_rotation}) -> \"\n            f\"{text_misaligned}\"\n        )\n\n        if textpdf and self.font:\n            if self.font_key is None:\n                raise ValueError(\"Font key is not set\")\n                                                                               \n                                                                  \n            strip_old = self.context.options.redo_ocr\n            self._graft_text_layer(\n                page_num=pageno + 1,\n                textpdf=textpdf,\n                font=self.font,\n                font_key=self.font_key,\n                text_rotation=text_misaligned,\n                strip_old_text=strip_old,\n            )\n\n                                                                                    \n                     \n        page_rotation = (content_rotation - autorotate_correction) % 360\n        self.pdf_base.pages[pageno].Rotate = page_rotation\n        log.debug(\n            f\"Page rotation: (content, auto) -> page = \"\n            f\"({content_rotation}, {autorotate_correction}) -> {page_rotation}\"\n        )\n        if self.emplacements % MAX_REPLACE_PAGES == 0:\n            self.save_and_reload()", "func_code_string": "def graft_page(\n        self,\n        *,\n        pageno: int,\n        image: Path | None,\n        textpdf: Path | None,\n        autorotate_correction: int,\n    ):\n        if textpdf and not self.font:\n            self.font, self.font_key = self._find_font(textpdf)\n\n        emplaced_page = False\n        content_rotation = self.pdfinfo[pageno].rotation\n        path_image = Path(image).resolve() if image else None\n        if path_image is not None and path_image != self.path_base:\n                                                                           \n                                                                    \n            log.debug(\"Emplacement update\")\n            with Pdf.open(path_image) as pdf_image:\n                self.emplacements += 1\n                foreign_image_page = pdf_image.pages[0]\n                self.pdf_base.pages.append(foreign_image_page)\n                local_image_page = self.pdf_base.pages[-1]\n                self.pdf_base.pages[pageno].emplace(\n                    local_image_page, retain=(Name.Parent,)\n                )\n                del self.pdf_base.pages[-1]\n            emplaced_page = True\n\n                                                                     \n        if emplaced_page:\n            content_rotation = autorotate_correction\n        text_rotation = autorotate_correction\n        text_misaligned = (text_rotation - content_rotation) % 360\n        log.debug(\n            f\"Text rotation: (text, autorotate, content) -> text misalignment = \"\n            f\"({text_rotation}, {autorotate_correction}, {content_rotation}) -> \"\n            f\"{text_misaligned}\"\n        )\n\n        if textpdf and self.font:\n            if self.font_key is None:\n                raise ValueError(\"Font key is not set\")\n                                                                               \n                                                                  \n            strip_old = self.context.options.redo_ocr\n            self._graft_text_layer(\n                page_num=pageno + 1,\n                textpdf=textpdf,\n                font=self.font,\n                font_key=self.font_key,\n                text_rotation=text_misaligned,\n                strip_old_text=strip_old,\n            )\n\n                                                                                    \n                     \n        page_rotation = (content_rotation - autorotate_correction) % 360\n        self.pdf_base.pages[pageno].Rotate = page_rotation\n        log.debug(\n            f\"Page rotation: (content, auto) -> page = \"\n            f\"({content_rotation}, {autorotate_correction}) -> {page_rotation}\"\n        )\n        if self.emplacements % MAX_REPLACE_PAGES == 0:\n            self.save_and_reload()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "save_and_reload", "whole_func_string": "def save_and_reload(self) -> None:\n                   \n        page0 = self.pdf_base.pages[0]\n        _update_resources(obj=page0.obj, font=self.font, font_key=self.font_key)\n\n                                                                      \n                                                                                 \n                                                             \n                                            \n                                                                   \n        old_file = self.output_file.with_suffix(f'.working{self.interim_count - 1}.pdf')\n        if not self.context.options.keep_temporary_files:\n            with suppress(FileNotFoundError):\n                old_file.unlink()\n\n        next_file = self.output_file.with_suffix(\n            f'.working{self.interim_count + 1}.pdf'\n        )\n        self.pdf_base.save(next_file)\n        self.pdf_base.close()\n\n        self.pdf_base = Pdf.open(next_file)\n        self.font, self.font_key = None, None                                        \n        self.interim_count += 1", "func_code_string": "def save_and_reload(self) -> None:\n                   \n        page0 = self.pdf_base.pages[0]\n        _update_resources(obj=page0.obj, font=self.font, font_key=self.font_key)\n\n                                                                      \n                                                                                 \n                                                             \n                                            \n                                                                   \n        old_file = self.output_file.with_suffix(f'.working{self.interim_count - 1}.pdf')\n        if not self.context.options.keep_temporary_files:\n            with suppress(FileNotFoundError):\n                old_file.unlink()\n\n        next_file = self.output_file.with_suffix(\n            f'.working{self.interim_count + 1}.pdf'\n        )\n        self.pdf_base.save(next_file)\n        self.pdf_base.close()\n\n        self.pdf_base = Pdf.open(next_file)\n        self.font, self.font_key = None, None                                        \n        self.interim_count += 1", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "finalize", "whole_func_string": "def finalize(self):\n        self.pdf_base.save(self.output_file)\n        self.pdf_base.close()\n        return self.output_file", "func_code_string": "def finalize(self):\n        self.pdf_base.save(self.output_file)\n        self.pdf_base.close()\n        return self.output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "_find_font", "whole_func_string": "def _find_font(self, text: Path) -> tuple[Dictionary | None, Name | None]:\n                                                               \n        font, font_key = None, None\n        possible_font_names = ('/f-0-0', '/F1')\n        try:\n            with Pdf.open(text) as pdf_text:\n                try:\n                    pdf_text_fonts = pdf_text.pages[0].Resources.get(\n                        Name.Font, Dictionary()\n                    )\n                except (AttributeError, IndexError, KeyError):\n                    return None, None\n                if not isinstance(pdf_text_fonts, Dictionary):\n                    log.warning(\"Page fonts are not stored in a dictionary\")\n                    return None, None\n                pdf_text_font = None\n                for f in possible_font_names:\n                    pdf_text_font = pdf_text_fonts.get(f, None)\n                    if pdf_text_font is not None:\n                        font_key = Name(f)\n                        break\n                if pdf_text_font:\n                    font = self.pdf_base.copy_foreign(pdf_text_font)\n                if not isinstance(font, Dictionary):\n                    log.warning(\"Font is not a dictionary\")\n                    font, font_key = None, None\n                return font, font_key\n        except (FileNotFoundError, PdfError):\n                                                                                   \n            return None, None", "func_code_string": "def _find_font(self, text: Path) -> tuple[Dictionary | None, Name | None]:\n                                                               \n        font, font_key = None, None\n        possible_font_names = ('/f-0-0', '/F1')\n        try:\n            with Pdf.open(text) as pdf_text:\n                try:\n                    pdf_text_fonts = pdf_text.pages[0].Resources.get(\n                        Name.Font, Dictionary()\n                    )\n                except (AttributeError, IndexError, KeyError):\n                    return None, None\n                if not isinstance(pdf_text_fonts, Dictionary):\n                    log.warning(\"Page fonts are not stored in a dictionary\")\n                    return None, None\n                pdf_text_font = None\n                for f in possible_font_names:\n                    pdf_text_font = pdf_text_fonts.get(f, None)\n                    if pdf_text_font is not None:\n                        font_key = Name(f)\n                        break\n                if pdf_text_font:\n                    font = self.pdf_base.copy_foreign(pdf_text_font)\n                if not isinstance(font, Dictionary):\n                    log.warning(\"Font is not a dictionary\")\n                    font, font_key = None, None\n                return font, font_key\n        except (FileNotFoundError, PdfError):\n                                                                                   \n            return None, None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_graft.py", "func_name": "_graft_text_layer", "whole_func_string": "def _graft_text_layer(\n        self,\n        *,\n        page_num: int,\n        textpdf: Path,\n        font: Dictionary,\n        font_key: Name,\n        text_rotation: int,\n        strip_old_text: bool,\n    ):\n                                                                                \n                                      \n\n        log.debug(\"Grafting\")\n        if Path(textpdf).stat().st_size == 0:\n            return\n\n                                                                       \n        with Pdf.open(textpdf) as pdf_text:\n            pdf_text_contents = pdf_text.pages[0].Contents.read_bytes()\n\n            base_page = self.pdf_base.pages.p(page_num)\n\n                                                                                     \n                                                                                       \n                                                                                  \n                                                                                       \n            mediabox = pdf_text.pages[0].mediabox\n            wt, ht = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            mediabox = base_page.mediabox\n            wp, hp = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            translate = Matrix().translated(-wt / 2, -ht / 2)\n            untranslate = Matrix().translated(wp / 2, hp / 2)\n            corner = Matrix().translated(mediabox[0], mediabox[1])\n                                                                               \n                      \n            text_rotation = -text_rotation % 360\n            rotate = Matrix().rotated(text_rotation)\n\n                                                                               \n                                                                                  \n                              \n            if text_rotation in (90, 270):\n                wt, ht = ht, wt\n            scale_x = wp / wt\n            scale_y = hp / ht\n\n                                               \n            scale = Matrix().scaled(scale_x, scale_y)\n\n                                                                                     \n                                                                                      \n                                                                       \n            ctm = translate @ rotate @ scale @ untranslate @ corner\n            log.debug(\"Grafting with ctm %r\", ctm)\n\n            base_resources = _ensure_dictionary(base_page.obj, Name.Resources)\n            base_xobjs = _ensure_dictionary(base_resources, Name.XObject)\n            text_xobj_name = Name.random(prefix=\"OCR-\")\n            xobj = self.pdf_base.make_stream(pdf_text_contents)\n            base_xobjs[text_xobj_name] = xobj\n            xobj.Type = Name.XObject\n            xobj.Subtype = Name.Form\n            xobj.FormType = 1\n            xobj.BBox = mediabox\n            _update_resources(obj=xobj, font=font, font_key=font_key)\n\n            pdf_draw_xobj = (\n                (b'q %s cm\\n' % ctm.encode()) + (b'%s Do\\n' % text_xobj_name) + b'\\nQ\\n'\n            )\n            new_text_layer = Stream(self.pdf_base, pdf_draw_xobj)\n\n            if strip_old_text:\n                strip_invisible_text(self.pdf_base, base_page)\n            base_page.contents_coalesce()\n            if self.render_mode == RenderMode.ON_TOP:\n                                                                        \n                                                                                   \n                                        \n                original = base_page.Contents.read_bytes()\n                base_page.Contents.write(b'q\\n' + original + b'\\nQ\\n')\n            base_page.contents_add(\n                new_text_layer, prepend=self.render_mode == RenderMode.UNDERNEATH\n            )\n            base_page.contents_coalesce()\n\n            _update_resources(obj=base_page.obj, font=font, font_key=font_key)", "func_code_string": "def _graft_text_layer(\n        self,\n        *,\n        page_num: int,\n        textpdf: Path,\n        font: Dictionary,\n        font_key: Name,\n        text_rotation: int,\n        strip_old_text: bool,\n    ):\n                                                                                \n                                      \n\n        log.debug(\"Grafting\")\n        if Path(textpdf).stat().st_size == 0:\n            return\n\n                                                                       \n        with Pdf.open(textpdf) as pdf_text:\n            pdf_text_contents = pdf_text.pages[0].Contents.read_bytes()\n\n            base_page = self.pdf_base.pages.p(page_num)\n\n                                                                                     \n                                                                                       \n                                                                                  \n                                                                                       \n            mediabox = pdf_text.pages[0].mediabox\n            wt, ht = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            mediabox = base_page.mediabox\n            wp, hp = mediabox[2] - mediabox[0], mediabox[3] - mediabox[1]\n\n            translate = Matrix().translated(-wt / 2, -ht / 2)\n            untranslate = Matrix().translated(wp / 2, hp / 2)\n            corner = Matrix().translated(mediabox[0], mediabox[1])\n                                                                               \n                      \n            text_rotation = -text_rotation % 360\n            rotate = Matrix().rotated(text_rotation)\n\n                                                                               \n                                                                                  \n                              \n            if text_rotation in (90, 270):\n                wt, ht = ht, wt\n            scale_x = wp / wt\n            scale_y = hp / ht\n\n                                               \n            scale = Matrix().scaled(scale_x, scale_y)\n\n                                                                                     \n                                                                                      \n                                                                       \n            ctm = translate @ rotate @ scale @ untranslate @ corner\n            log.debug(\"Grafting with ctm %r\", ctm)\n\n            base_resources = _ensure_dictionary(base_page.obj, Name.Resources)\n            base_xobjs = _ensure_dictionary(base_resources, Name.XObject)\n            text_xobj_name = Name.random(prefix=\"OCR-\")\n            xobj = self.pdf_base.make_stream(pdf_text_contents)\n            base_xobjs[text_xobj_name] = xobj\n            xobj.Type = Name.XObject\n            xobj.Subtype = Name.Form\n            xobj.FormType = 1\n            xobj.BBox = mediabox\n            _update_resources(obj=xobj, font=font, font_key=font_key)\n\n            pdf_draw_xobj = (\n                (b'q %s cm\\n' % ctm.encode()) + (b'%s Do\\n' % text_xobj_name) + b'\\nQ\\n'\n            )\n            new_text_layer = Stream(self.pdf_base, pdf_draw_xobj)\n\n            if strip_old_text:\n                strip_invisible_text(self.pdf_base, base_page)\n            base_page.contents_coalesce()\n            if self.render_mode == RenderMode.ON_TOP:\n                                                                        \n                                                                                   \n                                        \n                original = base_page.Contents.read_bytes()\n                base_page.Contents.write(b'q\\n' + original + b'\\nQ\\n')\n            base_page.contents_add(\n                new_text_layer, prepend=self.render_mode == RenderMode.UNDERNEATH\n            )\n            base_page.contents_coalesce()\n\n            _update_resources(obj=base_page.obj, font=font, font_key=font_key)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "Verbosity", "whole_func_string": "class Verbosity(IntEnum):\n                                                \n\n                                  \n    quiet = -1                           \n    default = 0                             \n    debug = 1                                   \n    debug_all = 2", "func_code_string": "class Verbosity(IntEnum):\n                                                \n\n                                  \n    quiet = -1                           \n    default = 0                             \n    debug = 1                                   \n    debug_all = 2", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "configure_logging", "whole_func_string": "def configure_logging(\n    verbosity: Verbosity,\n    *,\n    progress_bar_friendly: bool = True,\n    manage_root_logger: bool = False,\n    plugin_manager: pluggy.PluginManager | None = None,\n):\n           \n    prefix = '' if manage_root_logger else 'ocrmypdf'\n\n    log = logging.getLogger(prefix)\n    log.setLevel(logging.DEBUG)\n\n    console = None\n    if plugin_manager and progress_bar_friendly:\n        console = plugin_manager.hook.get_logging_console()\n\n    if not console:\n        console = logging.StreamHandler(stream=sys.stderr)\n\n    if verbosity < 0:\n        console.setLevel(logging.ERROR)\n    elif verbosity >= 1:\n        console.setLevel(logging.DEBUG)\n    else:\n        console.setLevel(logging.INFO)\n\n    console.addFilter(PageNumberFilter())\n\n    if verbosity >= 2:\n        fmt = '%(levelname)7s %(name)s -%(pageno)s %(message)s'\n    else:\n        fmt = '%(pageno)s%(message)s'\n\n    formatter = None\n\n    if not formatter:\n        formatter = logging.Formatter(fmt=fmt)\n\n    console.setFormatter(formatter)\n    log.addHandler(console)\n\n    if verbosity <= 1:\n        pdfminer_log = logging.getLogger('pdfminer')\n        pdfminer_log.setLevel(logging.ERROR)\n        pil_log = logging.getLogger('PIL')\n        pil_log.setLevel(logging.INFO)\n\n    if manage_root_logger:\n        logging.captureWarnings(True)\n\n    return log", "func_code_string": "def configure_logging(\n    verbosity: Verbosity,\n    *,\n    progress_bar_friendly: bool = True,\n    manage_root_logger: bool = False,\n    plugin_manager: pluggy.PluginManager | None = None,\n):\n           \n    prefix = '' if manage_root_logger else 'ocrmypdf'\n\n    log = logging.getLogger(prefix)\n    log.setLevel(logging.DEBUG)\n\n    console = None\n    if plugin_manager and progress_bar_friendly:\n        console = plugin_manager.hook.get_logging_console()\n\n    if not console:\n        console = logging.StreamHandler(stream=sys.stderr)\n\n    if verbosity < 0:\n        console.setLevel(logging.ERROR)\n    elif verbosity >= 1:\n        console.setLevel(logging.DEBUG)\n    else:\n        console.setLevel(logging.INFO)\n\n    console.addFilter(PageNumberFilter())\n\n    if verbosity >= 2:\n        fmt = '%(levelname)7s %(name)s -%(pageno)s %(message)s'\n    else:\n        fmt = '%(pageno)s%(message)s'\n\n    formatter = None\n\n    if not formatter:\n        formatter = logging.Formatter(fmt=fmt)\n\n    console.setFormatter(formatter)\n    log.addHandler(console)\n\n    if verbosity <= 1:\n        pdfminer_log = logging.getLogger('pdfminer')\n        pdfminer_log.setLevel(logging.ERROR)\n        pil_log = logging.getLogger('PIL')\n        pil_log.setLevel(logging.INFO)\n\n    if manage_root_logger:\n        logging.captureWarnings(True)\n\n    return log", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "_kwargs_to_cmdline", "whole_func_string": "def _kwargs_to_cmdline(\n    *, defer_kwargs: set[str], **kwargs\n) -> tuple[list[str | bytes], dict[str, str | bytes]]:\n                                                   \n    cmdline: list[str | bytes] = []\n    deferred = {}\n    for arg, val in kwargs.items():\n        if val is None:\n            continue\n\n                                                   \n        if arg in defer_kwargs:\n            deferred[arg] = val\n            continue\n\n        cmd_style_arg = arg.replace('_', '-')\n\n                                                                \n        if isinstance(val, bool):\n            if val:\n                cmdline.append(f\"--{cmd_style_arg}\")\n            continue\n\n        if is_iterable_notstr(val):\n            for elem in val:\n                cmdline.append(f\"--{cmd_style_arg}\")\n                cmdline.append(elem)\n            continue\n\n                             \n        cmdline.append(f\"--{cmd_style_arg}\")\n        if isinstance(val, int | float):\n            cmdline.append(str(val))\n        elif isinstance(val, str):\n            cmdline.append(val)\n        elif isinstance(val, Path):\n            cmdline.append(str(val))\n        else:\n            raise TypeError(f\"{arg}: {val} ({type(val)})\")\n    return cmdline, deferred", "func_code_string": "def _kwargs_to_cmdline(\n    *, defer_kwargs: set[str], **kwargs\n) -> tuple[list[str | bytes], dict[str, str | bytes]]:\n                                                   \n    cmdline: list[str | bytes] = []\n    deferred = {}\n    for arg, val in kwargs.items():\n        if val is None:\n            continue\n\n                                                   \n        if arg in defer_kwargs:\n            deferred[arg] = val\n            continue\n\n        cmd_style_arg = arg.replace('_', '-')\n\n                                                                \n        if isinstance(val, bool):\n            if val:\n                cmdline.append(f\"--{cmd_style_arg}\")\n            continue\n\n        if is_iterable_notstr(val):\n            for elem in val:\n                cmdline.append(f\"--{cmd_style_arg}\")\n                cmdline.append(elem)\n            continue\n\n                             \n        cmdline.append(f\"--{cmd_style_arg}\")\n        if isinstance(val, int | float):\n            cmdline.append(str(val))\n        elif isinstance(val, str):\n            cmdline.append(val)\n        elif isinstance(val, Path):\n            cmdline.append(str(val))\n        else:\n            raise TypeError(f\"{arg}: {val} ({type(val)})\")\n    return cmdline, deferred", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "create_options", "whole_func_string": "def create_options(\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\n) -> Namespace:\n           \n    cmdline, deferred = _kwargs_to_cmdline(\n        defer_kwargs={'progress_bar', 'plugins', 'parser', 'input_file', 'output_file'},\n        **kwargs,\n    )\n    if isinstance(input_file, BinaryIO | IOBase):\n        cmdline.append('stream://input_file')\n    else:\n        cmdline.append(os.fspath(input_file))\n    if isinstance(output_file, BinaryIO | IOBase):\n        cmdline.append('stream://output_file')\n    else:\n        cmdline.append(os.fspath(output_file))\n    if 'sidecar' in kwargs and isinstance(kwargs['sidecar'], BinaryIO | IOBase):\n        cmdline.append('--sidecar')\n        cmdline.append('stream://sidecar')\n\n    parser.enable_api_mode()\n    options = parser.parse_args(cmdline)\n    for keyword, val in deferred.items():\n        setattr(options, keyword, val)\n\n    if options.input_file == 'stream://input_file':\n        options.input_file = input_file\n    if options.output_file == 'stream://output_file':\n        options.output_file = output_file\n    if options.sidecar == 'stream://sidecar':\n        options.sidecar = kwargs['sidecar']\n\n    return options", "func_code_string": "def create_options(\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\n) -> Namespace:\n           \n    cmdline, deferred = _kwargs_to_cmdline(\n        defer_kwargs={'progress_bar', 'plugins', 'parser', 'input_file', 'output_file'},\n        **kwargs,\n    )\n    if isinstance(input_file, BinaryIO | IOBase):\n        cmdline.append('stream://input_file')\n    else:\n        cmdline.append(os.fspath(input_file))\n    if isinstance(output_file, BinaryIO | IOBase):\n        cmdline.append('stream://output_file')\n    else:\n        cmdline.append(os.fspath(output_file))\n    if 'sidecar' in kwargs and isinstance(kwargs['sidecar'], BinaryIO | IOBase):\n        cmdline.append('--sidecar')\n        cmdline.append('stream://sidecar')\n\n    parser.enable_api_mode()\n    options = parser.parse_args(cmdline)\n    for keyword, val in deferred.items():\n        setattr(options, keyword, val)\n\n    if options.input_file == 'stream://input_file':\n        options.input_file = input_file\n    if options.output_file == 'stream://output_file':\n        options.output_file = output_file\n    if options.sidecar == 'stream://sidecar':\n        options.sidecar = kwargs['sidecar']\n\n    return options", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "ocr", "whole_func_string": "def ocr(              \n    input_file: PathOrIO,\n    output_file: PathOrIO,\n    *,\n    language: Iterable[str] | None = None,\n    image_dpi: int | None = None,\n    output_type: str | None = None,\n    sidecar: PathOrIO | None = None,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    title: str | None = None,\n    author: str | None = None,\n    subject: str | None = None,\n    keywords: str | None = None,\n    rotate_pages: bool | None = None,\n    remove_background: bool | None = None,\n    deskew: bool | None = None,\n    clean: bool | None = None,\n    clean_final: bool | None = None,\n    unpaper_args: str | None = None,\n    oversample: int | None = None,\n    remove_vectors: bool | None = None,\n    force_ocr: bool | None = None,\n    skip_text: bool | None = None,\n    redo_ocr: bool | None = None,\n    skip_big: float | None = None,\n    optimize: int | None = None,\n    jpg_quality: int | None = None,\n    png_quality: int | None = None,\n    jbig2_lossy: bool | None = None,\n    jbig2_page_group_size: int | None = None,\n    jbig2_threshold: float | None = None,\n    pages: str | None = None,\n    max_image_mpixels: float | None = None,\n    tesseract_config: Iterable[str] | None = None,\n    tesseract_pagesegmode: int | None = None,\n    tesseract_oem: int | None = None,\n    tesseract_thresholding: int | None = None,\n    pdf_renderer: str | None = None,\n    tesseract_timeout: float | None = None,\n    tesseract_non_ocr_timeout: float | None = None,\n    tesseract_downsample_above: int | None = None,\n    tesseract_downsample_large_images: bool | None = None,\n    rotate_pages_threshold: float | None = None,\n    pdfa_image_compression: str | None = None,\n    color_conversion_strategy: str | None = None,\n    user_words: os.PathLike | None = None,\n    user_patterns: os.PathLike | None = None,\n    fast_web_view: float | None = None,\n    continue_on_soft_render_error: bool | None = None,\n    invalidate_digital_signatures: bool | None = None,\n    plugins: Iterable[Path | str] | None = None,\n    plugin_manager=None,\n    keep_temporary_files: bool | None = None,\n    progress_bar: bool | None = None,\n    **kwargs,\n):\n           \n    if plugins and plugin_manager:\n        raise ValueError(\"plugins= and plugin_manager are mutually exclusive\")\n\n    if not plugins:\n        plugins = []\n    elif isinstance(plugins, str | Path):\n        plugins = [plugins]\n    else:\n        plugins = list(plugins)\n\n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'input_file', 'output_file', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        if 'verbose' in kwargs:\n            warn(\"ocrmypdf.ocr(verbose=) is ignored. Use ocrmypdf.configure_logging().\")\n\n        options = create_options(\n            input_file=input_file,\n            output_file=output_file,\n            parser=parser,\n            **create_options_kwargs,\n        )\n        check_options(options, plugin_manager)\n        return run_pipeline(options=options, plugin_manager=plugin_manager)", "func_code_string": "def ocr(              \n    input_file: PathOrIO,\n    output_file: PathOrIO,\n    *,\n    language: Iterable[str] | None = None,\n    image_dpi: int | None = None,\n    output_type: str | None = None,\n    sidecar: PathOrIO | None = None,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    title: str | None = None,\n    author: str | None = None,\n    subject: str | None = None,\n    keywords: str | None = None,\n    rotate_pages: bool | None = None,\n    remove_background: bool | None = None,\n    deskew: bool | None = None,\n    clean: bool | None = None,\n    clean_final: bool | None = None,\n    unpaper_args: str | None = None,\n    oversample: int | None = None,\n    remove_vectors: bool | None = None,\n    force_ocr: bool | None = None,\n    skip_text: bool | None = None,\n    redo_ocr: bool | None = None,\n    skip_big: float | None = None,\n    optimize: int | None = None,\n    jpg_quality: int | None = None,\n    png_quality: int | None = None,\n    jbig2_lossy: bool | None = None,\n    jbig2_page_group_size: int | None = None,\n    jbig2_threshold: float | None = None,\n    pages: str | None = None,\n    max_image_mpixels: float | None = None,\n    tesseract_config: Iterable[str] | None = None,\n    tesseract_pagesegmode: int | None = None,\n    tesseract_oem: int | None = None,\n    tesseract_thresholding: int | None = None,\n    pdf_renderer: str | None = None,\n    tesseract_timeout: float | None = None,\n    tesseract_non_ocr_timeout: float | None = None,\n    tesseract_downsample_above: int | None = None,\n    tesseract_downsample_large_images: bool | None = None,\n    rotate_pages_threshold: float | None = None,\n    pdfa_image_compression: str | None = None,\n    color_conversion_strategy: str | None = None,\n    user_words: os.PathLike | None = None,\n    user_patterns: os.PathLike | None = None,\n    fast_web_view: float | None = None,\n    continue_on_soft_render_error: bool | None = None,\n    invalidate_digital_signatures: bool | None = None,\n    plugins: Iterable[Path | str] | None = None,\n    plugin_manager=None,\n    keep_temporary_files: bool | None = None,\n    progress_bar: bool | None = None,\n    **kwargs,\n):\n           \n    if plugins and plugin_manager:\n        raise ValueError(\"plugins= and plugin_manager are mutually exclusive\")\n\n    if not plugins:\n        plugins = []\n    elif isinstance(plugins, str | Path):\n        plugins = [plugins]\n    else:\n        plugins = list(plugins)\n\n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'input_file', 'output_file', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        if 'verbose' in kwargs:\n            warn(\"ocrmypdf.ocr(verbose=) is ignored. Use ocrmypdf.configure_logging().\")\n\n        options = create_options(\n            input_file=input_file,\n            output_file=output_file,\n            parser=parser,\n            **create_options_kwargs,\n        )\n        check_options(options, plugin_manager)\n        return run_pipeline(options=options, plugin_manager=plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "_pdf_to_hocr", "whole_func_string": "def _pdf_to_hocr(              \n    input_pdf: Path,\n    output_folder: Path,\n    *,\n    language: Iterable[str] | None = None,\n    image_dpi: int | None = None,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    title: str | None = None,\n    author: str | None = None,\n    subject: str | None = None,\n    keywords: str | None = None,\n    rotate_pages: bool | None = None,\n    remove_background: bool | None = None,\n    deskew: bool | None = None,\n    clean: bool | None = None,\n    clean_final: bool | None = None,\n    unpaper_args: str | None = None,\n    oversample: int | None = None,\n    remove_vectors: bool | None = None,\n    force_ocr: bool | None = None,\n    skip_text: bool | None = None,\n    redo_ocr: bool | None = None,\n    skip_big: float | None = None,\n    pages: str | None = None,\n    max_image_mpixels: float | None = None,\n    tesseract_config: Iterable[str] | None = None,\n    tesseract_pagesegmode: int | None = None,\n    tesseract_oem: int | None = None,\n    tesseract_thresholding: int | None = None,\n    tesseract_timeout: float | None = None,\n    tesseract_non_ocr_timeout: float | None = None,\n    tesseract_downsample_above: int | None = None,\n    tesseract_downsample_large_images: bool | None = None,\n    rotate_pages_threshold: float | None = None,\n    user_words: os.PathLike | None = None,\n    user_patterns: os.PathLike | None = None,\n    continue_on_soft_render_error: bool | None = None,\n    invalidate_digital_signatures: bool | None = None,\n    plugin_manager=None,\n    plugins: Sequence[Path | str] | None = None,\n    keep_temporary_files: bool | None = None,\n    **kwargs,\n):\n           \n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'input_pdf', 'output_folder', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        cmdline, deferred = _kwargs_to_cmdline(\n            defer_kwargs={'input_pdf', 'output_folder', 'plugins'},\n            **create_options_kwargs,\n        )\n        cmdline.append(str(input_pdf))\n        cmdline.append(str(output_folder))\n        parser.enable_api_mode()\n        options = parser.parse_args(cmdline)\n        for keyword, val in deferred.items():\n            setattr(options, keyword, val)\n        delattr(options, 'output_file')\n        setattr(options, 'output_folder', output_folder)\n\n        return run_hocr_pipeline(options=options, plugin_manager=plugin_manager)", "func_code_string": "def _pdf_to_hocr(              \n    input_pdf: Path,\n    output_folder: Path,\n    *,\n    language: Iterable[str] | None = None,\n    image_dpi: int | None = None,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    title: str | None = None,\n    author: str | None = None,\n    subject: str | None = None,\n    keywords: str | None = None,\n    rotate_pages: bool | None = None,\n    remove_background: bool | None = None,\n    deskew: bool | None = None,\n    clean: bool | None = None,\n    clean_final: bool | None = None,\n    unpaper_args: str | None = None,\n    oversample: int | None = None,\n    remove_vectors: bool | None = None,\n    force_ocr: bool | None = None,\n    skip_text: bool | None = None,\n    redo_ocr: bool | None = None,\n    skip_big: float | None = None,\n    pages: str | None = None,\n    max_image_mpixels: float | None = None,\n    tesseract_config: Iterable[str] | None = None,\n    tesseract_pagesegmode: int | None = None,\n    tesseract_oem: int | None = None,\n    tesseract_thresholding: int | None = None,\n    tesseract_timeout: float | None = None,\n    tesseract_non_ocr_timeout: float | None = None,\n    tesseract_downsample_above: int | None = None,\n    tesseract_downsample_large_images: bool | None = None,\n    rotate_pages_threshold: float | None = None,\n    user_words: os.PathLike | None = None,\n    user_patterns: os.PathLike | None = None,\n    continue_on_soft_render_error: bool | None = None,\n    invalidate_digital_signatures: bool | None = None,\n    plugin_manager=None,\n    plugins: Sequence[Path | str] | None = None,\n    keep_temporary_files: bool | None = None,\n    **kwargs,\n):\n           \n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'input_pdf', 'output_folder', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        cmdline, deferred = _kwargs_to_cmdline(\n            defer_kwargs={'input_pdf', 'output_folder', 'plugins'},\n            **create_options_kwargs,\n        )\n        cmdline.append(str(input_pdf))\n        cmdline.append(str(output_folder))\n        parser.enable_api_mode()\n        options = parser.parse_args(cmdline)\n        for keyword, val in deferred.items():\n            setattr(options, keyword, val)\n        delattr(options, 'output_file')\n        setattr(options, 'output_folder', output_folder)\n\n        return run_hocr_pipeline(options=options, plugin_manager=plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "_hocr_to_ocr_pdf", "whole_func_string": "def _hocr_to_ocr_pdf(              \n    work_folder: Path,\n    output_file: Path,\n    *,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    optimize: int | None = None,\n    jpg_quality: int | None = None,\n    png_quality: int | None = None,\n    jbig2_lossy: bool | None = None,\n    jbig2_page_group_size: int | None = None,\n    jbig2_threshold: float | None = None,\n    pdfa_image_compression: str | None = None,\n    color_conversion_strategy: str | None = None,\n    fast_web_view: float | None = None,\n    plugin_manager=None,\n    plugins: Sequence[Path | str] | None = None,\n    **kwargs,\n):\n           \n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'work_folder', 'output_pdf', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        cmdline, deferred = _kwargs_to_cmdline(\n            defer_kwargs={'work_folder', 'output_file', 'plugins'},\n            **create_options_kwargs,\n        )\n        cmdline.append(str(work_folder))\n        cmdline.append(str(output_file))\n        parser.enable_api_mode()\n        options = parser.parse_args(cmdline)\n        for keyword, val in deferred.items():\n            setattr(options, keyword, val)\n        delattr(options, 'input_file')\n        setattr(options, 'work_folder', work_folder)\n\n        return run_hocr_to_ocr_pdf_pipeline(\n            options=options, plugin_manager=plugin_manager\n        )", "func_code_string": "def _hocr_to_ocr_pdf(              \n    work_folder: Path,\n    output_file: Path,\n    *,\n    jobs: int | None = None,\n    use_threads: bool | None = None,\n    optimize: int | None = None,\n    jpg_quality: int | None = None,\n    png_quality: int | None = None,\n    jbig2_lossy: bool | None = None,\n    jbig2_page_group_size: int | None = None,\n    jbig2_threshold: float | None = None,\n    pdfa_image_compression: str | None = None,\n    color_conversion_strategy: str | None = None,\n    fast_web_view: float | None = None,\n    plugin_manager=None,\n    plugins: Sequence[Path | str] | None = None,\n    **kwargs,\n):\n           \n                                                                            \n    create_options_kwargs = {\n        k: v\n        for k, v in locals().items()\n        if k not in {'work_folder', 'output_pdf', 'kwargs'}\n    }\n    create_options_kwargs.update(kwargs)\n\n    parser = get_parser()\n\n    with _api_lock:\n        if not plugin_manager:\n            plugin_manager = get_plugin_manager(plugins)\n        plugin_manager.hook.add_options(parser=parser)                             \n\n        cmdline, deferred = _kwargs_to_cmdline(\n            defer_kwargs={'work_folder', 'output_file', 'plugins'},\n            **create_options_kwargs,\n        )\n        cmdline.append(str(work_folder))\n        cmdline.append(str(output_file))\n        parser.enable_api_mode()\n        options = parser.parse_args(cmdline)\n        for keyword, val in deferred.items():\n            setattr(options, keyword, val)\n        delattr(options, 'input_file')\n        setattr(options, 'work_folder', work_folder)\n\n        return run_hocr_to_ocr_pdf_pipeline(\n            options=options, plugin_manager=plugin_manager\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/imageops.py", "func_name": "bytes_per_pixel", "whole_func_string": "def bytes_per_pixel(mode: str) -> int:\n           \n    if mode in ('1', 'L', 'P'):\n        return 1\n    if mode in ('LA', 'PA', 'La') or mode.startswith('I;16'):\n        return 2\n    return 4", "func_code_string": "def bytes_per_pixel(mode: str) -> int:\n           \n    if mode in ('1', 'L', 'P'):\n        return 1\n    if mode in ('LA', 'PA', 'La') or mode.startswith('I;16'):\n        return 2\n    return 4", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/imageops.py", "func_name": "_calculate_downsample", "whole_func_string": "def _calculate_downsample(\n    image_size: tuple[int, int],\n    bytes_per_pixel: int,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    size = image_size\n\n    if max_size is not None:\n        overage = max_size[0] / size[0], max_size[1] / size[1]\n        size_factor = min(overage)\n        if size_factor < 1.0:\n            log.debug(\"Resizing image to fit image dimensions limit\")\n            size = floor(size[0] * size_factor), floor(size[1] * size_factor)\n            if size[0] == 0:\n                size = 1, min(size[1], max_size[1])\n            elif size[1] == 0:\n                size = min(size[0], max_size[0]), 1\n\n    if max_pixels is not None:\n        if size[0] * size[1] > max_pixels:\n            log.debug(\"Resizing image to fit image pixel limit\")\n            pixels_factor = sqrt(max_pixels / (size[0] * size[1]))\n            size = floor(size[0] * pixels_factor), floor(size[1] * pixels_factor)\n\n    if max_bytes is not None:\n        bpp = bytes_per_pixel\n                                 \n        stride = size[0] * bpp\n        height = size[1]\n        if stride * height > max_bytes:\n            log.debug(\"Resizing image to fit image byte size limit\")\n            bytes_factor = sqrt(max_bytes / (stride * height))\n            scaled_stride = floor(stride * bytes_factor)\n            scaled_height = floor(height * bytes_factor)\n            if scaled_stride == 0:\n                scaled_stride = bpp\n                scaled_height = min(max_bytes // bpp, scaled_height)\n            if scaled_height == 0:\n                scaled_height = 1\n                scaled_stride = min(max_bytes // scaled_height, scaled_stride)\n            size = floor(scaled_stride / bpp), scaled_height\n\n    return size", "func_code_string": "def _calculate_downsample(\n    image_size: tuple[int, int],\n    bytes_per_pixel: int,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    size = image_size\n\n    if max_size is not None:\n        overage = max_size[0] / size[0], max_size[1] / size[1]\n        size_factor = min(overage)\n        if size_factor < 1.0:\n            log.debug(\"Resizing image to fit image dimensions limit\")\n            size = floor(size[0] * size_factor), floor(size[1] * size_factor)\n            if size[0] == 0:\n                size = 1, min(size[1], max_size[1])\n            elif size[1] == 0:\n                size = min(size[0], max_size[0]), 1\n\n    if max_pixels is not None:\n        if size[0] * size[1] > max_pixels:\n            log.debug(\"Resizing image to fit image pixel limit\")\n            pixels_factor = sqrt(max_pixels / (size[0] * size[1]))\n            size = floor(size[0] * pixels_factor), floor(size[1] * pixels_factor)\n\n    if max_bytes is not None:\n        bpp = bytes_per_pixel\n                                 \n        stride = size[0] * bpp\n        height = size[1]\n        if stride * height > max_bytes:\n            log.debug(\"Resizing image to fit image byte size limit\")\n            bytes_factor = sqrt(max_bytes / (stride * height))\n            scaled_stride = floor(stride * bytes_factor)\n            scaled_height = floor(height * bytes_factor)\n            if scaled_stride == 0:\n                scaled_stride = bpp\n                scaled_height = min(max_bytes // bpp, scaled_height)\n            if scaled_height == 0:\n                scaled_height = 1\n                scaled_stride = min(max_bytes // scaled_height, scaled_stride)\n            size = floor(scaled_stride / bpp), scaled_height\n\n    return size", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/imageops.py", "func_name": "calculate_downsample", "whole_func_string": "def calculate_downsample(\n    image: Image.Image,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    return _calculate_downsample(\n        image.size,\n        bytes_per_pixel(image.mode),\n        max_size=max_size,\n        max_pixels=max_pixels,\n        max_bytes=max_bytes,\n    )", "func_code_string": "def calculate_downsample(\n    image: Image.Image,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    return _calculate_downsample(\n        image.size,\n        bytes_per_pixel(image.mode),\n        max_size=max_size,\n        max_pixels=max_pixels,\n        max_bytes=max_bytes,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/imageops.py", "func_name": "downsample_image", "whole_func_string": "def downsample_image(\n    image: Image.Image,\n    new_size: tuple[int, int],\n    *,\n    resample_mode: Image.Resampling = Image.Resampling.BICUBIC,\n    reducing_gap: int = 3,\n) -> Image.Image:\n           \n    if new_size == image.size:\n        return image\n\n    original_size = image.size\n    original_dpi = image.info['dpi']\n    image = image.resize(\n        new_size,\n        resample=resample_mode,\n        reducing_gap=reducing_gap,\n    )\n    image.info['dpi'] = (\n        round(original_dpi[0] * new_size[0] / original_size[0]),\n        round(original_dpi[1] * new_size[1] / original_size[1]),\n    )\n    log.debug(f\"Rescaled image to {image.size} pixels and {image.info['dpi']} dpi\")\n    return image", "func_code_string": "def downsample_image(\n    image: Image.Image,\n    new_size: tuple[int, int],\n    *,\n    resample_mode: Image.Resampling = Image.Resampling.BICUBIC,\n    reducing_gap: int = 3,\n) -> Image.Image:\n           \n    if new_size == image.size:\n        return image\n\n    original_size = image.size\n    original_dpi = image.info['dpi']\n    image = image.resize(\n        new_size,\n        resample=resample_mode,\n        reducing_gap=reducing_gap,\n    )\n    image.info['dpi'] = (\n        round(original_dpi[0] * new_size[0] / original_size[0]),\n        round(original_dpi[1] * new_size[1] / original_size[1]),\n    )\n    log.debug(f\"Rescaled image to {image.size} pixels and {image.info['dpi']} dpi\")\n    return image", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "numeric", "whole_func_string": "def numeric(basetype: Callable[[Any], T], min_: T | None = None, max_: T | None = None):\n           \n    min_ = basetype(min_) if min_ is not None else None\n    max_ = basetype(max_) if max_ is not None else None\n\n    def _numeric(s: str) -> T:\n        value = basetype(s)\n        if (min_ is not None and value < min_) or (max_ is not None and value > max_):\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} not in valid range {(min_, max_)!r}\"\n            )\n        return value\n\n    _numeric.__name__ = basetype.__name__\n    return _numeric", "func_code_string": "def numeric(basetype: Callable[[Any], T], min_: T | None = None, max_: T | None = None):\n           \n    min_ = basetype(min_) if min_ is not None else None\n    max_ = basetype(max_) if max_ is not None else None\n\n    def _numeric(s: str) -> T:\n        value = basetype(s)\n        if (min_ is not None and value < min_) or (max_ is not None and value > max_):\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} not in valid range {(min_, max_)!r}\"\n            )\n        return value\n\n    _numeric.__name__ = basetype.__name__\n    return _numeric", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "str_to_int", "whole_func_string": "def str_to_int(mapping: Mapping[str, int]):\n                                                             \n\n    def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None\n\n    return _str_to_int", "func_code_string": "def str_to_int(mapping: Mapping[str, int]):\n                                                             \n\n    def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None\n\n    return _str_to_int", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "ArgumentParser", "whole_func_string": "class ArgumentParser(argparse.ArgumentParser):\n           \n\n    def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False\n\n    def enable_api_mode(self):\n                   \n        self._api_mode = True\n\n    def error(self, message):\n                                                           \n        if not self._api_mode:\n            super().error(message)\n            return\n        raise ValueError(message)", "func_code_string": "class ArgumentParser(argparse.ArgumentParser):\n           \n\n    def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False\n\n    def enable_api_mode(self):\n                   \n        self._api_mode = True\n\n    def error(self, message):\n                                                           \n        if not self._api_mode:\n            super().error(message)\n            return\n        raise ValueError(message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "LanguageSetAction", "whole_func_string": "class LanguageSetAction(argparse.Action):\n                                      \n\n    def __init__(self, option_strings, dest, default=None, **kwargs):\n                                    \n        if default is None:\n            default = list()\n        super().__init__(option_strings, dest, default=default, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_code_string": "class LanguageSetAction(argparse.Action):\n                                      \n\n    def __init__(self, option_strings, dest, default=None, **kwargs):\n                                    \n        if default is None:\n            default = list()\n        super().__init__(option_strings, dest, default=default, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "get_parser", "whole_func_string": "def get_parser():\n                                  \n    parser = ArgumentParser(\n        prog=_PROGRAM_NAME,\n        allow_abbrev=True,\n        fromfile_prefix_chars='@',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"\\\nGenerates a searchable PDF or PDF/A from a regular PDF.\n\nOCRmyPDF rasterizes each page of the input PDF, optionally corrects page\nrotation and performs image processing, runs the Tesseract OCR engine on the\nimage, and then creates a PDF from the OCR information.\n\"\"\",\n        epilog=\"\"\"\\\nOCRmyPDF attempts to keep the output file at about the same size.  If a file\ncontains losslessly compressed images, and images in the output file will be\nlosslessly compressed as well.\n\nPDF is a page description file that attempts to preserve a layout exactly.\nA PDF can contain vector objects (such as text or lines) and raster objects\n(images).  A page might have multiple images.  OCRmyPDF is prepared to deal\nwith the wide variety of PDFs that exist in the wild.\n\nWhen a PDF page contains text, OCRmyPDF assumes that the page has already\nbeen OCRed or is a \"born digital\" page that should not be OCRed.  The default\nbehavior is to exit in this case without producing a file.  You can use the\noption --skip-text to ignore pages with text, or --force-ocr to rasterize\nall objects on the page and produce an image-only PDF as output.\n\n    ocrmypdf --skip-text file_with_some_text_pages.pdf output.pdf\n\n    ocrmypdf --force-ocr word_document.pdf output.pdf\n\nIf you are concerned about long-term archiving of PDFs, use the default option\n--output-type pdfa which converts the PDF to a standardized PDF/A-2b.  This\nremoves some features from the PDF such as Javascript or forms. If you want to\nminimize the number of changes made to your PDF, use --output-type pdf.\n\nIf OCRmyPDF is given an image file as input, it will attempt to convert the\nimage to a PDF before processing.  For more control over the conversion of\nimages to PDF, use the Python package img2pdf or other image to PDF software.\n\nFor example, this command uses img2pdf to convert all .png files beginning\nwith the 'page' prefix to a PDF, fitting each image on A4-sized paper, and\nsending the result to OCRmyPDF through a pipe.\n\n    img2pdf --pagesize A4 page*.png | ocrmypdf - myfile.pdf\n\nOnline documentation is located at:\n    https://ocrmypdf.readthedocs.io/en/latest/introduction.html\n\n\"\"\",\n    )\n\n    parser.add_argument(\n        'input_file',\n        metavar=\"input_pdf_or_image\",\n        help=\"PDF file containing the images to be OCRed (or '-' to read from \"\n        \"standard input)\",\n    )\n    parser.add_argument(\n        'output_file',\n        metavar=\"output_pdf\",\n        help=\"Output searchable PDF file (or '-' to write to standard output). \"\n        \"Existing files will be overwritten. If same as input file, the \"\n        \"input file will be updated only if processing is successful.\",\n    )\n    parser.add_argument(\n        '-l',\n        '--language',\n        dest='languages',\n        action=LanguageSetAction,\n        help=\"Language(s) of the file to be OCRed (see tesseract --list-langs for \"\n        \"all language packs installed in your system). Use -l eng+deu for \"\n        \"multiple languages.\",\n    )\n    parser.add_argument(\n        '--image-dpi',\n        metavar='DPI',\n        type=int,\n        help=\"When the input file is an image, not a PDF, use this DPI instead \"\n        \"of the DPI claimed by the input file. If the input does not claim a \"\n        \"sensible DPI, this option will be required.\",\n    )\n    parser.add_argument(\n        '--output-type',\n        choices=['pdfa', 'pdf', 'pdfa-1', 'pdfa-2', 'pdfa-3', 'none'],\n        default='pdfa',\n        help=\"Choose output type. 'pdfa' creates a PDF/A-2b compliant file for \"\n        \"long term archiving (default, recommended) but may not suitable \"\n        \"for users who want their file altered as little as possible. 'pdfa' \"\n        \"also has problems with full Unicode text. 'pdf' minimizes changes \"\n        \"to the input file. 'pdf-a1' creates a \"\n        \"PDF/A1-b file. 'pdf-a2' is equivalent to 'pdfa'. 'pdf-a3' creates a \"\n        \"PDF/A3-b file. 'none' will produce no output, which may be helpful if \"\n        \"only the --sidecar is desired.\",\n    )\n\n                                                                                 \n                                                                             \n                                  \n    parser.add_argument(\n        '--sidecar',\n        nargs='?',\n        const='\\0',\n        default=None,\n        metavar='FILE',\n        help=\"Generate sidecar text files that contain the same text recognized \"\n        \"by Tesseract. This may be useful for building a OCR text database. \"\n        \"If FILE is omitted, the sidecar file be named {output_file}.txt; the next \"\n        \"argument must NOT be the name of the input PDF. \"\n        \"If FILE is set to '-', the sidecar is written to stdout (a \"\n        \"convenient way to preview OCR quality). The output file and sidecar \"\n        \"may not both use stdout at the same time.\",\n    )\n\n    parser.add_argument(\n        '--version',\n        action='version',\n        version=_VERSION,\n        help=\"Print program version and exit\",\n    )\n\n    jobcontrol = parser.add_argument_group(\"Job control options\")\n    jobcontrol.add_argument(\n        '-j',\n        '--jobs',\n        metavar='N',\n        type=numeric(int, 0, 256),\n        help=\"Use up to N CPU cores simultaneously (default: use all).\",\n    )\n    jobcontrol.add_argument(\n        '-q', '--quiet', action='store_true', help=\"Suppress INFO messages\"\n    )\n    jobcontrol.add_argument(\n        '-v',\n        '--verbose',\n        type=numeric(int, 0, 2),\n        default=0,\n        const=1,\n        nargs='?',\n        help=\"Print more verbose messages for each additional verbose level. Use \"\n        \"`-v 1` typically for much more detailed logging. Higher numbers \"\n        \"are probably only useful in debugging.\",\n    )\n    jobcontrol.add_argument(\n        '--no-progress-bar',\n        action='store_false',\n        dest='progress_bar',\n        help=argparse.SUPPRESS,\n    )\n    jobcontrol.add_argument(\n        '--use-threads', action='store_true', default=True, help=argparse.SUPPRESS\n    )\n    jobcontrol.add_argument(\n        '--no-use-threads',\n        action='store_false',\n        dest='use_threads',\n        help=argparse.SUPPRESS,\n    )\n\n    metadata = parser.add_argument_group(\n        \"Metadata options\",\n        \"Set output PDF/A metadata (default: copy input document's metadata)\",\n    )\n    metadata.add_argument(\n        '--title', type=str, help=\"Set document title (place multiple words in quotes)\"\n    )\n    metadata.add_argument('--author', type=str, help=\"Set document author\")\n    metadata.add_argument(\n        '--subject', type=str, help=\"Set document subject description\"\n    )\n    metadata.add_argument('--keywords', type=str, help=\"Set document keywords\")\n\n    preprocessing = parser.add_argument_group(\n        \"Image preprocessing options\",\n        \"Options to improve the quality of the final PDF and OCR\",\n    )\n    preprocessing.add_argument(\n        '-r',\n        '--rotate-pages',\n        action='store_true',\n        help=\"Automatically rotate pages based on detected text orientation\",\n    )\n    preprocessing.add_argument(\n        '--remove-background',\n        action='store_true',\n        help=\"Attempt to remove background from gray or color pages, setting it \"\n        \"to white \",\n    )\n    preprocessing.add_argument(\n        '-d',\n        '--deskew',\n        action='store_true',\n        help=\"Deskew each page before performing OCR\",\n    )\n    preprocessing.add_argument(\n        '-c',\n        '--clean',\n        action='store_true',\n        help=\"Clean pages from scanning artifacts before performing OCR, and send \"\n        \"the cleaned page to OCR, but do not include the cleaned page in \"\n        \"the output\",\n    )\n    preprocessing.add_argument(\n        '-i',\n        '--clean-final',\n        action='store_true',\n        help=\"Clean page as above, and incorporate the cleaned image in the final \"\n        \"PDF.  Might remove desired content.\",\n    )\n    preprocessing.add_argument(\n        '--unpaper-args',\n        type=str,\n        default=None,\n        help=\"A quoted string of arguments to pass to unpaper. Requires --clean. \"\n        \"Example: --unpaper-args '--layout double'.\",\n    )\n    preprocessing.add_argument(\n        '--oversample',\n        metavar='DPI',\n        type=numeric(int, 0, 5000),\n        default=0,\n        help=\"Oversample images to at least the specified DPI, to improve OCR \"\n        \"results slightly\",\n    )\n    preprocessing.add_argument(\n        '--remove-vectors',\n        action='store_true',\n        help=\"EXPERIMENTAL. Mask out any vector objects in the PDF so that they \"\n        \"will not be included in OCR. This can eliminate false characters.\",\n    )\n\n    ocrsettings = parser.add_argument_group(\"OCR options\", \"Control how OCR is applied\")\n    ocrsettings.add_argument(\n        '-f',\n        '--force-ocr',\n        action='store_true',\n        help=\"Rasterize any text or vector objects on each page, apply OCR, and \"\n        \"save the rastered output (this rewrites the PDF)\",\n    )\n    ocrsettings.add_argument(\n        '-s',\n        '--skip-text',\n        action='store_true',\n        help=\"Skip OCR on any pages that already contain text, but include the \"\n        \"page in final output; useful for PDFs that contain a mix of \"\n        \"images, text pages, and/or previously OCRed pages\",\n    )\n    ocrsettings.add_argument(\n        '--redo-ocr',\n        action='store_true',\n        help=\"Attempt to detect and remove the hidden OCR layer from files that \"\n        \"were previously OCRed with OCRmyPDF or another program. Apply OCR \"\n        \"to text found in raster images. Existing visible text objects will \"\n        \"not be changed. If there is no existing OCR, OCR will be added.\",\n    )\n    ocrsettings.add_argument(\n        '--skip-big',\n        type=numeric(float, 0, 5000),\n        metavar='MPixels',\n        help=\"Skip OCR on pages larger than the specified amount of megapixels, \"\n        \"but include skipped pages in final output\",\n    )\n    ocrsettings.add_argument(\n        '--invalidate-digital-signatures',\n        action='store_true',\n        help=\"Normally, OCRmyPDF will refuse to OCR a PDF that has a digital \"\n        \"signature. This option allows OCR to proceed, but the digital signature \"\n        \"will be invalidated.\",\n    )\n\n    advanced = parser.add_argument_group(\n        \"Advanced\", \"Advanced options to control OCRmyPDF\"\n    )\n    advanced.add_argument(\n        '--pages',\n        type=str,\n        help=(\n            \"Limit OCR to the specified pages (ranges or comma separated), \"\n            \"skipping others\"\n        ),\n    )\n    advanced.add_argument(\n        '--max-image-mpixels',\n        action='store',\n        type=numeric(float, 0),\n        metavar='MPixels',\n        help=\"Set maximum number of megapixels to unpack before treating an image as a \"\n        \"decompression bomb\",\n        default=250.0,\n    )\n    advanced.add_argument(\n        '--pdf-renderer',\n        choices=['auto', 'hocr', 'sandwich', 'hocrdebug'],\n        default='auto',\n        help=\"Choose OCR PDF renderer - the default option is to let OCRmyPDF \"\n        \"choose.  See documentation for discussion.\",\n    )\n    advanced.add_argument(\n        '--rotate-pages-threshold',\n        default=DEFAULT_ROTATE_PAGES_THRESHOLD,\n        type=numeric(float, 0, 1000),\n        metavar='CONFIDENCE',\n        help=\"Only rotate pages when confidence is above this value (arbitrary \"\n        \"units reported by tesseract)\",\n    )\n    advanced.add_argument(\n        '--fast-web-view',\n        type=numeric(float, 0),\n        default=1.0,\n        metavar=\"MEGABYTES\",\n        help=\"If the size of file is more than this threshold (in MB), then \"\n        \"linearize the PDF for fast web viewing. This allows the PDF to be \"\n        \"displayed before it is fully downloaded in web browsers, but increases \"\n        \"the space required slightly. By default we skip this for small files \"\n        \"which do not benefit. If the threshold is 0 it will be apply to all files. \"\n        \"Set the threshold very high to disable.\",\n    )\n    advanced.add_argument(\n        '--continue-on-soft-render-error',\n        action='store_true',\n        help=\"Continue processing pages after a recoverable PDF rendering error. \"\n        \"A recoverable error is one that does not prevent the page from being \"\n        \"rendered, but may result in visual differences compared to the input \"\n        \"file. Missing fonts are a typical source of these errors.\",\n    )\n    advanced.add_argument(\n        '--plugin',\n        dest='plugins',\n        action='append',\n        default=[],\n        help=\"Name of plugin to import. Argument may be issued multiple times to \"\n        \"import multiple plugins. Plugins may be specified as module names in \"\n        \"Python syntax, provided they are installed in the same Python (virtual) \"\n        \"environment as ocrmypdf; or you may give the path to the Python file that \"\n        \"contains the plugin. Plugins must conform to the specification in the \"\n        \"OCRmyPDF documentation.\",\n    )\n\n    debugging = parser.add_argument_group(\n        \"Debugging\", \"Arguments to help with troubleshooting and debugging\"\n    )\n    debugging.add_argument(\n        '-k',\n        '--keep-temporary-files',\n        action='store_true',\n        help=\"Keep temporary files (helpful for debugging)\",\n    )\n    return parser", "func_code_string": "def get_parser():\n                                  \n    parser = ArgumentParser(\n        prog=_PROGRAM_NAME,\n        allow_abbrev=True,\n        fromfile_prefix_chars='@',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"\\\nGenerates a searchable PDF or PDF/A from a regular PDF.\n\nOCRmyPDF rasterizes each page of the input PDF, optionally corrects page\nrotation and performs image processing, runs the Tesseract OCR engine on the\nimage, and then creates a PDF from the OCR information.\n\"\"\",\n        epilog=\"\"\"\\\nOCRmyPDF attempts to keep the output file at about the same size.  If a file\ncontains losslessly compressed images, and images in the output file will be\nlosslessly compressed as well.\n\nPDF is a page description file that attempts to preserve a layout exactly.\nA PDF can contain vector objects (such as text or lines) and raster objects\n(images).  A page might have multiple images.  OCRmyPDF is prepared to deal\nwith the wide variety of PDFs that exist in the wild.\n\nWhen a PDF page contains text, OCRmyPDF assumes that the page has already\nbeen OCRed or is a \"born digital\" page that should not be OCRed.  The default\nbehavior is to exit in this case without producing a file.  You can use the\noption --skip-text to ignore pages with text, or --force-ocr to rasterize\nall objects on the page and produce an image-only PDF as output.\n\n    ocrmypdf --skip-text file_with_some_text_pages.pdf output.pdf\n\n    ocrmypdf --force-ocr word_document.pdf output.pdf\n\nIf you are concerned about long-term archiving of PDFs, use the default option\n--output-type pdfa which converts the PDF to a standardized PDF/A-2b.  This\nremoves some features from the PDF such as Javascript or forms. If you want to\nminimize the number of changes made to your PDF, use --output-type pdf.\n\nIf OCRmyPDF is given an image file as input, it will attempt to convert the\nimage to a PDF before processing.  For more control over the conversion of\nimages to PDF, use the Python package img2pdf or other image to PDF software.\n\nFor example, this command uses img2pdf to convert all .png files beginning\nwith the 'page' prefix to a PDF, fitting each image on A4-sized paper, and\nsending the result to OCRmyPDF through a pipe.\n\n    img2pdf --pagesize A4 page*.png | ocrmypdf - myfile.pdf\n\nOnline documentation is located at:\n    https://ocrmypdf.readthedocs.io/en/latest/introduction.html\n\n\"\"\",\n    )\n\n    parser.add_argument(\n        'input_file',\n        metavar=\"input_pdf_or_image\",\n        help=\"PDF file containing the images to be OCRed (or '-' to read from \"\n        \"standard input)\",\n    )\n    parser.add_argument(\n        'output_file',\n        metavar=\"output_pdf\",\n        help=\"Output searchable PDF file (or '-' to write to standard output). \"\n        \"Existing files will be overwritten. If same as input file, the \"\n        \"input file will be updated only if processing is successful.\",\n    )\n    parser.add_argument(\n        '-l',\n        '--language',\n        dest='languages',\n        action=LanguageSetAction,\n        help=\"Language(s) of the file to be OCRed (see tesseract --list-langs for \"\n        \"all language packs installed in your system). Use -l eng+deu for \"\n        \"multiple languages.\",\n    )\n    parser.add_argument(\n        '--image-dpi',\n        metavar='DPI',\n        type=int,\n        help=\"When the input file is an image, not a PDF, use this DPI instead \"\n        \"of the DPI claimed by the input file. If the input does not claim a \"\n        \"sensible DPI, this option will be required.\",\n    )\n    parser.add_argument(\n        '--output-type',\n        choices=['pdfa', 'pdf', 'pdfa-1', 'pdfa-2', 'pdfa-3', 'none'],\n        default='pdfa',\n        help=\"Choose output type. 'pdfa' creates a PDF/A-2b compliant file for \"\n        \"long term archiving (default, recommended) but may not suitable \"\n        \"for users who want their file altered as little as possible. 'pdfa' \"\n        \"also has problems with full Unicode text. 'pdf' minimizes changes \"\n        \"to the input file. 'pdf-a1' creates a \"\n        \"PDF/A1-b file. 'pdf-a2' is equivalent to 'pdfa'. 'pdf-a3' creates a \"\n        \"PDF/A3-b file. 'none' will produce no output, which may be helpful if \"\n        \"only the --sidecar is desired.\",\n    )\n\n                                                                                 \n                                                                             \n                                  \n    parser.add_argument(\n        '--sidecar',\n        nargs='?',\n        const='\\0',\n        default=None,\n        metavar='FILE',\n        help=\"Generate sidecar text files that contain the same text recognized \"\n        \"by Tesseract. This may be useful for building a OCR text database. \"\n        \"If FILE is omitted, the sidecar file be named {output_file}.txt; the next \"\n        \"argument must NOT be the name of the input PDF. \"\n        \"If FILE is set to '-', the sidecar is written to stdout (a \"\n        \"convenient way to preview OCR quality). The output file and sidecar \"\n        \"may not both use stdout at the same time.\",\n    )\n\n    parser.add_argument(\n        '--version',\n        action='version',\n        version=_VERSION,\n        help=\"Print program version and exit\",\n    )\n\n    jobcontrol = parser.add_argument_group(\"Job control options\")\n    jobcontrol.add_argument(\n        '-j',\n        '--jobs',\n        metavar='N',\n        type=numeric(int, 0, 256),\n        help=\"Use up to N CPU cores simultaneously (default: use all).\",\n    )\n    jobcontrol.add_argument(\n        '-q', '--quiet', action='store_true', help=\"Suppress INFO messages\"\n    )\n    jobcontrol.add_argument(\n        '-v',\n        '--verbose',\n        type=numeric(int, 0, 2),\n        default=0,\n        const=1,\n        nargs='?',\n        help=\"Print more verbose messages for each additional verbose level. Use \"\n        \"`-v 1` typically for much more detailed logging. Higher numbers \"\n        \"are probably only useful in debugging.\",\n    )\n    jobcontrol.add_argument(\n        '--no-progress-bar',\n        action='store_false',\n        dest='progress_bar',\n        help=argparse.SUPPRESS,\n    )\n    jobcontrol.add_argument(\n        '--use-threads', action='store_true', default=True, help=argparse.SUPPRESS\n    )\n    jobcontrol.add_argument(\n        '--no-use-threads',\n        action='store_false',\n        dest='use_threads',\n        help=argparse.SUPPRESS,\n    )\n\n    metadata = parser.add_argument_group(\n        \"Metadata options\",\n        \"Set output PDF/A metadata (default: copy input document's metadata)\",\n    )\n    metadata.add_argument(\n        '--title', type=str, help=\"Set document title (place multiple words in quotes)\"\n    )\n    metadata.add_argument('--author', type=str, help=\"Set document author\")\n    metadata.add_argument(\n        '--subject', type=str, help=\"Set document subject description\"\n    )\n    metadata.add_argument('--keywords', type=str, help=\"Set document keywords\")\n\n    preprocessing = parser.add_argument_group(\n        \"Image preprocessing options\",\n        \"Options to improve the quality of the final PDF and OCR\",\n    )\n    preprocessing.add_argument(\n        '-r',\n        '--rotate-pages',\n        action='store_true',\n        help=\"Automatically rotate pages based on detected text orientation\",\n    )\n    preprocessing.add_argument(\n        '--remove-background',\n        action='store_true',\n        help=\"Attempt to remove background from gray or color pages, setting it \"\n        \"to white \",\n    )\n    preprocessing.add_argument(\n        '-d',\n        '--deskew',\n        action='store_true',\n        help=\"Deskew each page before performing OCR\",\n    )\n    preprocessing.add_argument(\n        '-c',\n        '--clean',\n        action='store_true',\n        help=\"Clean pages from scanning artifacts before performing OCR, and send \"\n        \"the cleaned page to OCR, but do not include the cleaned page in \"\n        \"the output\",\n    )\n    preprocessing.add_argument(\n        '-i',\n        '--clean-final',\n        action='store_true',\n        help=\"Clean page as above, and incorporate the cleaned image in the final \"\n        \"PDF.  Might remove desired content.\",\n    )\n    preprocessing.add_argument(\n        '--unpaper-args',\n        type=str,\n        default=None,\n        help=\"A quoted string of arguments to pass to unpaper. Requires --clean. \"\n        \"Example: --unpaper-args '--layout double'.\",\n    )\n    preprocessing.add_argument(\n        '--oversample',\n        metavar='DPI',\n        type=numeric(int, 0, 5000),\n        default=0,\n        help=\"Oversample images to at least the specified DPI, to improve OCR \"\n        \"results slightly\",\n    )\n    preprocessing.add_argument(\n        '--remove-vectors',\n        action='store_true',\n        help=\"EXPERIMENTAL. Mask out any vector objects in the PDF so that they \"\n        \"will not be included in OCR. This can eliminate false characters.\",\n    )\n\n    ocrsettings = parser.add_argument_group(\"OCR options\", \"Control how OCR is applied\")\n    ocrsettings.add_argument(\n        '-f',\n        '--force-ocr',\n        action='store_true',\n        help=\"Rasterize any text or vector objects on each page, apply OCR, and \"\n        \"save the rastered output (this rewrites the PDF)\",\n    )\n    ocrsettings.add_argument(\n        '-s',\n        '--skip-text',\n        action='store_true',\n        help=\"Skip OCR on any pages that already contain text, but include the \"\n        \"page in final output; useful for PDFs that contain a mix of \"\n        \"images, text pages, and/or previously OCRed pages\",\n    )\n    ocrsettings.add_argument(\n        '--redo-ocr',\n        action='store_true',\n        help=\"Attempt to detect and remove the hidden OCR layer from files that \"\n        \"were previously OCRed with OCRmyPDF or another program. Apply OCR \"\n        \"to text found in raster images. Existing visible text objects will \"\n        \"not be changed. If there is no existing OCR, OCR will be added.\",\n    )\n    ocrsettings.add_argument(\n        '--skip-big',\n        type=numeric(float, 0, 5000),\n        metavar='MPixels',\n        help=\"Skip OCR on pages larger than the specified amount of megapixels, \"\n        \"but include skipped pages in final output\",\n    )\n    ocrsettings.add_argument(\n        '--invalidate-digital-signatures',\n        action='store_true',\n        help=\"Normally, OCRmyPDF will refuse to OCR a PDF that has a digital \"\n        \"signature. This option allows OCR to proceed, but the digital signature \"\n        \"will be invalidated.\",\n    )\n\n    advanced = parser.add_argument_group(\n        \"Advanced\", \"Advanced options to control OCRmyPDF\"\n    )\n    advanced.add_argument(\n        '--pages',\n        type=str,\n        help=(\n            \"Limit OCR to the specified pages (ranges or comma separated), \"\n            \"skipping others\"\n        ),\n    )\n    advanced.add_argument(\n        '--max-image-mpixels',\n        action='store',\n        type=numeric(float, 0),\n        metavar='MPixels',\n        help=\"Set maximum number of megapixels to unpack before treating an image as a \"\n        \"decompression bomb\",\n        default=250.0,\n    )\n    advanced.add_argument(\n        '--pdf-renderer',\n        choices=['auto', 'hocr', 'sandwich', 'hocrdebug'],\n        default='auto',\n        help=\"Choose OCR PDF renderer - the default option is to let OCRmyPDF \"\n        \"choose.  See documentation for discussion.\",\n    )\n    advanced.add_argument(\n        '--rotate-pages-threshold',\n        default=DEFAULT_ROTATE_PAGES_THRESHOLD,\n        type=numeric(float, 0, 1000),\n        metavar='CONFIDENCE',\n        help=\"Only rotate pages when confidence is above this value (arbitrary \"\n        \"units reported by tesseract)\",\n    )\n    advanced.add_argument(\n        '--fast-web-view',\n        type=numeric(float, 0),\n        default=1.0,\n        metavar=\"MEGABYTES\",\n        help=\"If the size of file is more than this threshold (in MB), then \"\n        \"linearize the PDF for fast web viewing. This allows the PDF to be \"\n        \"displayed before it is fully downloaded in web browsers, but increases \"\n        \"the space required slightly. By default we skip this for small files \"\n        \"which do not benefit. If the threshold is 0 it will be apply to all files. \"\n        \"Set the threshold very high to disable.\",\n    )\n    advanced.add_argument(\n        '--continue-on-soft-render-error',\n        action='store_true',\n        help=\"Continue processing pages after a recoverable PDF rendering error. \"\n        \"A recoverable error is one that does not prevent the page from being \"\n        \"rendered, but may result in visual differences compared to the input \"\n        \"file. Missing fonts are a typical source of these errors.\",\n    )\n    advanced.add_argument(\n        '--plugin',\n        dest='plugins',\n        action='append',\n        default=[],\n        help=\"Name of plugin to import. Argument may be issued multiple times to \"\n        \"import multiple plugins. Plugins may be specified as module names in \"\n        \"Python syntax, provided they are installed in the same Python (virtual) \"\n        \"environment as ocrmypdf; or you may give the path to the Python file that \"\n        \"contains the plugin. Plugins must conform to the specification in the \"\n        \"OCRmyPDF documentation.\",\n    )\n\n    debugging = parser.add_argument_group(\n        \"Debugging\", \"Arguments to help with troubleshooting and debugging\"\n    )\n    debugging.add_argument(\n        '-k',\n        '--keep-temporary-files',\n        action='store_true',\n        help=\"Keep temporary files (helpful for debugging)\",\n    )\n    return parser", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "_numeric", "whole_func_string": "def _numeric(s: str) -> T:\n        value = basetype(s)\n        if (min_ is not None and value < min_) or (max_ is not None and value > max_):\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} not in valid range {(min_, max_)!r}\"\n            )\n        return value", "func_code_string": "def _numeric(s: str) -> T:\n        value = basetype(s)\n        if (min_ is not None and value < min_) or (max_ is not None and value > max_):\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} not in valid range {(min_, max_)!r}\"\n            )\n        return value", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "_str_to_int", "whole_func_string": "def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None", "func_code_string": "def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "__init__", "whole_func_string": "def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False", "func_code_string": "def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "enable_api_mode", "whole_func_string": "def enable_api_mode(self):\n                   \n        self._api_mode = True", "func_code_string": "def enable_api_mode(self):\n                   \n        self._api_mode = True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "error", "whole_func_string": "def error(self, message):\n                                                           \n        if not self._api_mode:\n            super().error(message)\n            return\n        raise ValueError(message)", "func_code_string": "def error(self, message):\n                                                           \n        if not self._api_mode:\n            super().error(message)\n            return\n        raise ValueError(message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "__init__", "whole_func_string": "def __init__(self, option_strings, dest, default=None, **kwargs):\n                                    \n        if default is None:\n            default = list()\n        super().__init__(option_strings, dest, default=default, **kwargs)", "func_code_string": "def __init__(self, option_strings, dest, default=None, **kwargs):\n                                    \n        if default is None:\n            default = list()\n        super().__init__(option_strings, dest, default=default, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "__call__", "whole_func_string": "def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_code_string": "def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "triage_image_file", "whole_func_string": "def triage_image_file(input_file: Path, output_file: Path, options) -> None:\n           \n    log.info(\"Input file is not a PDF, checking if it is an image...\")\n    try:\n        im = Image.open(input_file)\n    except OSError as e:\n                                       \n        log.error(str(e).replace(str(input_file), str(options.input_file)))\n        if not input_file.exists():\n            log.error(\"Input file does not exist: %s\", input_file)\n        if input_file.is_dir():\n            log.error(\"Input file is a directory: %s\", input_file)\n        if input_file.is_file():\n            log.error(\"Input file is a file: %s\", input_file)\n        if input_file.stat().st_size == 0:\n            log.error(\"Input file is empty: %s\", input_file)\n        raise UnsupportedImageFormatError() from e\n\n    with im:\n        log.info(\"Input file is an image\")\n        if 'dpi' in im.info:\n            if im.info['dpi'] <= (96, 96) and not options.image_dpi:\n                log.info(\"Image size: (%d, %d)\", *im.size)\n                log.info(\"Image resolution: (%d, %d)\", *im.info['dpi'])\n                raise DpiError(\n                    \"Input file is an image, but the resolution (DPI) is \"\n                    \"not credible.  Estimate the resolution at which the \"\n                    \"image was scanned and specify it using --image-dpi.\"\n                )\n        elif not options.image_dpi:\n            log.info(\"Image size: (%d, %d)\", *im.size)\n            raise DpiError(\n                \"Input file is an image, but has no resolution (DPI) \"\n                \"in its metadata.  Estimate the resolution at which \"\n                \"image was scanned and specify it using --image-dpi.\"\n            )\n\n        if im.mode in ('RGBA', 'LA'):\n            raise UnsupportedImageFormatError(\n                \"The input image has an alpha channel. Remove the alpha \"\n                \"channel first.\"\n            )\n\n        if 'iccprofile' not in im.info:\n            if im.mode == 'RGB':\n                log.info(\"Input image has no ICC profile, assuming sRGB\")\n            elif im.mode == 'CMYK':\n                raise UnsupportedImageFormatError(\n                    \"Input CMYK image has no ICC profile, not usable\"\n                )\n\n    try:\n        log.info(\"Image seems valid. Try converting to PDF...\")\n        layout_fun = img2pdf.default_layout_fun\n        if options.image_dpi:\n            layout_fun = img2pdf.get_fixed_dpi_layout_fun(\n                Resolution(options.image_dpi, options.image_dpi)\n            )\n        with open(output_file, 'wb') as outf:\n            img2pdf.convert(\n                os.fspath(input_file),\n                layout_fun=layout_fun,\n                outputstream=outf,\n                **IMG2PDF_KWARGS,\n            )\n        log.info(\"Successfully converted to PDF, processing...\")\n    except img2pdf.ImageOpenError as e:\n        raise UnsupportedImageFormatError() from e", "func_code_string": "def triage_image_file(input_file: Path, output_file: Path, options) -> None:\n           \n    log.info(\"Input file is not a PDF, checking if it is an image...\")\n    try:\n        im = Image.open(input_file)\n    except OSError as e:\n                                       \n        log.error(str(e).replace(str(input_file), str(options.input_file)))\n        if not input_file.exists():\n            log.error(\"Input file does not exist: %s\", input_file)\n        if input_file.is_dir():\n            log.error(\"Input file is a directory: %s\", input_file)\n        if input_file.is_file():\n            log.error(\"Input file is a file: %s\", input_file)\n        if input_file.stat().st_size == 0:\n            log.error(\"Input file is empty: %s\", input_file)\n        raise UnsupportedImageFormatError() from e\n\n    with im:\n        log.info(\"Input file is an image\")\n        if 'dpi' in im.info:\n            if im.info['dpi'] <= (96, 96) and not options.image_dpi:\n                log.info(\"Image size: (%d, %d)\", *im.size)\n                log.info(\"Image resolution: (%d, %d)\", *im.info['dpi'])\n                raise DpiError(\n                    \"Input file is an image, but the resolution (DPI) is \"\n                    \"not credible.  Estimate the resolution at which the \"\n                    \"image was scanned and specify it using --image-dpi.\"\n                )\n        elif not options.image_dpi:\n            log.info(\"Image size: (%d, %d)\", *im.size)\n            raise DpiError(\n                \"Input file is an image, but has no resolution (DPI) \"\n                \"in its metadata.  Estimate the resolution at which \"\n                \"image was scanned and specify it using --image-dpi.\"\n            )\n\n        if im.mode in ('RGBA', 'LA'):\n            raise UnsupportedImageFormatError(\n                \"The input image has an alpha channel. Remove the alpha \"\n                \"channel first.\"\n            )\n\n        if 'iccprofile' not in im.info:\n            if im.mode == 'RGB':\n                log.info(\"Input image has no ICC profile, assuming sRGB\")\n            elif im.mode == 'CMYK':\n                raise UnsupportedImageFormatError(\n                    \"Input CMYK image has no ICC profile, not usable\"\n                )\n\n    try:\n        log.info(\"Image seems valid. Try converting to PDF...\")\n        layout_fun = img2pdf.default_layout_fun\n        if options.image_dpi:\n            layout_fun = img2pdf.get_fixed_dpi_layout_fun(\n                Resolution(options.image_dpi, options.image_dpi)\n            )\n        with open(output_file, 'wb') as outf:\n            img2pdf.convert(\n                os.fspath(input_file),\n                layout_fun=layout_fun,\n                outputstream=outf,\n                **IMG2PDF_KWARGS,\n            )\n        log.info(\"Successfully converted to PDF, processing...\")\n    except img2pdf.ImageOpenError as e:\n        raise UnsupportedImageFormatError() from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "_pdf_guess_version", "whole_func_string": "def _pdf_guess_version(input_file: Path, search_window=1024) -> str:\n           \n    with open(input_file, 'rb') as f:\n        signature = f.read(search_window)\n    m = re.search(rb'%PDF-(\\d\\.\\d)', signature)\n    if m:\n        return m.group(1).decode('ascii')\n    return ''", "func_code_string": "def _pdf_guess_version(input_file: Path, search_window=1024) -> str:\n           \n    with open(input_file, 'rb') as f:\n        signature = f.read(search_window)\n    m = re.search(rb'%PDF-(\\d\\.\\d)', signature)\n    if m:\n        return m.group(1).decode('ascii')\n    return ''", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "triage", "whole_func_string": "def triage(\n    original_filename: str, input_file: Path, output_file: Path, options\n) -> Path:\n                                                               \n    try:\n        if _pdf_guess_version(input_file):\n            if options.image_dpi:\n                log.warning(\n                    \"Argument --image-dpi is being ignored because the \"\n                    \"input file is a PDF, not an image.\"\n                )\n            try:\n                with pikepdf.open(input_file) as pdf:\n                    pdf.save(output_file)\n            except pikepdf.PdfError as e:\n                raise InputFileError() from e\n            except pikepdf.PasswordError as e:\n                raise EncryptedPdfError() from e\n            return output_file\n    except OSError as e:\n        log.debug(f\"Temporary file was at: {input_file}\")\n        msg = str(e).replace(str(input_file), original_filename)\n        raise InputFileError(msg) from e\n\n    triage_image_file(input_file, output_file, options)\n    return output_file", "func_code_string": "def triage(\n    original_filename: str, input_file: Path, output_file: Path, options\n) -> Path:\n                                                               \n    try:\n        if _pdf_guess_version(input_file):\n            if options.image_dpi:\n                log.warning(\n                    \"Argument --image-dpi is being ignored because the \"\n                    \"input file is a PDF, not an image.\"\n                )\n            try:\n                with pikepdf.open(input_file) as pdf:\n                    pdf.save(output_file)\n            except pikepdf.PdfError as e:\n                raise InputFileError() from e\n            except pikepdf.PasswordError as e:\n                raise EncryptedPdfError() from e\n            return output_file\n    except OSError as e:\n        log.debug(f\"Temporary file was at: {input_file}\")\n        msg = str(e).replace(str(input_file), original_filename)\n        raise InputFileError(msg) from e\n\n    triage_image_file(input_file, output_file, options)\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_pdfinfo", "whole_func_string": "def get_pdfinfo(\n    input_file,\n    *,\n    executor: Executor,\n    detailed_analysis: bool = False,\n    progbar: bool = False,\n    max_workers: int | None = None,\n    use_threads: bool = True,\n    check_pages=None,\n) -> PdfInfo:\n                           \n    try:\n        return PdfInfo(\n            input_file,\n            detailed_analysis=detailed_analysis,\n            progbar=progbar,\n            max_workers=max_workers,\n            use_threads=use_threads,\n            check_pages=check_pages,\n            executor=executor,\n        )\n    except pikepdf.PasswordError as e:\n        raise EncryptedPdfError() from e\n    except pikepdf.PdfError as e:\n        raise InputFileError() from e", "func_code_string": "def get_pdfinfo(\n    input_file,\n    *,\n    executor: Executor,\n    detailed_analysis: bool = False,\n    progbar: bool = False,\n    max_workers: int | None = None,\n    use_threads: bool = True,\n    check_pages=None,\n) -> PdfInfo:\n                           \n    try:\n        return PdfInfo(\n            input_file,\n            detailed_analysis=detailed_analysis,\n            progbar=progbar,\n            max_workers=max_workers,\n            use_threads=use_threads,\n            check_pages=check_pages,\n            executor=executor,\n        )\n    except pikepdf.PasswordError as e:\n        raise EncryptedPdfError() from e\n    except pikepdf.PdfError as e:\n        raise InputFileError() from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "validate_pdfinfo_options", "whole_func_string": "def validate_pdfinfo_options(context: PdfContext) -> None:\n                                        \n    pdfinfo = context.pdfinfo\n    options = context.options\n\n    if pdfinfo.needs_rendering:\n        raise InputFileError(\n            \"This PDF contains dynamic XFA forms created by Adobe LiveCycle \"\n            \"Designer and can only be read by Adobe Acrobat or Adobe Reader.\"\n        )\n    if pdfinfo.has_signature:\n        if options.invalidate_digital_signatures:\n            log.warning(\"All digital signatures will be invalidated\")\n        else:\n            raise DigitalSignatureError()\n    if pdfinfo.has_acroform:\n        if options.redo_ocr:\n            raise InputFileError(\n                \"This PDF has a user fillable form. --redo-ocr is not \"\n                \"currently possible on such files.\"\n            )\n        else:\n            log.warning(\n                \"This PDF has a fillable form. \"\n                \"Chances are it is a pure digital \"\n                \"document that does not need OCR.\"\n            )\n            if not options.force_ocr:\n                log.info(\n                    \"Use the option --force-ocr to produce an image of the \"\n                    \"form and all filled form fields. The output PDF will be \"\n                    \"'flattened' and will no longer be fillable.\"\n                )\n    if pdfinfo.is_tagged:\n        if options.force_ocr or options.skip_text or options.redo_ocr:\n            log.warning(\n                \"This PDF is marked as a Tagged PDF. This often indicates \"\n                \"that the PDF was generated from an office document and does \"\n                \"not need OCR. PDF pages processed by OCRmyPDF may not be \"\n                \"tagged correctly.\"\n            )\n        else:\n            raise TaggedPDFError()\n    context.plugin_manager.hook.validate(pdfinfo=pdfinfo, options=options)", "func_code_string": "def validate_pdfinfo_options(context: PdfContext) -> None:\n                                        \n    pdfinfo = context.pdfinfo\n    options = context.options\n\n    if pdfinfo.needs_rendering:\n        raise InputFileError(\n            \"This PDF contains dynamic XFA forms created by Adobe LiveCycle \"\n            \"Designer and can only be read by Adobe Acrobat or Adobe Reader.\"\n        )\n    if pdfinfo.has_signature:\n        if options.invalidate_digital_signatures:\n            log.warning(\"All digital signatures will be invalidated\")\n        else:\n            raise DigitalSignatureError()\n    if pdfinfo.has_acroform:\n        if options.redo_ocr:\n            raise InputFileError(\n                \"This PDF has a user fillable form. --redo-ocr is not \"\n                \"currently possible on such files.\"\n            )\n        else:\n            log.warning(\n                \"This PDF has a fillable form. \"\n                \"Chances are it is a pure digital \"\n                \"document that does not need OCR.\"\n            )\n            if not options.force_ocr:\n                log.info(\n                    \"Use the option --force-ocr to produce an image of the \"\n                    \"form and all filled form fields. The output PDF will be \"\n                    \"'flattened' and will no longer be fillable.\"\n                )\n    if pdfinfo.is_tagged:\n        if options.force_ocr or options.skip_text or options.redo_ocr:\n            log.warning(\n                \"This PDF is marked as a Tagged PDF. This often indicates \"\n                \"that the PDF was generated from an office document and does \"\n                \"not need OCR. PDF pages processed by OCRmyPDF may not be \"\n                \"tagged correctly.\"\n            )\n        else:\n            raise TaggedPDFError()\n    context.plugin_manager.hook.validate(pdfinfo=pdfinfo, options=options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "_vector_page_dpi", "whole_func_string": "def _vector_page_dpi(pageinfo: PageInfo) -> int:\n                                                                            \n    return VECTOR_PAGE_DPI if pageinfo.has_vector or pageinfo.has_text else 0", "func_code_string": "def _vector_page_dpi(pageinfo: PageInfo) -> int:\n                                                                            \n    return VECTOR_PAGE_DPI if pageinfo.has_vector or pageinfo.has_text else 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_page_square_dpi", "whole_func_string": "def get_page_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    xres = image_dpi.x or 0.0\n    yres = image_dpi.y or 0.0\n    userunit = float(pageinfo.userunit) or 1.0\n    units = float(\n        max(\n            (xres * userunit) or VECTOR_PAGE_DPI,\n            (yres * userunit) or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_code_string": "def get_page_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    xres = image_dpi.x or 0.0\n    yres = image_dpi.y or 0.0\n    userunit = float(pageinfo.userunit) or 1.0\n    units = float(\n        max(\n            (xres * userunit) or VECTOR_PAGE_DPI,\n            (yres * userunit) or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_canvas_square_dpi", "whole_func_string": "def get_canvas_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    units = float(\n        max(\n            image_dpi.x or VECTOR_PAGE_DPI,\n            image_dpi.y or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_code_string": "def get_canvas_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    units = float(\n        max(\n            image_dpi.x or VECTOR_PAGE_DPI,\n            image_dpi.y or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "is_ocr_required", "whole_func_string": "def is_ocr_required(page_context: PageContext) -> bool:\n                                              \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n\n    ocr_required = True\n\n    if options.pages and pageinfo.pageno not in options.pages:\n        log.debug(f\"skipped {pageinfo.pageno} as requested by --pages {options.pages}\")\n        ocr_required = False\n    elif pageinfo.has_text:\n        if not options.force_ocr and not (options.skip_text or options.redo_ocr):\n            raise PriorOcrFoundError(\n                \"page already has text! - aborting (use --force-ocr to force OCR; \"\n                \" see also help for the arguments --skip-text and --redo-ocr\"\n            )\n        elif options.force_ocr:\n            log.info(\"page already has text! - rasterizing text and running OCR anyway\")\n            ocr_required = True\n        elif options.redo_ocr:\n            if pageinfo.has_corrupt_text:\n                log.warning(\n                    \"some text on this page cannot be mapped to characters: \"\n                    \"consider using --force-ocr instead\"\n                )\n            else:\n                log.info(\"redoing OCR\")\n            ocr_required = True\n        elif options.skip_text:\n            log.info(\"skipping all processing on this page\")\n            ocr_required = False\n    elif not pageinfo.images and not options.lossless_reconstruction:\n                                                                       \n                                                                      \n                                                                           \n                                                                         \n                                                                          \n                                                       \n                                                                            \n        if options.force_ocr and options.oversample:\n                                                          \n            log.info(\n                \"page has no images - \"\n                f\"rasterizing at {options.oversample} DPI because \"\n                \"--force-ocr --oversample was specified\"\n            )\n        elif options.force_ocr:\n                                                          \n            log.warning(\n                \"page has no images - \"\n                \"all vector content will be \"\n                f\"rasterized at {VECTOR_PAGE_DPI} DPI, losing some resolution and \"\n                \"likely increasing file size. Use --oversample to adjust the \"\n                \"DPI.\"\n            )\n        else:\n            log.info(\n                \"page has no images - \"\n                \"skipping all processing on this page to avoid losing detail. \"\n                \"Use --force-ocr if you wish to perform OCR on pages that \"\n                \"have vector content.\"\n            )\n            ocr_required = False\n\n    if ocr_required and options.skip_big and pageinfo.images:\n        pixel_count = pageinfo.width_pixels * pageinfo.height_pixels\n        if pixel_count > (options.skip_big * 1_000_000):\n            ocr_required = False\n            log.warning(\n                \"page too big, skipping OCR \"\n                f\"({(pixel_count / 1_000_000):.1f} MPixels > \"\n                f\"{options.skip_big:.1f} MPixels --skip-big)\"\n            )\n    return ocr_required", "func_code_string": "def is_ocr_required(page_context: PageContext) -> bool:\n                                              \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n\n    ocr_required = True\n\n    if options.pages and pageinfo.pageno not in options.pages:\n        log.debug(f\"skipped {pageinfo.pageno} as requested by --pages {options.pages}\")\n        ocr_required = False\n    elif pageinfo.has_text:\n        if not options.force_ocr and not (options.skip_text or options.redo_ocr):\n            raise PriorOcrFoundError(\n                \"page already has text! - aborting (use --force-ocr to force OCR; \"\n                \" see also help for the arguments --skip-text and --redo-ocr\"\n            )\n        elif options.force_ocr:\n            log.info(\"page already has text! - rasterizing text and running OCR anyway\")\n            ocr_required = True\n        elif options.redo_ocr:\n            if pageinfo.has_corrupt_text:\n                log.warning(\n                    \"some text on this page cannot be mapped to characters: \"\n                    \"consider using --force-ocr instead\"\n                )\n            else:\n                log.info(\"redoing OCR\")\n            ocr_required = True\n        elif options.skip_text:\n            log.info(\"skipping all processing on this page\")\n            ocr_required = False\n    elif not pageinfo.images and not options.lossless_reconstruction:\n                                                                       \n                                                                      \n                                                                           \n                                                                         \n                                                                          \n                                                       \n                                                                            \n        if options.force_ocr and options.oversample:\n                                                          \n            log.info(\n                \"page has no images - \"\n                f\"rasterizing at {options.oversample} DPI because \"\n                \"--force-ocr --oversample was specified\"\n            )\n        elif options.force_ocr:\n                                                          \n            log.warning(\n                \"page has no images - \"\n                \"all vector content will be \"\n                f\"rasterized at {VECTOR_PAGE_DPI} DPI, losing some resolution and \"\n                \"likely increasing file size. Use --oversample to adjust the \"\n                \"DPI.\"\n            )\n        else:\n            log.info(\n                \"page has no images - \"\n                \"skipping all processing on this page to avoid losing detail. \"\n                \"Use --force-ocr if you wish to perform OCR on pages that \"\n                \"have vector content.\"\n            )\n            ocr_required = False\n\n    if ocr_required and options.skip_big and pageinfo.images:\n        pixel_count = pageinfo.width_pixels * pageinfo.height_pixels\n        if pixel_count > (options.skip_big * 1_000_000):\n            ocr_required = False\n            log.warning(\n                \"page too big, skipping OCR \"\n                f\"({(pixel_count / 1_000_000):.1f} MPixels > \"\n                f\"{options.skip_big:.1f} MPixels --skip-big)\"\n            )\n    return ocr_required", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "rasterize_preview", "whole_func_string": "def rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\n                                                 \n    output_file = page_context.get_path('rasterize_preview.jpg')\n    canvas_dpi = Resolution(300.0, 300.0).take_min(\n        [get_canvas_square_dpi(page_context)]\n    )\n    page_dpi = Resolution(300.0, 300.0).take_min([get_page_square_dpi(page_context)])\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device='jpeggray',\n        raster_dpi=canvas_dpi,\n        pageno=page_context.pageinfo.pageno + 1,\n        page_dpi=page_dpi,\n        rotation=0,\n        filter_vector=False,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_code_string": "def rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\n                                                 \n    output_file = page_context.get_path('rasterize_preview.jpg')\n    canvas_dpi = Resolution(300.0, 300.0).take_min(\n        [get_canvas_square_dpi(page_context)]\n    )\n    page_dpi = Resolution(300.0, 300.0).take_min([get_page_square_dpi(page_context)])\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device='jpeggray',\n        raster_dpi=canvas_dpi,\n        pageno=page_context.pageinfo.pageno + 1,\n        page_dpi=page_dpi,\n        rotation=0,\n        filter_vector=False,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "describe_rotation", "whole_func_string": "def describe_rotation(\n    page_context: PageContext, orient_conf: OrientationConfidence, correction: int\n) -> str:\n                                                                              \n    direction = {0: '\u21e7', 90: '\u21e8', 180: '\u21e9', 270: '\u21e6'}\n    turns = {0: ' ', 90: '\u2b0f', 180: '\u21bb', 270: '\u2b11'}\n\n    existing_rotation = page_context.pageinfo.rotation\n    action = ''\n    if orient_conf.confidence >= page_context.options.rotate_pages_threshold:\n        if correction != 0:\n            action = 'will rotate ' + turns[correction]\n        else:\n            action = 'rotation appears correct'\n    else:\n        if correction != 0:\n            action = 'confidence too low to rotate'\n        else:\n            action = 'no change'\n\n    facing = ''\n\n    if existing_rotation != 0:\n        facing = f\"with existing rotation {direction.get(existing_rotation, '?')}, \"\n    facing += f\"page is facing {direction.get(orient_conf.angle, '?')}\"\n\n    return f\"{facing}, confidence {orient_conf.confidence:.2f} - {action}\"", "func_code_string": "def describe_rotation(\n    page_context: PageContext, orient_conf: OrientationConfidence, correction: int\n) -> str:\n                                                                              \n    direction = {0: '\u21e7', 90: '\u21e8', 180: '\u21e9', 270: '\u21e6'}\n    turns = {0: ' ', 90: '\u2b0f', 180: '\u21bb', 270: '\u2b11'}\n\n    existing_rotation = page_context.pageinfo.rotation\n    action = ''\n    if orient_conf.confidence >= page_context.options.rotate_pages_threshold:\n        if correction != 0:\n            action = 'will rotate ' + turns[correction]\n        else:\n            action = 'rotation appears correct'\n    else:\n        if correction != 0:\n            action = 'confidence too low to rotate'\n        else:\n            action = 'no change'\n\n    facing = ''\n\n    if existing_rotation != 0:\n        facing = f\"with existing rotation {direction.get(existing_rotation, '?')}, \"\n    facing += f\"page is facing {direction.get(orient_conf.angle, '?')}\"\n\n    return f\"{facing}, confidence {orient_conf.confidence:.2f} - {action}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_orientation_correction", "whole_func_string": "def get_orientation_correction(preview: Path, page_context: PageContext) -> int:\n           \n    orient_conf = page_context.plugin_manager.hook.get_ocr_engine().get_orientation(\n        preview, page_context.options\n    )\n\n    correction = orient_conf.angle % 360\n    log.info(describe_rotation(page_context, orient_conf, correction))\n    if (\n        orient_conf.confidence >= page_context.options.rotate_pages_threshold\n        and correction != 0\n    ):\n        return correction\n\n    return 0", "func_code_string": "def get_orientation_correction(preview: Path, page_context: PageContext) -> int:\n           \n    orient_conf = page_context.plugin_manager.hook.get_ocr_engine().get_orientation(\n        preview, page_context.options\n    )\n\n    correction = orient_conf.angle % 360\n    log.info(describe_rotation(page_context, orient_conf, correction))\n    if (\n        orient_conf.confidence >= page_context.options.rotate_pages_threshold\n        and correction != 0\n    ):\n        return correction\n\n    return 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "calculate_image_dpi", "whole_func_string": "def calculate_image_dpi(page_context: PageContext) -> Resolution:\n                                               \n    pageinfo = page_context.pageinfo\n    dpi_profile = pageinfo.page_dpi_profile()\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        image_dpi = Resolution(dpi_profile.weighted_dpi, dpi_profile.weighted_dpi)\n    else:\n        image_dpi = pageinfo.dpi\n    return image_dpi", "func_code_string": "def calculate_image_dpi(page_context: PageContext) -> Resolution:\n                                               \n    pageinfo = page_context.pageinfo\n    dpi_profile = pageinfo.page_dpi_profile()\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        image_dpi = Resolution(dpi_profile.weighted_dpi, dpi_profile.weighted_dpi)\n    else:\n        image_dpi = pageinfo.dpi\n    return image_dpi", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "calculate_raster_dpi", "whole_func_string": "def calculate_raster_dpi(page_context: PageContext):\n                                              \n                                                                          \n                             \n    image_dpi = calculate_image_dpi(page_context)\n    dpi_profile = page_context.pageinfo.page_dpi_profile()\n    canvas_dpi = get_canvas_square_dpi(page_context, image_dpi)\n    page_dpi = get_page_square_dpi(page_context, image_dpi)\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        log.warning(\n            \"Weighted average image DPI is %0.1f, max DPI is %0.1f. \"\n            \"The discrepancy may indicate a high detail region on this page, \"\n            \"but could also indicate a problem with the input PDF file. \"\n            \"Page image will be rendered at %0.1f DPI.\",\n            dpi_profile.weighted_dpi,\n            dpi_profile.max_dpi,\n            canvas_dpi.to_scalar(),\n        )\n    return canvas_dpi, page_dpi", "func_code_string": "def calculate_raster_dpi(page_context: PageContext):\n                                              \n                                                                          \n                             \n    image_dpi = calculate_image_dpi(page_context)\n    dpi_profile = page_context.pageinfo.page_dpi_profile()\n    canvas_dpi = get_canvas_square_dpi(page_context, image_dpi)\n    page_dpi = get_page_square_dpi(page_context, image_dpi)\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        log.warning(\n            \"Weighted average image DPI is %0.1f, max DPI is %0.1f. \"\n            \"The discrepancy may indicate a high detail region on this page, \"\n            \"but could also indicate a problem with the input PDF file. \"\n            \"Page image will be rendered at %0.1f DPI.\",\n            dpi_profile.weighted_dpi,\n            dpi_profile.max_dpi,\n            canvas_dpi.to_scalar(),\n        )\n    return canvas_dpi, page_dpi", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "rasterize", "whole_func_string": "def rasterize(\n    input_file: Path,\n    page_context: PageContext,\n    correction: int = 0,\n    output_tag: str = '',\n    remove_vectors: bool | None = None,\n) -> Path:\n           \n    colorspaces = ['pngmono', 'pnggray', 'png256', 'png16m']\n    device_idx = 0\n\n    if remove_vectors is None:\n        remove_vectors = page_context.options.remove_vectors\n\n    output_file = page_context.get_path(f'rasterize{output_tag}.png')\n    pageinfo = page_context.pageinfo\n\n    def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))\n\n    for image in pageinfo.images:\n        if image.type_ != 'image':\n            continue                \n        if image.bpc > 1:\n            if image.color == Colorspace.index:\n                device_idx = at_least('png256')\n            elif image.color == Colorspace.gray:\n                device_idx = at_least('pnggray')\n            else:\n                device_idx = at_least('png16m')\n\n    if pageinfo.has_vector:\n        log.debug(\"Page has vector content, using png16m\")\n        device_idx = at_least('png16m')\n\n    device = colorspaces[device_idx]\n\n    log.debug(f\"Rasterize with {device}, rotation {correction}\")\n\n    canvas_dpi, page_dpi = calculate_raster_dpi(page_context)\n\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device=device,\n        raster_dpi=canvas_dpi,\n        page_dpi=page_dpi,\n        pageno=pageinfo.pageno + 1,\n        rotation=correction,\n        filter_vector=remove_vectors,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_code_string": "def rasterize(\n    input_file: Path,\n    page_context: PageContext,\n    correction: int = 0,\n    output_tag: str = '',\n    remove_vectors: bool | None = None,\n) -> Path:\n           \n    colorspaces = ['pngmono', 'pnggray', 'png256', 'png16m']\n    device_idx = 0\n\n    if remove_vectors is None:\n        remove_vectors = page_context.options.remove_vectors\n\n    output_file = page_context.get_path(f'rasterize{output_tag}.png')\n    pageinfo = page_context.pageinfo\n\n    def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))\n\n    for image in pageinfo.images:\n        if image.type_ != 'image':\n            continue                \n        if image.bpc > 1:\n            if image.color == Colorspace.index:\n                device_idx = at_least('png256')\n            elif image.color == Colorspace.gray:\n                device_idx = at_least('pnggray')\n            else:\n                device_idx = at_least('png16m')\n\n    if pageinfo.has_vector:\n        log.debug(\"Page has vector content, using png16m\")\n        device_idx = at_least('png16m')\n\n    device = colorspaces[device_idx]\n\n    log.debug(f\"Rasterize with {device}, rotation {correction}\")\n\n    canvas_dpi, page_dpi = calculate_raster_dpi(page_context)\n\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device=device,\n        raster_dpi=canvas_dpi,\n        page_dpi=page_dpi,\n        pageno=pageinfo.pageno + 1,\n        rotation=correction,\n        filter_vector=remove_vectors,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "preprocess_remove_background", "whole_func_string": "def preprocess_remove_background(input_file: Path, page_context: PageContext) -> Path:\n                                                                            \n    if any(image.bpc > 1 for image in page_context.pageinfo.images):\n        raise NotImplementedError(\"--remove-background is temporarily not implemented\")\n                                                             \n                                                              \n                            \n    log.info(\"background removal skipped on mono page\")\n    return input_file", "func_code_string": "def preprocess_remove_background(input_file: Path, page_context: PageContext) -> Path:\n                                                                            \n    if any(image.bpc > 1 for image in page_context.pageinfo.images):\n        raise NotImplementedError(\"--remove-background is temporarily not implemented\")\n                                                             \n                                                              \n                            \n    log.info(\"background removal skipped on mono page\")\n    return input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "preprocess_deskew", "whole_func_string": "def preprocess_deskew(input_file: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('pp_deskew.png')\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    deskew_angle_degrees = ocr_engine.get_deskew(input_file, page_context.options)\n\n    with Image.open(input_file) as im:\n                                                                                  \n                                                \n        deskewed = im.rotate(\n            deskew_angle_degrees,\n            resample=Image.Resampling.BICUBIC,\n            fillcolor=ImageColor.getcolor('white', mode=im.mode),                \n        )\n        deskewed.save(output_file, dpi=dpi)\n\n    return output_file", "func_code_string": "def preprocess_deskew(input_file: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('pp_deskew.png')\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    deskew_angle_degrees = ocr_engine.get_deskew(input_file, page_context.options)\n\n    with Image.open(input_file) as im:\n                                                                                  \n                                                \n        deskewed = im.rotate(\n            deskew_angle_degrees,\n            resample=Image.Resampling.BICUBIC,\n            fillcolor=ImageColor.getcolor('white', mode=im.mode),                \n        )\n        deskewed.save(output_file, dpi=dpi)\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "preprocess_clean", "whole_func_string": "def preprocess_clean(input_file: Path, page_context: PageContext) -> Path:\n                                              \n    output_file = page_context.get_path('pp_clean.png')\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n    return unpaper.clean(\n        input_file,\n        output_file,\n        dpi=dpi.to_scalar(),\n        unpaper_args=page_context.options.unpaper_args,\n    )", "func_code_string": "def preprocess_clean(input_file: Path, page_context: PageContext) -> Path:\n                                              \n    output_file = page_context.get_path('pp_clean.png')\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n    return unpaper.clean(\n        input_file,\n        output_file,\n        dpi=dpi.to_scalar(),\n        unpaper_args=page_context.options.unpaper_args,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "create_ocr_image", "whole_func_string": "def create_ocr_image(image: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('ocr.png')\n    options = page_context.options\n    with Image.open(image) as im:\n        log.debug('resolution %r', im.info['dpi'])\n\n        if not options.force_ocr:\n                                                                             \n                            \n            mask = None                                                    \n            if options.redo_ocr:\n                mask = True                                             \n\n            draw = ImageDraw.ImageDraw(im)\n            for textarea in page_context.pageinfo.get_textareas(\n                visible=mask, corrupt=None\n            ):\n                                                                                  \n                                                                                  \n                          \n                bbox = [float(v) for v in textarea]\n                xyscale = tuple(float(coord) / 72.0 for coord in im.info['dpi'])\n                pixcoords = (\n                    bbox[0] * xyscale[0],\n                    im.height - bbox[3] * xyscale[1],\n                    bbox[2] * xyscale[0],\n                    im.height - bbox[1] * xyscale[1],\n                )\n                log.debug('blanking %r', pixcoords)\n                draw.rectangle(pixcoords, fill='white')\n                                                           \n\n        filter_im = page_context.plugin_manager.hook.filter_ocr_image(\n            page=page_context, image=im\n        )\n        if filter_im is not None:\n            im = filter_im\n\n                                     \n        dpi = tuple(round(coord) for coord in im.info['dpi'])\n        im.save(output_file, dpi=dpi)\n    return output_file", "func_code_string": "def create_ocr_image(image: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('ocr.png')\n    options = page_context.options\n    with Image.open(image) as im:\n        log.debug('resolution %r', im.info['dpi'])\n\n        if not options.force_ocr:\n                                                                             \n                            \n            mask = None                                                    \n            if options.redo_ocr:\n                mask = True                                             \n\n            draw = ImageDraw.ImageDraw(im)\n            for textarea in page_context.pageinfo.get_textareas(\n                visible=mask, corrupt=None\n            ):\n                                                                                  \n                                                                                  \n                          \n                bbox = [float(v) for v in textarea]\n                xyscale = tuple(float(coord) / 72.0 for coord in im.info['dpi'])\n                pixcoords = (\n                    bbox[0] * xyscale[0],\n                    im.height - bbox[3] * xyscale[1],\n                    bbox[2] * xyscale[0],\n                    im.height - bbox[1] * xyscale[1],\n                )\n                log.debug('blanking %r', pixcoords)\n                draw.rectangle(pixcoords, fill='white')\n                                                           \n\n        filter_im = page_context.plugin_manager.hook.filter_ocr_image(\n            page=page_context, image=im\n        )\n        if filter_im is not None:\n            im = filter_im\n\n                                     \n        dpi = tuple(round(coord) for coord in im.info['dpi'])\n        im.save(output_file, dpi=dpi)\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "ocr_engine_hocr", "whole_func_string": "def ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\n                                                      \n    hocr_out = page_context.get_path('ocr_hocr.hocr')\n    hocr_text_out = page_context.get_path('ocr_hocr.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_hocr(\n        input_file=input_file,\n        output_hocr=hocr_out,\n        output_text=hocr_text_out,\n        options=options,\n    )\n    return hocr_out, hocr_text_out", "func_code_string": "def ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\n                                                      \n    hocr_out = page_context.get_path('ocr_hocr.hocr')\n    hocr_text_out = page_context.get_path('ocr_hocr.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_hocr(\n        input_file=input_file,\n        output_hocr=hocr_out,\n        output_text=hocr_text_out,\n        options=options,\n    )\n    return hocr_out, hocr_text_out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "should_visible_page_image_use_jpg", "whole_func_string": "def should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\n           \n    return bool(pageinfo.images) and all(\n        im.enc == Encoding.jpeg for im in pageinfo.images\n    )", "func_code_string": "def should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\n           \n    return bool(pageinfo.images) and all(\n        im.enc == Encoding.jpeg for im in pageinfo.images\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "create_visible_page_jpg", "whole_func_string": "def create_visible_page_jpg(image: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('visible.jpg')\n    with Image.open(image) as im:\n                                                                       \n                                                                            \n                                                                  \n                                                                          \n                                                                    \n        if 'dpi' in im.info:\n            dpi = Resolution(*im.info['dpi'])\n        else:\n                                          \n            dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n\n                                     \n        im.save(output_file, format='JPEG', dpi=dpi.to_int())\n    return output_file", "func_code_string": "def create_visible_page_jpg(image: Path, page_context: PageContext) -> Path:\n           \n    output_file = page_context.get_path('visible.jpg')\n    with Image.open(image) as im:\n                                                                       \n                                                                            \n                                                                  \n                                                                          \n                                                                    \n        if 'dpi' in im.info:\n            dpi = Resolution(*im.info['dpi'])\n        else:\n                                          \n            dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n\n                                     \n        im.save(output_file, format='JPEG', dpi=dpi.to_int())\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "create_pdf_page_from_image", "whole_func_string": "def create_pdf_page_from_image(\n    image: Path, page_context: PageContext, orientation_correction: int\n) -> Path:\n                                              \n                                                                       \n                                                                              \n                                                                                \n                                                                              \n                                                                           \n                                      \n    output_file = page_context.get_path('visible.pdf')\n\n    pageinfo = page_context.pageinfo\n    pagesize = 72.0 * float(pageinfo.width_inches), 72.0 * float(pageinfo.height_inches)\n    effective_rotation = (pageinfo.rotation - orientation_correction) % 360\n    swap_axis = effective_rotation % 180 == 90\n    if swap_axis:\n        pagesize = pagesize[1], pagesize[0]\n\n                                          \n    bio = BytesIO()\n    with open(image, 'rb') as imfile:\n        log.debug('convert')\n\n        layout_fun = img2pdf.get_layout_fun(pagesize)\n        img2pdf.convert(\n            imfile,\n            layout_fun=layout_fun,\n            outputstream=bio,\n            engine=img2pdf.Engine.pikepdf,\n            rotation=img2pdf.Rotation.ifvalid,\n        )\n        log.debug('convert done')\n\n                                                               \n    bio.seek(0)\n    fix_pagepdf_boxes(bio, output_file, page_context, swap_axis=swap_axis)\n\n    output_file = page_context.plugin_manager.hook.filter_pdf_page(\n        page=page_context, image_filename=image, output_pdf=output_file\n    )\n    return output_file", "func_code_string": "def create_pdf_page_from_image(\n    image: Path, page_context: PageContext, orientation_correction: int\n) -> Path:\n                                              \n                                                                       \n                                                                              \n                                                                                \n                                                                              \n                                                                           \n                                      \n    output_file = page_context.get_path('visible.pdf')\n\n    pageinfo = page_context.pageinfo\n    pagesize = 72.0 * float(pageinfo.width_inches), 72.0 * float(pageinfo.height_inches)\n    effective_rotation = (pageinfo.rotation - orientation_correction) % 360\n    swap_axis = effective_rotation % 180 == 90\n    if swap_axis:\n        pagesize = pagesize[1], pagesize[0]\n\n                                          \n    bio = BytesIO()\n    with open(image, 'rb') as imfile:\n        log.debug('convert')\n\n        layout_fun = img2pdf.get_layout_fun(pagesize)\n        img2pdf.convert(\n            imfile,\n            layout_fun=layout_fun,\n            outputstream=bio,\n            engine=img2pdf.Engine.pikepdf,\n            rotation=img2pdf.Rotation.ifvalid,\n        )\n        log.debug('convert done')\n\n                                                               \n    bio.seek(0)\n    fix_pagepdf_boxes(bio, output_file, page_context, swap_axis=swap_axis)\n\n    output_file = page_context.plugin_manager.hook.filter_pdf_page(\n        page=page_context, image_filename=image, output_pdf=output_file\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "render_hocr_page", "whole_func_string": "def render_hocr_page(hocr: Path, page_context: PageContext) -> Path:\n                                        \n    options = page_context.options\n    output_file = page_context.get_path('ocr_hocr.pdf')\n    if hocr.stat().st_size == 0:\n                                                                               \n        output_file.touch()\n        return output_file\n\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n    debug_kwargs = {}\n    if options.pdf_renderer == 'hocrdebug':\n        debug_kwargs = dict(\n            debug_render_options=DebugRenderOptions(\n                render_baseline=True,\n                render_triangle=True,\n                render_line_bbox=False,\n                render_word_bbox=True,\n                render_paragraph_bbox=False,\n                render_space_bbox=False,\n            ),\n            font=Courier(),\n        )\n    HocrTransform(\n        hocr_filename=hocr,\n        dpi=dpi.to_scalar(),\n        **debug_kwargs,          \n    ).to_pdf(\n        out_filename=output_file,\n        image_filename=None,\n        invisible_text=True if not debug_kwargs else False,\n    )\n    return output_file", "func_code_string": "def render_hocr_page(hocr: Path, page_context: PageContext) -> Path:\n                                        \n    options = page_context.options\n    output_file = page_context.get_path('ocr_hocr.pdf')\n    if hocr.stat().st_size == 0:\n                                                                               \n        output_file.touch()\n        return output_file\n\n    dpi = get_page_square_dpi(page_context, calculate_image_dpi(page_context))\n    debug_kwargs = {}\n    if options.pdf_renderer == 'hocrdebug':\n        debug_kwargs = dict(\n            debug_render_options=DebugRenderOptions(\n                render_baseline=True,\n                render_triangle=True,\n                render_line_bbox=False,\n                render_word_bbox=True,\n                render_paragraph_bbox=False,\n                render_space_bbox=False,\n            ),\n            font=Courier(),\n        )\n    HocrTransform(\n        hocr_filename=hocr,\n        dpi=dpi.to_scalar(),\n        **debug_kwargs,          \n    ).to_pdf(\n        out_filename=output_file,\n        image_filename=None,\n        invisible_text=True if not debug_kwargs else False,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "ocr_engine_textonly_pdf", "whole_func_string": "def ocr_engine_textonly_pdf(\n    input_image: Path, page_context: PageContext\n) -> tuple[Path, Path]:\n                                                                            \n    output_pdf = page_context.get_path('ocr_tess.pdf')\n    output_text = page_context.get_path('ocr_tess.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_pdf(\n        input_file=input_image,\n        output_pdf=output_pdf,\n        output_text=output_text,\n        options=options,\n    )\n    return output_pdf, output_text", "func_code_string": "def ocr_engine_textonly_pdf(\n    input_image: Path, page_context: PageContext\n) -> tuple[Path, Path]:\n                                                                            \n    output_pdf = page_context.get_path('ocr_tess.pdf')\n    output_text = page_context.get_path('ocr_tess.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_pdf(\n        input_file=input_image,\n        output_pdf=output_pdf,\n        output_text=output_text,\n        options=options,\n    )\n    return output_pdf, output_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "_offset_rect", "whole_func_string": "def _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]):\n                                               \n    return (\n        rect[0] + offset[0],\n        rect[1] + offset[1],\n        rect[2] + offset[0],\n        rect[3] + offset[1],\n    )", "func_code_string": "def _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]):\n                                               \n    return (\n        rect[0] + offset[0],\n        rect[1] + offset[1],\n        rect[2] + offset[0],\n        rect[3] + offset[1],\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "fix_pagepdf_boxes", "whole_func_string": "def fix_pagepdf_boxes(\n    infile: Path | BinaryIO,\n    out_file: Path,\n    page_context: PageContext,\n    swap_axis: bool = False,\n) -> Path:\n           \n    with pikepdf.open(infile) as pdf:\n        for page in pdf.pages:\n                                                            \n                                                        \n            mediabox = page_context.pageinfo.mediabox\n            offset = mediabox[0], mediabox[1]\n            cropbox = _offset_rect(page_context.pageinfo.cropbox, offset)\n            trimbox = _offset_rect(page_context.pageinfo.trimbox, offset)\n\n            if swap_axis:\n                cropbox = cropbox[1], cropbox[0], cropbox[3], cropbox[2]\n                trimbox = trimbox[1], trimbox[0], trimbox[3], trimbox[2]\n            page.CropBox = cropbox\n            page.TrimBox = trimbox\n        pdf.save(out_file)\n    return out_file", "func_code_string": "def fix_pagepdf_boxes(\n    infile: Path | BinaryIO,\n    out_file: Path,\n    page_context: PageContext,\n    swap_axis: bool = False,\n) -> Path:\n           \n    with pikepdf.open(infile) as pdf:\n        for page in pdf.pages:\n                                                            \n                                                        \n            mediabox = page_context.pageinfo.mediabox\n            offset = mediabox[0], mediabox[1]\n            cropbox = _offset_rect(page_context.pageinfo.cropbox, offset)\n            trimbox = _offset_rect(page_context.pageinfo.trimbox, offset)\n\n            if swap_axis:\n                cropbox = cropbox[1], cropbox[0], cropbox[3], cropbox[2]\n                trimbox = trimbox[1], trimbox[0], trimbox[3], trimbox[2]\n            page.CropBox = cropbox\n            page.TrimBox = trimbox\n        pdf.save(out_file)\n    return out_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "generate_postscript_stub", "whole_func_string": "def generate_postscript_stub(context: PdfContext) -> Path:\n           \n    output_file = context.get_path('pdfa.ps')\n    generate_pdfa_ps(output_file)\n    return output_file", "func_code_string": "def generate_postscript_stub(context: PdfContext) -> Path:\n           \n    output_file = context.get_path('pdfa.ps')\n    generate_pdfa_ps(output_file)\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "convert_to_pdfa", "whole_func_string": "def convert_to_pdfa(input_pdf: Path, input_ps_stub: Path, context: PdfContext) -> Path:\n           \n    options = context.options\n    input_pdfinfo = context.pdfinfo\n    fix_docinfo_file = context.get_path('fix_docinfo.pdf')\n    output_file = context.get_path('pdfa.pdf')\n\n                                                                          \n                                                                      \n                                                                                \n                                                                         \n                                            \n    with pikepdf.open(input_pdf) as pdf_file:\n        if repair_docinfo_nuls(pdf_file):\n            pdf_file.save(fix_docinfo_file)\n        else:\n            safe_symlink(input_pdf, fix_docinfo_file)\n\n    context.plugin_manager.hook.generate_pdfa(\n        pdf_version=input_pdfinfo.min_version,\n        pdf_pages=[fix_docinfo_file],\n        pdfmark=input_ps_stub,\n        output_file=output_file,\n        context=context,\n        pdfa_part=options.output_type[-1],                                \n        progressbar_class=(\n            context.plugin_manager.hook.get_progressbar_class()\n            if options.progress_bar\n            else None\n        ),\n        stop_on_soft_error=not options.continue_on_soft_render_error,\n    )\n\n    return output_file", "func_code_string": "def convert_to_pdfa(input_pdf: Path, input_ps_stub: Path, context: PdfContext) -> Path:\n           \n    options = context.options\n    input_pdfinfo = context.pdfinfo\n    fix_docinfo_file = context.get_path('fix_docinfo.pdf')\n    output_file = context.get_path('pdfa.pdf')\n\n                                                                          \n                                                                      \n                                                                                \n                                                                         \n                                            \n    with pikepdf.open(input_pdf) as pdf_file:\n        if repair_docinfo_nuls(pdf_file):\n            pdf_file.save(fix_docinfo_file)\n        else:\n            safe_symlink(input_pdf, fix_docinfo_file)\n\n    context.plugin_manager.hook.generate_pdfa(\n        pdf_version=input_pdfinfo.min_version,\n        pdf_pages=[fix_docinfo_file],\n        pdfmark=input_ps_stub,\n        output_file=output_file,\n        context=context,\n        pdfa_part=options.output_type[-1],                                \n        progressbar_class=(\n            context.plugin_manager.hook.get_progressbar_class()\n            if options.progress_bar\n            else None\n        ),\n        stop_on_soft_error=not options.continue_on_soft_render_error,\n    )\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "should_linearize", "whole_func_string": "def should_linearize(working_file: Path, context: PdfContext) -> bool:\n           \n    filesize = os.stat(working_file).st_size\n    if filesize > (context.options.fast_web_view * 1_000_000):\n        return True\n    return False", "func_code_string": "def should_linearize(working_file: Path, context: PdfContext) -> bool:\n           \n    filesize = os.stat(working_file).st_size\n    if filesize > (context.options.fast_web_view * 1_000_000):\n        return True\n    return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_pdf_save_settings", "whole_func_string": "def get_pdf_save_settings(output_type: str) -> dict[str, Any]:\n           \n    if output_type == 'pdfa-1':\n                                                                             \n                                                              \n        return dict(\n            preserve_pdfa=True,\n            compress_streams=True,\n            stream_decode_level=pikepdf.StreamDecodeLevel.generalized,\n            object_stream_mode=pikepdf.ObjectStreamMode.disable,\n        )\n    else:\n        return dict(\n            preserve_pdfa=True,\n            compress_streams=True,\n            object_stream_mode=(pikepdf.ObjectStreamMode.generate),\n        )", "func_code_string": "def get_pdf_save_settings(output_type: str) -> dict[str, Any]:\n           \n    if output_type == 'pdfa-1':\n                                                                             \n                                                              \n        return dict(\n            preserve_pdfa=True,\n            compress_streams=True,\n            stream_decode_level=pikepdf.StreamDecodeLevel.generalized,\n            object_stream_mode=pikepdf.ObjectStreamMode.disable,\n        )\n    else:\n        return dict(\n            preserve_pdfa=True,\n            compress_streams=True,\n            object_stream_mode=(pikepdf.ObjectStreamMode.generate),\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "_file_size_ratio", "whole_func_string": "def _file_size_ratio(\n    input_file: Path, output_file: Path\n) -> tuple[float | None, float | None]:\n           \n    input_size = input_file.stat().st_size\n    output_size = output_file.stat().st_size\n    if output_size == 0:\n        return None, None\n    ratio = input_size / output_size\n    savings = 1 - output_size / input_size\n    return ratio, savings", "func_code_string": "def _file_size_ratio(\n    input_file: Path, output_file: Path\n) -> tuple[float | None, float | None]:\n           \n    input_size = input_file.stat().st_size\n    output_size = output_file.stat().st_size\n    if output_size == 0:\n        return None, None\n    ratio = input_size / output_size\n    savings = 1 - output_size / input_size\n    return ratio, savings", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "optimize_pdf", "whole_func_string": "def optimize_pdf(\n    input_file: Path, context: PdfContext, executor: Executor\n) -> tuple[Path, Sequence[str]]:\n                                      \n    output_file = context.get_path('optimize.pdf')\n    output_pdf, messages = context.plugin_manager.hook.optimize_pdf(\n        input_pdf=input_file,\n        output_pdf=output_file,\n        context=context,\n        executor=executor,\n        linearize=should_linearize(input_file, context),\n    )\n\n    ratio, savings = _file_size_ratio(input_file, output_file)\n    if ratio:\n        log.info(f\"Image optimization ratio: {ratio:.2f} savings: {(savings):.1%}\")\n    ratio, savings = _file_size_ratio(context.origin, output_file)\n    if ratio:\n        log.info(f\"Total file size ratio: {ratio:.2f} savings: {(savings):.1%}\")\n    return output_pdf, messages", "func_code_string": "def optimize_pdf(\n    input_file: Path, context: PdfContext, executor: Executor\n) -> tuple[Path, Sequence[str]]:\n                                      \n    output_file = context.get_path('optimize.pdf')\n    output_pdf, messages = context.plugin_manager.hook.optimize_pdf(\n        input_pdf=input_file,\n        output_pdf=output_file,\n        context=context,\n        executor=executor,\n        linearize=should_linearize(input_file, context),\n    )\n\n    ratio, savings = _file_size_ratio(input_file, output_file)\n    if ratio:\n        log.info(f\"Image optimization ratio: {ratio:.2f} savings: {(savings):.1%}\")\n    ratio, savings = _file_size_ratio(context.origin, output_file)\n    if ratio:\n        log.info(f\"Total file size ratio: {ratio:.2f} savings: {(savings):.1%}\")\n    return output_pdf, messages", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "enumerate_compress_ranges", "whole_func_string": "def enumerate_compress_ranges(\n    iterable: Iterable[T],\n) -> Iterator[tuple[tuple[int, int], T | None]]:\n           \n    skipped_from, index = None, None\n    for index, txt_file in enumerate(iterable):\n        index += 1\n        if txt_file:\n            if skipped_from is not None:\n                yield (skipped_from, index - 1), None\n                skipped_from = None\n            yield (index, index), txt_file\n        else:\n            if skipped_from is None:\n                skipped_from = index\n    if skipped_from is not None:\n        yield (skipped_from, index), None", "func_code_string": "def enumerate_compress_ranges(\n    iterable: Iterable[T],\n) -> Iterator[tuple[tuple[int, int], T | None]]:\n           \n    skipped_from, index = None, None\n    for index, txt_file in enumerate(iterable):\n        index += 1\n        if txt_file:\n            if skipped_from is not None:\n                yield (skipped_from, index - 1), None\n                skipped_from = None\n            yield (index, index), txt_file\n        else:\n            if skipped_from is None:\n                skipped_from = index\n    if skipped_from is not None:\n        yield (skipped_from, index), None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "merge_sidecars", "whole_func_string": "def merge_sidecars(txt_files: Iterable[Path | None], context: PdfContext) -> Path:\n           \n    output_file = context.get_path('sidecar.txt')\n    with open(output_file, 'w', encoding=\"utf-8\") as stream:\n        for (from_, to_), txt_file in enumerate_compress_ranges(txt_files):\n            if from_ != 1:\n                stream.write('\\f')                                                     \n            if txt_file:\n                txt = txt_file.read_text(encoding=\"utf-8\")\n                                                                           \n                                                                                  \n                stream.write(txt.removesuffix('\\f'))\n            else:\n                if from_ != to_:\n                    pages = f'{from_}-{to_}'\n                else:\n                    pages = f'{from_}'\n                stream.write(f'[OCR skipped on page(s) {pages}]')\n    return output_file", "func_code_string": "def merge_sidecars(txt_files: Iterable[Path | None], context: PdfContext) -> Path:\n           \n    output_file = context.get_path('sidecar.txt')\n    with open(output_file, 'w', encoding=\"utf-8\") as stream:\n        for (from_, to_), txt_file in enumerate_compress_ranges(txt_files):\n            if from_ != 1:\n                stream.write('\\f')                                                     \n            if txt_file:\n                txt = txt_file.read_text(encoding=\"utf-8\")\n                                                                           \n                                                                                  \n                stream.write(txt.removesuffix('\\f'))\n            else:\n                if from_ != to_:\n                    pages = f'{from_}-{to_}'\n                else:\n                    pages = f'{from_}'\n                stream.write(f'[OCR skipped on page(s) {pages}]')\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "copy_final", "whole_func_string": "def copy_final(\n    input_file: Path, output_file: str | Path | BinaryIO, original_file: Path | None\n) -> None:\n           \n    log.debug('%s -> %s', input_file, output_file)\n    with input_file.open('rb') as input_stream:\n        if output_file == '-':\n            copyfileobj(input_stream, sys.stdout.buffer)                      \n            sys.stdout.flush()\n        elif hasattr(output_file, 'writable'):\n            output_stream = cast(BinaryIO, output_file)\n            copyfileobj(input_stream, output_stream)                      \n            with suppress(AttributeError):\n                output_stream.flush()\n        else:\n                                                                              \n                                                                               \n                                                        \n            with open(output_file, 'w+b') as output_stream:\n                copyfileobj(input_stream, output_stream)", "func_code_string": "def copy_final(\n    input_file: Path, output_file: str | Path | BinaryIO, original_file: Path | None\n) -> None:\n           \n    log.debug('%s -> %s', input_file, output_file)\n    with input_file.open('rb') as input_stream:\n        if output_file == '-':\n            copyfileobj(input_stream, sys.stdout.buffer)                      \n            sys.stdout.flush()\n        elif hasattr(output_file, 'writable'):\n            output_stream = cast(BinaryIO, output_file)\n            copyfileobj(input_stream, output_stream)                      \n            with suppress(AttributeError):\n                output_stream.flush()\n        else:\n                                                                              \n                                                                               \n                                                        \n            with open(output_file, 'w+b') as output_stream:\n                copyfileobj(input_stream, output_stream)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "at_least", "whole_func_string": "def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))", "func_code_string": "def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "register_heif_opener", "whole_func_string": "def register_heif_opener():\n        pass", "func_code_string": "def register_heif_opener():\n        pass", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_platform", "whole_func_string": "def check_platform() -> None:\n    if sys.maxsize <= 2**32:                    \n        log.warning(\n            \"You are running OCRmyPDF in a 32-bit (x86) Python interpreter. \"\n            \"This is not supported. 32-bit does not have enough address space \"\n            \"to process large files. \"\n            \"Please use a 64-bit (x86-64) version of Python.\"\n        )", "func_code_string": "def check_platform() -> None:\n    if sys.maxsize <= 2**32:                    \n        log.warning(\n            \"You are running OCRmyPDF in a 32-bit (x86) Python interpreter. \"\n            \"This is not supported. 32-bit does not have enough address space \"\n            \"to process large files. \"\n            \"Please use a 64-bit (x86-64) version of Python.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_languages", "whole_func_string": "def check_options_languages(\n    options: Namespace, ocr_engine_languages: list[str]\n) -> None:\n    if not options.languages:\n        options.languages = [DEFAULT_LANGUAGE]\n        system_lang = locale.getlocale()[0]\n        if system_lang and not system_lang.startswith('en'):\n            log.debug(\"No language specified; assuming --language %s\", DEFAULT_LANGUAGE)\n    if not ocr_engine_languages:\n        return\n\n    missing_languages = set(options.languages) - set(ocr_engine_languages)\n    if missing_languages:\n        lang_text = '\\n'.join(lang for lang in missing_languages)\n        msg = (\n            \"OCR engine does not have language data for the following \"\n            \"requested languages: \\n\"\n            f\"{lang_text}\\n\"\n            \"Please install the appropriate language data for your OCR engine.\\n\"\n            \"\\n\"\n            \"See the online documentation for instructions:\\n\"\n            \"    https://ocrmypdf.readthedocs.io/en/latest/languages.html\\n\"\n            \"\\n\"\n            \"Note: most languages are identified by a 3-letter ISO 639-2 Code.\\n\"\n            \"For example, English is 'eng', German is 'deu', and Spanish is 'spa'.\\n\"\n            \"Simplified Chinese is 'chi_sim' and Traditional Chinese is 'chi_tra'.\"\n            \"\\n\"\n        )\n        raise MissingDependencyError(msg)", "func_code_string": "def check_options_languages(\n    options: Namespace, ocr_engine_languages: list[str]\n) -> None:\n    if not options.languages:\n        options.languages = [DEFAULT_LANGUAGE]\n        system_lang = locale.getlocale()[0]\n        if system_lang and not system_lang.startswith('en'):\n            log.debug(\"No language specified; assuming --language %s\", DEFAULT_LANGUAGE)\n    if not ocr_engine_languages:\n        return\n\n    missing_languages = set(options.languages) - set(ocr_engine_languages)\n    if missing_languages:\n        lang_text = '\\n'.join(lang for lang in missing_languages)\n        msg = (\n            \"OCR engine does not have language data for the following \"\n            \"requested languages: \\n\"\n            f\"{lang_text}\\n\"\n            \"Please install the appropriate language data for your OCR engine.\\n\"\n            \"\\n\"\n            \"See the online documentation for instructions:\\n\"\n            \"    https://ocrmypdf.readthedocs.io/en/latest/languages.html\\n\"\n            \"\\n\"\n            \"Note: most languages are identified by a 3-letter ISO 639-2 Code.\\n\"\n            \"For example, English is 'eng', German is 'deu', and Spanish is 'spa'.\\n\"\n            \"Simplified Chinese is 'chi_sim' and Traditional Chinese is 'chi_tra'.\"\n            \"\\n\"\n        )\n        raise MissingDependencyError(msg)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_output", "whole_func_string": "def check_options_output(options: Namespace) -> None:\n    if options.output_type == 'none' and options.output_file not in (os.devnull, '-'):\n        raise BadArgsError(\n            \"Since you specified `--output-type none`, the output file \"\n            f\"{options.output_file} cannot be produced. Set the output file to \"\n            f\"`-` to suppress this message.\"\n        )", "func_code_string": "def check_options_output(options: Namespace) -> None:\n    if options.output_type == 'none' and options.output_file not in (os.devnull, '-'):\n        raise BadArgsError(\n            \"Since you specified `--output-type none`, the output file \"\n            f\"{options.output_file} cannot be produced. Set the output file to \"\n            f\"`-` to suppress this message.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "set_lossless_reconstruction", "whole_func_string": "def set_lossless_reconstruction(options: Namespace) -> None:\n    lossless_reconstruction = False\n    if not any(\n        (\n            options.deskew,\n            options.clean_final,\n            options.force_ocr,\n            options.remove_background,\n        )\n    ):\n        lossless_reconstruction = True\n    options.lossless_reconstruction = lossless_reconstruction\n\n    if not options.lossless_reconstruction and options.redo_ocr:\n        raise BadArgsError(\n            \"--redo-ocr is not currently compatible with --deskew, \"\n            \"--clean-final, and --remove-background\"\n        )", "func_code_string": "def set_lossless_reconstruction(options: Namespace) -> None:\n    lossless_reconstruction = False\n    if not any(\n        (\n            options.deskew,\n            options.clean_final,\n            options.force_ocr,\n            options.remove_background,\n        )\n    ):\n        lossless_reconstruction = True\n    options.lossless_reconstruction = lossless_reconstruction\n\n    if not options.lossless_reconstruction and options.redo_ocr:\n        raise BadArgsError(\n            \"--redo-ocr is not currently compatible with --deskew, \"\n            \"--clean-final, and --remove-background\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_sidecar", "whole_func_string": "def check_options_sidecar(options: Namespace) -> None:\n    if options.sidecar == '\\0':\n        if options.output_file == '-':\n            raise BadArgsError(\"--sidecar filename needed when output file is stdout.\")\n        elif options.output_file == os.devnull:\n            raise BadArgsError(\n                \"--sidecar filename needed when output file is /dev/null or NUL.\"\n            )\n        options.sidecar = options.output_file + '.txt'\n    if options.sidecar == options.input_file or options.sidecar == options.output_file:\n        raise BadArgsError(\n            \"--sidecar file must be different from the input and output files\"\n        )", "func_code_string": "def check_options_sidecar(options: Namespace) -> None:\n    if options.sidecar == '\\0':\n        if options.output_file == '-':\n            raise BadArgsError(\"--sidecar filename needed when output file is stdout.\")\n        elif options.output_file == os.devnull:\n            raise BadArgsError(\n                \"--sidecar filename needed when output file is /dev/null or NUL.\"\n            )\n        options.sidecar = options.output_file + '.txt'\n    if options.sidecar == options.input_file or options.sidecar == options.output_file:\n        raise BadArgsError(\n            \"--sidecar file must be different from the input and output files\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_preprocessing", "whole_func_string": "def check_options_preprocessing(options: Namespace) -> None:\n    if options.clean_final:\n        options.clean = True\n    if options.unpaper_args and not options.clean:\n        raise BadArgsError(\"--clean is required for --unpaper-args\")\n    if (\n        options.rotate_pages_threshold != DEFAULT_ROTATE_PAGES_THRESHOLD\n        and not options.rotate_pages\n    ):\n        raise BadArgsError(\"--rotate-pages is required for --rotate-pages-threshold\")\n    if options.clean:\n        check_external_program(\n            program='unpaper',\n            package='unpaper',\n            version_checker=unpaper.version,\n            need_version='6.1',\n            required_for=\"--clean, --clean-final\",                     \n        )\n        try:\n            if options.unpaper_args:\n                options.unpaper_args = unpaper.validate_custom_args(\n                    options.unpaper_args\n                )\n        except Exception as e:\n            raise BadArgsError(\"--unpaper-args: \" + str(e)) from e", "func_code_string": "def check_options_preprocessing(options: Namespace) -> None:\n    if options.clean_final:\n        options.clean = True\n    if options.unpaper_args and not options.clean:\n        raise BadArgsError(\"--clean is required for --unpaper-args\")\n    if (\n        options.rotate_pages_threshold != DEFAULT_ROTATE_PAGES_THRESHOLD\n        and not options.rotate_pages\n    ):\n        raise BadArgsError(\"--rotate-pages is required for --rotate-pages-threshold\")\n    if options.clean:\n        check_external_program(\n            program='unpaper',\n            package='unpaper',\n            version_checker=unpaper.version,\n            need_version='6.1',\n            required_for=\"--clean, --clean-final\",                     \n        )\n        try:\n            if options.unpaper_args:\n                options.unpaper_args = unpaper.validate_custom_args(\n                    options.unpaper_args\n                )\n        except Exception as e:\n            raise BadArgsError(\"--unpaper-args: \" + str(e)) from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "_pages_from_ranges", "whole_func_string": "def _pages_from_ranges(ranges: str) -> set[int]:\n    pages: list[int] = []\n    page_groups = ranges.replace(' ', '').split(',')\n    for group in page_groups:\n        if not group:\n            continue\n        try:\n            start, end = group.split('-')\n        except ValueError:\n            pages.append(int(group) - 1)\n        else:\n            try:\n                new_pages = list(range(int(start) - 1, int(end)))\n                if not new_pages:\n                    raise BadArgsError(\n                        f\"invalid page subrange '{start}-{end}'\"\n                    ) from None\n                pages.extend(new_pages)\n            except ValueError:\n                raise BadArgsError(f\"invalid page subrange '{group}'\") from None\n\n    if not pages:\n        raise BadArgsError(\n            f\"The string of page ranges '{ranges}' did not contain any recognizable \"\n            f\"page ranges.\"\n        )\n\n    if not monotonic(pages):\n        log.warning(\n            \"List of pages to process contains duplicate pages, or pages that are \"\n            \"out of order\"\n        )\n    if any(page < 0 for page in pages):\n        raise BadArgsError(\"pages refers to a page number less than 1\")\n\n    log.debug(\"OCRing only these pages: %s\", pages)\n    return set(pages)", "func_code_string": "def _pages_from_ranges(ranges: str) -> set[int]:\n    pages: list[int] = []\n    page_groups = ranges.replace(' ', '').split(',')\n    for group in page_groups:\n        if not group:\n            continue\n        try:\n            start, end = group.split('-')\n        except ValueError:\n            pages.append(int(group) - 1)\n        else:\n            try:\n                new_pages = list(range(int(start) - 1, int(end)))\n                if not new_pages:\n                    raise BadArgsError(\n                        f\"invalid page subrange '{start}-{end}'\"\n                    ) from None\n                pages.extend(new_pages)\n            except ValueError:\n                raise BadArgsError(f\"invalid page subrange '{group}'\") from None\n\n    if not pages:\n        raise BadArgsError(\n            f\"The string of page ranges '{ranges}' did not contain any recognizable \"\n            f\"page ranges.\"\n        )\n\n    if not monotonic(pages):\n        log.warning(\n            \"List of pages to process contains duplicate pages, or pages that are \"\n            \"out of order\"\n        )\n    if any(page < 0 for page in pages):\n        raise BadArgsError(\"pages refers to a page number less than 1\")\n\n    log.debug(\"OCRing only these pages: %s\", pages)\n    return set(pages)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_ocr_behavior", "whole_func_string": "def check_options_ocr_behavior(options: Namespace) -> None:\n    exclusive_options = sum(\n        (1 if opt else 0)\n        for opt in (options.force_ocr, options.skip_text, options.redo_ocr)\n    )\n    if exclusive_options >= 2:\n        raise BadArgsError(\"Choose only one of --force-ocr, --skip-text, --redo-ocr.\")\n    if options.pages:\n        options.pages = _pages_from_ranges(options.pages)", "func_code_string": "def check_options_ocr_behavior(options: Namespace) -> None:\n    exclusive_options = sum(\n        (1 if opt else 0)\n        for opt in (options.force_ocr, options.skip_text, options.redo_ocr)\n    )\n    if exclusive_options >= 2:\n        raise BadArgsError(\"Choose only one of --force-ocr, --skip-text, --redo-ocr.\")\n    if options.pages:\n        options.pages = _pages_from_ranges(options.pages)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_metadata", "whole_func_string": "def check_options_metadata(options: Namespace) -> None:\n    docinfo = [options.title, options.author, options.keywords, options.subject]\n    for s in (m for m in docinfo if m):\n        for char in s:\n            if unicodedata.category(char) == 'Co' or ord(char) >= 0x10000:\n                hexchar = hex(ord(char))[2:].upper()\n                raise ValueError(\n                    \"One of the metadata strings contains \"\n                    \"an unsupported Unicode character: \"\n                    f\"{char} (U+{hexchar})\"\n                )", "func_code_string": "def check_options_metadata(options: Namespace) -> None:\n    docinfo = [options.title, options.author, options.keywords, options.subject]\n    for s in (m for m in docinfo if m):\n        for char in s:\n            if unicodedata.category(char) == 'Co' or ord(char) >= 0x10000:\n                hexchar = hex(ord(char))[2:].upper()\n                raise ValueError(\n                    \"One of the metadata strings contains \"\n                    \"an unsupported Unicode character: \"\n                    f\"{char} (U+{hexchar})\"\n                )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_pillow", "whole_func_string": "def check_options_pillow(options: Namespace) -> None:\n    PIL.Image.MAX_IMAGE_PIXELS = int(options.max_image_mpixels * 1_000_000)\n    if PIL.Image.MAX_IMAGE_PIXELS == 0:\n        PIL.Image.MAX_IMAGE_PIXELS = None", "func_code_string": "def check_options_pillow(options: Namespace) -> None:\n    PIL.Image.MAX_IMAGE_PIXELS = int(options.max_image_mpixels * 1_000_000)\n    if PIL.Image.MAX_IMAGE_PIXELS == 0:\n        PIL.Image.MAX_IMAGE_PIXELS = None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "_check_plugin_invariant_options", "whole_func_string": "def _check_plugin_invariant_options(options: Namespace) -> None:\n    check_platform()\n    check_options_metadata(options)\n    check_options_output(options)\n    set_lossless_reconstruction(options)\n    check_options_sidecar(options)\n    check_options_preprocessing(options)\n    check_options_ocr_behavior(options)\n    check_options_pillow(options)", "func_code_string": "def _check_plugin_invariant_options(options: Namespace) -> None:\n    check_platform()\n    check_options_metadata(options)\n    check_options_output(options)\n    set_lossless_reconstruction(options)\n    check_options_sidecar(options)\n    check_options_preprocessing(options)\n    check_options_ocr_behavior(options)\n    check_options_pillow(options)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "_check_plugin_options", "whole_func_string": "def _check_plugin_options(options: Namespace, plugin_manager: PluginManager) -> None:\n    plugin_manager.hook.check_options(options=options)\n    ocr_engine_languages = plugin_manager.hook.get_ocr_engine().languages(options)\n    check_options_languages(options, ocr_engine_languages)", "func_code_string": "def _check_plugin_options(options: Namespace, plugin_manager: PluginManager) -> None:\n    plugin_manager.hook.check_options(options=options)\n    ocr_engine_languages = plugin_manager.hook.get_ocr_engine().languages(options)\n    check_options_languages(options, ocr_engine_languages)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options", "whole_func_string": "def check_options(options: Namespace, plugin_manager: PluginManager) -> None:\n    _check_plugin_invariant_options(options)\n    _check_plugin_options(options, plugin_manager)", "func_code_string": "def check_options(options: Namespace, plugin_manager: PluginManager) -> None:\n    _check_plugin_invariant_options(options)\n    _check_plugin_options(options, plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "create_input_file", "whole_func_string": "def create_input_file(options: Namespace, work_folder: Path) -> tuple[Path, str]:\n    if options.input_file == '-':\n               \n        log.info('reading file from standard input')\n        target = work_folder / 'stdin'\n        with open(target, 'wb') as stream_buffer:\n            copyfileobj(sys.stdin.buffer, stream_buffer)\n        return target, \"stdin\"\n    elif hasattr(options.input_file, 'readable'):\n        if not options.input_file.readable():\n            raise InputFileError(\"Input file stream is not readable\")\n        log.info('reading file from input stream')\n        target = work_folder / 'stream'\n        with open(target, 'wb') as stream_buffer:\n            copyfileobj(options.input_file, stream_buffer)\n        return target, \"stream\"\n    else:\n        try:\n            target = work_folder / 'origin'\n            safe_symlink(options.input_file, target)\n            return target, os.fspath(options.input_file)\n        except FileNotFoundError as e:\n            msg = f\"File not found - {options.input_file}\"\n            if running_in_docker():                    \n                msg += (\n                    \"\\nDocker cannot access your working directory unless you \"\n                    \"explicitly share it with the Docker container and set up\"\n                    \"permissions correctly.\\n\"\n                    \"You may find it easier to use stdin/stdout:\"\n                    \"\\n\"\n                    \"\\tdocker run -i --rm jbarlow83/ocrmypdf - - <input.pdf >output.pdf\"\n                    \"\\n\"\n                )\n            elif running_in_snap():                    \n                msg += (\n                    \"\\nSnap applications cannot access files outside of \"\n                    \"your home directory unless you explicitly allow it. \"\n                    \"You may find it easier to use stdin/stdout:\"\n                    \"\\n\"\n                    \"\\tsnap run ocrmypdf - - <input.pdf >output.pdf\"\n                    \"\\n\"\n                )\n            raise InputFileError(msg) from e", "func_code_string": "def create_input_file(options: Namespace, work_folder: Path) -> tuple[Path, str]:\n    if options.input_file == '-':\n               \n        log.info('reading file from standard input')\n        target = work_folder / 'stdin'\n        with open(target, 'wb') as stream_buffer:\n            copyfileobj(sys.stdin.buffer, stream_buffer)\n        return target, \"stdin\"\n    elif hasattr(options.input_file, 'readable'):\n        if not options.input_file.readable():\n            raise InputFileError(\"Input file stream is not readable\")\n        log.info('reading file from input stream')\n        target = work_folder / 'stream'\n        with open(target, 'wb') as stream_buffer:\n            copyfileobj(options.input_file, stream_buffer)\n        return target, \"stream\"\n    else:\n        try:\n            target = work_folder / 'origin'\n            safe_symlink(options.input_file, target)\n            return target, os.fspath(options.input_file)\n        except FileNotFoundError as e:\n            msg = f\"File not found - {options.input_file}\"\n            if running_in_docker():                    \n                msg += (\n                    \"\\nDocker cannot access your working directory unless you \"\n                    \"explicitly share it with the Docker container and set up\"\n                    \"permissions correctly.\\n\"\n                    \"You may find it easier to use stdin/stdout:\"\n                    \"\\n\"\n                    \"\\tdocker run -i --rm jbarlow83/ocrmypdf - - <input.pdf >output.pdf\"\n                    \"\\n\"\n                )\n            elif running_in_snap():                    \n                msg += (\n                    \"\\nSnap applications cannot access files outside of \"\n                    \"your home directory unless you explicitly allow it. \"\n                    \"You may find it easier to use stdin/stdout:\"\n                    \"\\n\"\n                    \"\\tsnap run ocrmypdf - - <input.pdf >output.pdf\"\n                    \"\\n\"\n                )\n            raise InputFileError(msg) from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_requested_output_file", "whole_func_string": "def check_requested_output_file(options: Namespace) -> None:\n    if options.output_file == '-':\n        if sys.stdout.isatty():\n            raise BadArgsError(\n                \"Output was set to stdout '-' but it looks like stdout \"\n                \"is connected to a terminal.  Please redirect stdout to a \"\n                \"file.\"\n            )\n    elif hasattr(options.output_file, 'writable'):\n        if not options.output_file.writable():\n            raise OutputFileAccessError(\"Output stream is not writable\")\n    elif not is_file_writable(options.output_file):\n        raise OutputFileAccessError(\n            f\"Output file location ({options.output_file}) is not a writable file.\"\n        )", "func_code_string": "def check_requested_output_file(options: Namespace) -> None:\n    if options.output_file == '-':\n        if sys.stdout.isatty():\n            raise BadArgsError(\n                \"Output was set to stdout '-' but it looks like stdout \"\n                \"is connected to a terminal.  Please redirect stdout to a \"\n                \"file.\"\n            )\n    elif hasattr(options.output_file, 'writable'):\n        if not options.output_file.writable():\n            raise OutputFileAccessError(\"Output stream is not writable\")\n    elif not is_file_writable(options.output_file):\n        raise OutputFileAccessError(\n            f\"Output file location ({options.output_file}) is not a writable file.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "report_output_file_size", "whole_func_string": "def report_output_file_size(\n    options: Namespace,\n    input_file: Path,\n    output_file: Path,\n    optimize_messages: Sequence[str] | None = None,\n    file_overhead: int = 4000,\n    page_overhead: int = 3000,\n) -> None:\n    if optimize_messages is None:\n        optimize_messages = []\n    try:\n        output_size = Path(output_file).stat().st_size\n        input_size = Path(input_file).stat().st_size\n    except FileNotFoundError:\n        return                                     \n    with pikepdf.open(output_file) as p:\n                                                                               \n                                                                                \n        reasonable_overhead = file_overhead + page_overhead * len(p.pages)\n    ratio = output_size / input_size\n    reasonable_ratio = output_size / (input_size + reasonable_overhead)\n    if reasonable_ratio < 1.35 or input_size < 25000:\n        return              \n\n    reasons = []\n    image_preproc = {\n        'deskew',\n        'clean_final',\n        'remove_background',\n        'oversample',\n        'force_ocr',\n    }\n    for arg in image_preproc:\n        if getattr(options, arg, False):\n            reasons.append(\n                f\"--{arg.replace('_', '-')} was issued, causing transcoding.\"\n            )\n\n    reasons.extend(optimize_messages)\n\n    if options.output_type.startswith('pdfa'):\n        reasons.append(\"PDF/A conversion was enabled. (Try `--output-type pdf`.)\")\n    if options.plugins:\n        reasons.append(\"Plugins were used.\")\n\n    if reasons:\n        explanation = \"Possible reasons for this include:\\n\" + '\\n'.join(reasons) + \"\\n\"\n    else:\n        explanation = \"No reason for this increase is known.  Please report this issue.\"\n\n    log.warning(\n        f\"The output file size is {ratio:.2f}\u00d7 larger than the input file.\\n\"\n        f\"{explanation}\"\n    )", "func_code_string": "def report_output_file_size(\n    options: Namespace,\n    input_file: Path,\n    output_file: Path,\n    optimize_messages: Sequence[str] | None = None,\n    file_overhead: int = 4000,\n    page_overhead: int = 3000,\n) -> None:\n    if optimize_messages is None:\n        optimize_messages = []\n    try:\n        output_size = Path(output_file).stat().st_size\n        input_size = Path(input_file).stat().st_size\n    except FileNotFoundError:\n        return                                     \n    with pikepdf.open(output_file) as p:\n                                                                               \n                                                                                \n        reasonable_overhead = file_overhead + page_overhead * len(p.pages)\n    ratio = output_size / input_size\n    reasonable_ratio = output_size / (input_size + reasonable_overhead)\n    if reasonable_ratio < 1.35 or input_size < 25000:\n        return              \n\n    reasons = []\n    image_preproc = {\n        'deskew',\n        'clean_final',\n        'remove_background',\n        'oversample',\n        'force_ocr',\n    }\n    for arg in image_preproc:\n        if getattr(options, arg, False):\n            reasons.append(\n                f\"--{arg.replace('_', '-')} was issued, causing transcoding.\"\n            )\n\n    reasons.extend(optimize_messages)\n\n    if options.output_type.startswith('pdfa'):\n        reasons.append(\"PDF/A conversion was enabled. (Try `--output-type pdf`.)\")\n    if options.plugins:\n        reasons.append(\"Plugins were used.\")\n\n    if reasons:\n        explanation = \"Possible reasons for this include:\\n\" + '\\n'.join(reasons) + \"\\n\"\n    else:\n        explanation = \"No reason for this increase is known.  Please report this issue.\"\n\n    log.warning(\n        f\"The output file size is {ratio:.2f}\u00d7 larger than the input file.\\n\"\n        f\"{explanation}\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "ExitCode", "whole_func_string": "class ExitCode(IntEnum):\n                                \n\n                                  \n    ok = 0\n    bad_args = 1\n    input_file = 2\n    missing_dependency = 3\n    invalid_output_pdf = 4\n    file_access_error = 5\n    already_done_ocr = 6\n    child_process_error = 7\n    encrypted_pdf = 8\n    invalid_config = 9\n    pdfa_conversion_failed = 10\n    other_error = 15\n    ctrl_c = 130", "func_code_string": "class ExitCode(IntEnum):\n                                \n\n                                  \n    ok = 0\n    bad_args = 1\n    input_file = 2\n    missing_dependency = 3\n    invalid_output_pdf = 4\n    file_access_error = 5\n    already_done_ocr = 6\n    child_process_error = 7\n    encrypted_pdf = 8\n    invalid_config = 9\n    pdfa_conversion_failed = 10\n    other_error = 15\n    ctrl_c = 130", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "ExitCodeException", "whole_func_string": "class ExitCodeException(Exception):\n                                                                        \n\n    exit_code = ExitCode.other_error\n    message = \"\"\n\n    def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_code_string": "class ExitCodeException(Exception):\n                                                                        \n\n    exit_code = ExitCode.other_error\n    message = \"\"\n\n    def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "BadArgsError", "whole_func_string": "class BadArgsError(ExitCodeException):\n                                                       \n\n    exit_code = ExitCode.bad_args", "func_code_string": "class BadArgsError(ExitCodeException):\n                                                       \n\n    exit_code = ExitCode.bad_args", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "MissingDependencyError", "whole_func_string": "class MissingDependencyError(ExitCodeException):\n                                              \n\n    exit_code = ExitCode.missing_dependency", "func_code_string": "class MissingDependencyError(ExitCodeException):\n                                              \n\n    exit_code = ExitCode.missing_dependency", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "UnsupportedImageFormatError", "whole_func_string": "class UnsupportedImageFormatError(ExitCodeException):\n                                            \n\n    exit_code = ExitCode.input_file", "func_code_string": "class UnsupportedImageFormatError(ExitCodeException):\n                                            \n\n    exit_code = ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "DpiError", "whole_func_string": "class DpiError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.input_file", "func_code_string": "class DpiError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "OutputFileAccessError", "whole_func_string": "class OutputFileAccessError(ExitCodeException):\n                                                      \n\n    exit_code = ExitCode.file_access_error", "func_code_string": "class OutputFileAccessError(ExitCodeException):\n                                                      \n\n    exit_code = ExitCode.file_access_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "PriorOcrFoundError", "whole_func_string": "class PriorOcrFoundError(ExitCodeException):\n                                    \n\n    exit_code = ExitCode.already_done_ocr", "func_code_string": "class PriorOcrFoundError(ExitCodeException):\n                                    \n\n    exit_code = ExitCode.already_done_ocr", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "InputFileError", "whole_func_string": "class InputFileError(ExitCodeException):\n                                                 \n\n    exit_code = ExitCode.input_file", "func_code_string": "class InputFileError(ExitCodeException):\n                                                 \n\n    exit_code = ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "SubprocessOutputError", "whole_func_string": "class SubprocessOutputError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.child_process_error", "func_code_string": "class SubprocessOutputError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "EncryptedPdfError", "whole_func_string": "class EncryptedPdfError(ExitCodeException):\n                                 \n\n    exit_code = ExitCode.encrypted_pdf\n    message = dedent(\n        \"\"\"\\\n        Input PDF is encrypted. The encryption must be removed to\n        perform OCR.\n\n        For information about this PDF's security use\n            qpdf --show-encryption infilename\n\n        You can remove the encryption using\n            qpdf --decrypt [--password=[password]] infilename\n        \"\"\"\n    )", "func_code_string": "class EncryptedPdfError(ExitCodeException):\n                                 \n\n    exit_code = ExitCode.encrypted_pdf\n    message = dedent(\n        \"\"\"\\\n        Input PDF is encrypted. The encryption must be removed to\n        perform OCR.\n\n        For information about this PDF's security use\n            qpdf --show-encryption infilename\n\n        You can remove the encryption using\n            qpdf --decrypt [--password=[password]] infilename\n        \"\"\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "TesseractConfigError", "whole_func_string": "class TesseractConfigError(ExitCodeException):\n                                           \n\n    exit_code = ExitCode.invalid_config\n    message = \"Error occurred while parsing a Tesseract configuration file\"", "func_code_string": "class TesseractConfigError(ExitCodeException):\n                                           \n\n    exit_code = ExitCode.invalid_config\n    message = \"Error occurred while parsing a Tesseract configuration file\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "DigitalSignatureError", "whole_func_string": "class DigitalSignatureError(InputFileError):\n                                      \n\n    message = dedent(\n        \"\"\"\\\n        Input PDF has a digital signature. OCR would alter the document,\n        invalidating the signature.\n        \"\"\"\n    )", "func_code_string": "class DigitalSignatureError(InputFileError):\n                                      \n\n    message = dedent(\n        \"\"\"\\\n        Input PDF has a digital signature. OCR would alter the document,\n        invalidating the signature.\n        \"\"\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "TaggedPDFError", "whole_func_string": "class TaggedPDFError(InputFileError):\n                        \n\n    message = dedent(\n        \"\"\"\\\n        This PDF is marked as a Tagged PDF. This often indicates\n        that the PDF was generated from an office document and does\n        not need OCR. Use --force-ocr, --skip-text or --redo-ocr to\n        override this error.\n        \"\"\"\n    )", "func_code_string": "class TaggedPDFError(InputFileError):\n                        \n\n    message = dedent(\n        \"\"\"\\\n        This PDF is marked as a Tagged PDF. This often indicates\n        that the PDF was generated from an office document and does\n        not need OCR. Use --force-ocr, --skip-text or --redo-ocr to\n        override this error.\n        \"\"\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "ColorConversionNeededError", "whole_func_string": "class ColorConversionNeededError(BadArgsError):\n                                     \n\n    message = dedent(\n        \"\"\"\\\n        The input PDF has an unusual color space. Use\n        --color-conversion-strategy to convert to a common color space\n        such as RGB, or use --output-type pdf to skip PDF/A conversion\n        and retain the original color space.\n        \"\"\"\n    )", "func_code_string": "class ColorConversionNeededError(BadArgsError):\n                                     \n\n    message = dedent(\n        \"\"\"\\\n        The input PDF has an unusual color space. Use\n        --color-conversion-strategy to convert to a common color space\n        such as RGB, or use --output-type pdf to skip PDF/A conversion\n        and retain the original color space.\n        \"\"\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_code_string": "def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_annots.py", "func_name": "remove_broken_goto_annotations", "whole_func_string": "def remove_broken_goto_annotations(pdf: Pdf) -> bool:\n           \n    modified = False\n\n                                               \n    if Name.Names not in pdf.Root:\n        return modified\n    if Name.Dests not in pdf.Root[Name.Names]:\n        return modified\n\n    dests = pdf.Root[Name.Names][Name.Dests]\n    if not isinstance(dests, Dictionary):\n        return modified\n    nametree = NameTree(dests)\n\n                                            \n    names = set(k for k in nametree.keys())\n\n    for n, page in enumerate(pdf.pages):\n        if Name.Annots not in page:\n            continue\n        for annot in page[Name.Annots]:\n            if not isinstance(annot, Dictionary):\n                continue\n            if Name.A not in annot or Name.D not in annot[Name.A]:\n                continue\n                                                                       \n            named_destination = str(annot[Name.A][Name.D])\n            if named_destination not in names:\n                                                                            \n                                                                               \n                                                \n                log.warning(\n                    f\"Disabling a hyperlink annotation on page {n + 1} to a \"\n                    \"non-existent named destination \"\n                    f\"{named_destination}.\"\n                )\n                del annot[Name.A][Name.D]\n                modified = True\n\n    return modified", "func_code_string": "def remove_broken_goto_annotations(pdf: Pdf) -> bool:\n           \n    modified = False\n\n                                               \n    if Name.Names not in pdf.Root:\n        return modified\n    if Name.Dests not in pdf.Root[Name.Names]:\n        return modified\n\n    dests = pdf.Root[Name.Names][Name.Dests]\n    if not isinstance(dests, Dictionary):\n        return modified\n    nametree = NameTree(dests)\n\n                                            \n    names = set(k for k in nametree.keys())\n\n    for n, page in enumerate(pdf.pages):\n        if Name.Annots not in page:\n            continue\n        for annot in page[Name.Annots]:\n            if not isinstance(annot, Dictionary):\n                continue\n            if Name.A not in annot or Name.D not in annot[Name.A]:\n                continue\n                                                                       \n            named_destination = str(annot[Name.A][Name.D])\n            if named_destination not in names:\n                                                                            \n                                                                               \n                                                \n                log.warning(\n                    f\"Disabling a hyperlink annotation on page {n + 1} to a \"\n                    \"non-existent named destination \"\n                    f\"{named_destination}.\"\n                )\n                del annot[Name.A][Name.D]\n                modified = True\n\n    return modified", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "OcrmypdfPluginManager", "whole_func_string": "class OcrmypdfPluginManager(pluggy.PluginManager):\n           \n\n    def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n\n    def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state\n\n    def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )\n\n    def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_code_string": "class OcrmypdfPluginManager(pluggy.PluginManager):\n           \n\n    def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n\n    def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state\n\n    def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )\n\n    def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "get_plugin_manager", "whole_func_string": "def get_plugin_manager(\n    plugins: Sequence[str | Path] | None = None, builtins=True\n) -> OcrmypdfPluginManager:\n    return OcrmypdfPluginManager(\n        project_name='ocrmypdf',\n        plugins=plugins if plugins is not None else [],\n        builtins=builtins,\n    )", "func_code_string": "def get_plugin_manager(\n    plugins: Sequence[str | Path] | None = None, builtins=True\n) -> OcrmypdfPluginManager:\n    return OcrmypdfPluginManager(\n        project_name='ocrmypdf',\n        plugins=plugins if plugins is not None else [],\n        builtins=builtins,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "get_parser_options_plugins", "whole_func_string": "def get_parser_options_plugins(\n    args: Sequence[str],\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\n    pre_options, _unused = plugins_only_parser.parse_known_args(args=args)\n    plugin_manager = get_plugin_manager(pre_options.plugins)\n\n    parser = get_parser()\n    plugin_manager.hook.initialize(                             \n        plugin_manager=plugin_manager\n    )\n    plugin_manager.hook.add_options(parser=parser)                             \n\n    options = parser.parse_args(args=args)\n    return parser, options, plugin_manager", "func_code_string": "def get_parser_options_plugins(\n    args: Sequence[str],\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\n    pre_options, _unused = plugins_only_parser.parse_known_args(args=args)\n    plugin_manager = get_plugin_manager(pre_options.plugins)\n\n    parser = get_parser()\n    plugin_manager.hook.initialize(                             \n        plugin_manager=plugin_manager\n    )\n    plugin_manager.hook.add_options(parser=parser)                             \n\n    options = parser.parse_args(args=args)\n    return parser, options, plugin_manager", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()", "func_code_string": "def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "__getstate__", "whole_func_string": "def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state", "func_code_string": "def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "__setstate__", "whole_func_string": "def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )", "func_code_string": "def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "setup_plugins", "whole_func_string": "def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_code_string": "def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "PdfContext", "whole_func_string": "class PdfContext:\n                                                                 \n\n    options: Namespace                                                   \n    origin: Path                                             \n    pdfinfo: PdfInfo                                \n    plugin_manager: PluginManager                                                  \n\n    def __init__(\n        self,\n        options: Namespace,\n        work_folder: Path,\n        origin: Path,\n        pdfinfo: PdfInfo,\n        plugin_manager,\n    ):\n        self.options = options\n        self.work_folder = work_folder\n        self.origin = origin\n        self.pdfinfo = pdfinfo\n        self.plugin_manager = plugin_manager\n\n    def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name\n\n    def get_page_contexts(self) -> Iterator[PageContext]:\n                                                   \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield PageContext(self, n)\n\n    def get_page_context_args(self) -> Iterator[tuple[PageContext]]:\n                                                                                        \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield (PageContext(self, n),)", "func_code_string": "class PdfContext:\n                                                                 \n\n    options: Namespace                                                   \n    origin: Path                                             \n    pdfinfo: PdfInfo                                \n    plugin_manager: PluginManager                                                  \n\n    def __init__(\n        self,\n        options: Namespace,\n        work_folder: Path,\n        origin: Path,\n        pdfinfo: PdfInfo,\n        plugin_manager,\n    ):\n        self.options = options\n        self.work_folder = work_folder\n        self.origin = origin\n        self.pdfinfo = pdfinfo\n        self.plugin_manager = plugin_manager\n\n    def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name\n\n    def get_page_contexts(self) -> Iterator[PageContext]:\n                                                   \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield PageContext(self, n)\n\n    def get_page_context_args(self) -> Iterator[tuple[PageContext]]:\n                                                                                        \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield (PageContext(self, n),)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "PageContext", "whole_func_string": "class PageContext:\n           \n\n    options: Namespace                                                   \n    origin: Path                                             \n    pageno: int                                   \n    pageinfo: PageInfo                              \n    plugin_manager: PluginManager                                                  \n\n    def __init__(self, pdf_context: PdfContext, pageno):\n        self.work_folder = pdf_context.work_folder\n        self.origin = pdf_context.origin\n        self.options = pdf_context.options\n        self.pageno = pageno\n        self.pageinfo = pdf_context.pdfinfo[pageno]\n        self.plugin_manager = pdf_context.plugin_manager\n\n    def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / f\"{(self.pageno + 1):06d}_{name}\"\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n\n        state['options'] = copy(self.options)\n        if not isinstance(state['options'].input_file, str | bytes | os.PathLike):\n            state['options'].input_file = 'stream'\n        if not isinstance(state['options'].output_file, str | bytes | os.PathLike):\n            state['options'].output_file = 'stream'\n        return state", "func_code_string": "class PageContext:\n           \n\n    options: Namespace                                                   \n    origin: Path                                             \n    pageno: int                                   \n    pageinfo: PageInfo                              \n    plugin_manager: PluginManager                                                  \n\n    def __init__(self, pdf_context: PdfContext, pageno):\n        self.work_folder = pdf_context.work_folder\n        self.origin = pdf_context.origin\n        self.options = pdf_context.options\n        self.pageno = pageno\n        self.pageinfo = pdf_context.pdfinfo[pageno]\n        self.plugin_manager = pdf_context.plugin_manager\n\n    def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / f\"{(self.pageno + 1):06d}_{name}\"\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n\n        state['options'] = copy(self.options)\n        if not isinstance(state['options'].input_file, str | bytes | os.PathLike):\n            state['options'].input_file = 'stream'\n        if not isinstance(state['options'].output_file, str | bytes | os.PathLike):\n            state['options'].output_file = 'stream'\n        return state", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        options: Namespace,\n        work_folder: Path,\n        origin: Path,\n        pdfinfo: PdfInfo,\n        plugin_manager,\n    ):\n        self.options = options\n        self.work_folder = work_folder\n        self.origin = origin\n        self.pdfinfo = pdfinfo\n        self.plugin_manager = plugin_manager", "func_code_string": "def __init__(\n        self,\n        options: Namespace,\n        work_folder: Path,\n        origin: Path,\n        pdfinfo: PdfInfo,\n        plugin_manager,\n    ):\n        self.options = options\n        self.work_folder = work_folder\n        self.origin = origin\n        self.pdfinfo = pdfinfo\n        self.plugin_manager = plugin_manager", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "get_path", "whole_func_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name", "func_code_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "get_page_contexts", "whole_func_string": "def get_page_contexts(self) -> Iterator[PageContext]:\n                                                   \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield PageContext(self, n)", "func_code_string": "def get_page_contexts(self) -> Iterator[PageContext]:\n                                                   \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield PageContext(self, n)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "get_page_context_args", "whole_func_string": "def get_page_context_args(self) -> Iterator[tuple[PageContext]]:\n                                                                                        \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield (PageContext(self, n),)", "func_code_string": "def get_page_context_args(self) -> Iterator[tuple[PageContext]]:\n                                                                                        \n        npages = len(self.pdfinfo)\n        for n in range(npages):\n            yield (PageContext(self, n),)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "__init__", "whole_func_string": "def __init__(self, pdf_context: PdfContext, pageno):\n        self.work_folder = pdf_context.work_folder\n        self.origin = pdf_context.origin\n        self.options = pdf_context.options\n        self.pageno = pageno\n        self.pageinfo = pdf_context.pdfinfo[pageno]\n        self.plugin_manager = pdf_context.plugin_manager", "func_code_string": "def __init__(self, pdf_context: PdfContext, pageno):\n        self.work_folder = pdf_context.work_folder\n        self.origin = pdf_context.origin\n        self.options = pdf_context.options\n        self.pageno = pageno\n        self.pageinfo = pdf_context.pdfinfo[pageno]\n        self.plugin_manager = pdf_context.plugin_manager", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "get_path", "whole_func_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / f\"{(self.pageno + 1):06d}_{name}\"", "func_code_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / f\"{(self.pageno + 1):06d}_{name}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "__getstate__", "whole_func_string": "def __getstate__(self):\n        state = self.__dict__.copy()\n\n        state['options'] = copy(self.options)\n        if not isinstance(state['options'].input_file, str | bytes | os.PathLike):\n            state['options'].input_file = 'stream'\n        if not isinstance(state['options'].output_file, str | bytes | os.PathLike):\n            state['options'].output_file = 'stream'\n        return state", "func_code_string": "def __getstate__(self):\n        state = self.__dict__.copy()\n\n        state['options'] = copy(self.options)\n        if not isinstance(state['options'].input_file, str | bytes | os.PathLike):\n            state['options'].input_file = 'stream'\n        if not isinstance(state['options'].output_file, str | bytes | os.PathLike):\n            state['options'].output_file = 'stream'\n        return state", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfa.py", "func_name": "_postscript_objdef", "whole_func_string": "def _postscript_objdef(\n    alias: str,\n    dictionary: dict[str, str],\n    *,\n    stream_name: str | None = None,\n    stream_data: bytes | None = None,\n) -> Iterator[str]:\n    assert (stream_name is None) == (stream_data is None)\n\n    objtype = '/stream' if stream_name else '/dict'\n\n    if stream_name:\n        assert stream_data is not None\n        a85_data = base64.a85encode(stream_data, adobe=True).decode('ascii')\n        yield f'{stream_name} ' + a85_data\n        yield 'def'\n\n    if alias != '{Catalog}':                               \n        yield f'[/_objdef {alias} /type {objtype} /OBJ pdfmark'\n\n    yield f'[{alias} <<'\n    for key, val in dictionary.items():\n        yield f'  {key} {val}'\n    yield '>> /PUT pdfmark'\n\n    if stream_name:\n        yield f'[{alias} {stream_name[1:]} /PUT pdfmark'", "func_code_string": "def _postscript_objdef(\n    alias: str,\n    dictionary: dict[str, str],\n    *,\n    stream_name: str | None = None,\n    stream_data: bytes | None = None,\n) -> Iterator[str]:\n    assert (stream_name is None) == (stream_data is None)\n\n    objtype = '/stream' if stream_name else '/dict'\n\n    if stream_name:\n        assert stream_data is not None\n        a85_data = base64.a85encode(stream_data, adobe=True).decode('ascii')\n        yield f'{stream_name} ' + a85_data\n        yield 'def'\n\n    if alias != '{Catalog}':                               \n        yield f'[/_objdef {alias} /type {objtype} /OBJ pdfmark'\n\n    yield f'[{alias} <<'\n    for key, val in dictionary.items():\n        yield f'  {key} {val}'\n    yield '>> /PUT pdfmark'\n\n    if stream_name:\n        yield f'[{alias} {stream_name[1:]} /PUT pdfmark'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfa.py", "func_name": "_make_postscript", "whole_func_string": "def _make_postscript(icc_name: str, icc_data: bytes, colors: int) -> Iterator[str]:\n    yield '%!'\n    yield from _postscript_objdef(\n        '{icc_PDFA}',                   \n        {'/N': str(colors)},\n        stream_name='/ICCProfile',\n        stream_data=icc_data,\n    )\n    yield ''\n    yield from _postscript_objdef(\n        '{OutputIntent_PDFA}',\n        {\n            '/Type': '/OutputIntent',\n            '/S': '/GTS_PDFA1',\n            '/DestOutputProfile': '{icc_PDFA}',\n            '/OutputConditionIdentifier': f'({icc_name})',                 \n        },\n    )\n    yield ''\n    yield from _postscript_objdef(\n        '{Catalog}', {'/OutputIntents': '[ {OutputIntent_PDFA} ]'}\n    )", "func_code_string": "def _make_postscript(icc_name: str, icc_data: bytes, colors: int) -> Iterator[str]:\n    yield '%!'\n    yield from _postscript_objdef(\n        '{icc_PDFA}',                   \n        {'/N': str(colors)},\n        stream_name='/ICCProfile',\n        stream_data=icc_data,\n    )\n    yield ''\n    yield from _postscript_objdef(\n        '{OutputIntent_PDFA}',\n        {\n            '/Type': '/OutputIntent',\n            '/S': '/GTS_PDFA1',\n            '/DestOutputProfile': '{icc_PDFA}',\n            '/OutputConditionIdentifier': f'({icc_name})',                 \n        },\n    )\n    yield ''\n    yield from _postscript_objdef(\n        '{Catalog}', {'/OutputIntents': '[ {OutputIntent_PDFA} ]'}\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfa.py", "func_name": "generate_pdfa_ps", "whole_func_string": "def generate_pdfa_ps(target_filename: Path, icc: str = 'sRGB'):\n           \n    if icc != 'sRGB':\n        raise NotImplementedError(\"Only supporting sRGB\")\n\n    bytes_icc_profile = (\n        package_files('ocrmypdf.data') / SRGB_ICC_PROFILE_NAME\n    ).read_bytes()\n    postscript = '\\n'.join(_make_postscript(icc, bytes_icc_profile, 3))\n\n                                                                        \n                                                \n    Path(target_filename).write_text(postscript, encoding='ascii')\n    return target_filename", "func_code_string": "def generate_pdfa_ps(target_filename: Path, icc: str = 'sRGB'):\n           \n    if icc != 'sRGB':\n        raise NotImplementedError(\"Only supporting sRGB\")\n\n    bytes_icc_profile = (\n        package_files('ocrmypdf.data') / SRGB_ICC_PROFILE_NAME\n    ).read_bytes()\n    postscript = '\\n'.join(_make_postscript(icc, bytes_icc_profile, 3))\n\n                                                                        \n                                                \n    Path(target_filename).write_text(postscript, encoding='ascii')\n    return target_filename", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfa.py", "func_name": "file_claims_pdfa", "whole_func_string": "def file_claims_pdfa(filename: Path):\n           \n    with pikepdf.open(filename) as pdf:\n        pdfmeta = pdf.open_metadata()\n        if not pdfmeta.pdfa_status:\n            return {\n                'pass': False,\n                'output': 'pdf',\n                'conformance': 'No PDF/A metadata in XMP',\n            }\n        valid_part_conforms = {'1A', '1B', '2A', '2B', '2U', '3A', '3B', '3U'}\n        conformance = f'PDF/A-{pdfmeta.pdfa_status}'\n        pdfa_dict: dict[str, str | bool] = {}\n        if pdfmeta.pdfa_status in valid_part_conforms:\n            pdfa_dict['pass'] = True\n            pdfa_dict['output'] = 'pdfa'\n        pdfa_dict['conformance'] = conformance\n    return pdfa_dict", "func_code_string": "def file_claims_pdfa(filename: Path):\n           \n    with pikepdf.open(filename) as pdf:\n        pdfmeta = pdf.open_metadata()\n        if not pdfmeta.pdfa_status:\n            return {\n                'pass': False,\n                'output': 'pdf',\n                'conformance': 'No PDF/A metadata in XMP',\n            }\n        valid_part_conforms = {'1A', '1B', '2A', '2B', '2U', '3A', '3B', '3U'}\n        conformance = f'PDF/A-{pdfmeta.pdfa_status}'\n        pdfa_dict: dict[str, str | bool] = {}\n        if pdfmeta.pdfa_status in valid_part_conforms:\n            pdfa_dict['pass'] = True\n            pdfa_dict['output'] = 'pdfa'\n        pdfa_dict['conformance'] = conformance\n    return pdfa_dict", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/quality.py", "func_name": "OcrQualityDictionary", "whole_func_string": "class OcrQualityDictionary:\n                                                             \n\n    def __init__(self, *, wordlist: Iterable[str]):\n                   \n        self.dictionary = set(wordlist)\n\n    def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_code_string": "class OcrQualityDictionary:\n                                                             \n\n    def __init__(self, *, wordlist: Iterable[str]):\n                   \n        self.dictionary = set(wordlist)\n\n    def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/quality.py", "func_name": "__init__", "whole_func_string": "def __init__(self, *, wordlist: Iterable[str]):\n                   \n        self.dictionary = set(wordlist)", "func_code_string": "def __init__(self, *, wordlist: Iterable[str]):\n                   \n        self.dictionary = set(wordlist)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/quality.py", "func_name": "measure_words_matched", "whole_func_string": "def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_code_string": "def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/languages.py", "func_name": "ISOCodeData", "whole_func_string": "class ISOCodeData(NamedTuple):\n                                         \n\n    alt: str\n    alpha_2: str\n    english: str\n    french: str", "func_code_string": "class ISOCodeData(NamedTuple):\n                                         \n\n    alt: str\n    alpha_2: str\n    english: str\n    french: str", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/languages.py", "func_name": "iso_639_2_from_3", "whole_func_string": "def iso_639_2_from_3(iso3: str) -> str:\n                                                   \n    if iso3 in ISO_639_3:\n        return ISO_639_3[iso3].alpha_2\n    else:\n        return \"\"", "func_code_string": "def iso_639_2_from_3(iso3: str) -> str:\n                                                   \n    if iso3 in ISO_639_3:\n        return ISO_639_3[iso3].alpha_2\n    else:\n        return \"\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/__main__.py", "func_name": "sigbus", "whole_func_string": "def sigbus(*args):\n           \n    raise InputFileError(\"Lost access to the input file\")", "func_code_string": "def sigbus(*args):\n           \n    raise InputFileError(\"Lost access to the input file\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/__main__.py", "func_name": "run", "whole_func_string": "def run(args=None):\n                                                  \n    _parser, options, plugin_manager = get_parser_options_plugins(args=args)\n\n    with suppress(AttributeError, PermissionError):\n        os.nice(5)\n\n    verbosity = options.verbose\n    if not os.isatty(sys.stderr.fileno()):\n        options.progress_bar = False\n    if options.quiet:\n        verbosity = Verbosity.quiet\n        options.progress_bar = False\n    configure_logging(\n        verbosity,\n        progress_bar_friendly=options.progress_bar,\n        manage_root_logger=True,\n        plugin_manager=plugin_manager,\n    )\n    log.debug('ocrmypdf %s', __version__)\n    try:\n        check_options(options, plugin_manager)\n    except ValueError as e:\n        log.error(e)\n        return ExitCode.bad_args\n    except BadArgsError as e:\n        log.error(e)\n        return e.exit_code\n    except MissingDependencyError as e:\n        log.error(e)\n        return ExitCode.missing_dependency\n\n    with suppress(AttributeError, OSError):\n        signal.signal(signal.SIGBUS, sigbus)\n\n    result = run_pipeline_cli(options=options, plugin_manager=plugin_manager)\n    return result", "func_code_string": "def run(args=None):\n                                                  \n    _parser, options, plugin_manager = get_parser_options_plugins(args=args)\n\n    with suppress(AttributeError, PermissionError):\n        os.nice(5)\n\n    verbosity = options.verbose\n    if not os.isatty(sys.stderr.fileno()):\n        options.progress_bar = False\n    if options.quiet:\n        verbosity = Verbosity.quiet\n        options.progress_bar = False\n    configure_logging(\n        verbosity,\n        progress_bar_friendly=options.progress_bar,\n        manage_root_logger=True,\n        plugin_manager=plugin_manager,\n    )\n    log.debug('ocrmypdf %s', __version__)\n    try:\n        check_options(options, plugin_manager)\n    except ValueError as e:\n        log.error(e)\n        return ExitCode.bad_args\n    except BadArgsError as e:\n        log.error(e)\n        return e.exit_code\n    except MissingDependencyError as e:\n        log.error(e)\n        return ExitCode.missing_dependency\n\n    with suppress(AttributeError, OSError):\n        signal.signal(signal.SIGBUS, sigbus)\n\n    result = run_pipeline_cli(options=options, plugin_manager=plugin_manager)\n    return result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "pdfsimplefont__init__", "whole_func_string": "def pdfsimplefont__init__(\n    self,\n    descriptor: Mapping[str, Any],\n    widths: FontWidthDict,\n    spec: Mapping[str, Any],\n) -> None:\n           \n                                                    \n                                                      \n                      \n    original_pdfsimplefont_init(self, descriptor, widths, spec)\n    if not self.unicode_map and 'Encoding' not in spec:\n        self.cid2unicode = {}\n    return", "func_code_string": "def pdfsimplefont__init__(\n    self,\n    descriptor: Mapping[str, Any],\n    widths: FontWidthDict,\n    spec: Mapping[str, Any],\n) -> None:\n           \n                                                    \n                                                      \n                      \n    original_pdfsimplefont_init(self, descriptor, widths, spec)\n    if not self.unicode_map and 'Encoding' not in spec:\n        self.cid2unicode = {}\n    return", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "pdftype3font__pscript5_get_height", "whole_func_string": "def pdftype3font__pscript5_get_height(self):\n           \n    h = self.bbox[3] - self.bbox[1]\n    if h == 0:\n        h = self.ascent - self.descent\n    return h * copysign(1.0, self.vscale)", "func_code_string": "def pdftype3font__pscript5_get_height(self):\n           \n    h = self.bbox[3] - self.bbox[1]\n    if h == 0:\n        h = self.ascent - self.descent\n    return h * copysign(1.0, self.vscale)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "pdftype3font__pscript5_get_descent", "whole_func_string": "def pdftype3font__pscript5_get_descent(self):\n           \n    return self.descent * copysign(1.0, self.vscale)", "func_code_string": "def pdftype3font__pscript5_get_descent(self):\n           \n    return self.descent * copysign(1.0, self.vscale)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "pdftype3font__pscript5_get_ascent", "whole_func_string": "def pdftype3font__pscript5_get_ascent(self):\n           \n    return self.ascent * copysign(1.0, self.vscale)", "func_code_string": "def pdftype3font__pscript5_get_ascent(self):\n           \n    return self.ascent * copysign(1.0, self.vscale)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "_is_undefined_char", "whole_func_string": "def _is_undefined_char(s: str) -> bool:\n                                                      \n    return s.startswith('(cid:') and s.endswith(')')", "func_code_string": "def _is_undefined_char(s: str) -> bool:\n                                                      \n    return s.startswith('(cid:') and s.endswith(')')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "LTStateAwareChar", "whole_func_string": "class LTStateAwareChar(LTChar):\n                                                                               \n\n    __slots__ = (\n        'rendermode',\n        '_text',\n        'matrix',\n        'fontname',\n        'adv',\n        'upright',\n        'size',\n        'width',\n        'height',\n        'bbox',\n        'x0',\n        'x1',\n        'y0',\n        'y1',\n    )\n\n    def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render\n\n    def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode\n\n    def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text\n\n    def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_code_string": "class LTStateAwareChar(LTChar):\n                                                                               \n\n    __slots__ = (\n        'rendermode',\n        '_text',\n        'matrix',\n        'fontname',\n        'adv',\n        'upright',\n        'size',\n        'width',\n        'height',\n        'bbox',\n        'x0',\n        'x1',\n        'y0',\n        'y1',\n    )\n\n    def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render\n\n    def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode\n\n    def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text\n\n    def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "TextPositionTracker", "whole_func_string": "class TextPositionTracker(PDFLayoutAnalyzer):\n                                                                        \n\n    textstate: PDFTextState\n\n    def __init__(\n        self,\n        rsrcmgr: PDFResourceManager,\n        pageno: int = 1,\n        laparams: LAParams | None = None,\n    ):\n                                             \n        super().__init__(rsrcmgr, pageno, laparams)\n        self.result: LTPage | None = None\n\n    def begin_page(self, page: PDFPage, ctm: Matrix) -> None:\n                                         \n        super().begin_page(page, ctm)\n        self.cur_item = LTPage(self.pageno, page.mediabox)\n\n    def end_page(self, page: PDFPage) -> None:\n                                       \n        assert not self._stack, str(len(self._stack))\n        assert isinstance(self.cur_item, LTPage), str(type(self.cur_item))\n        if self.laparams is not None:\n            self.cur_item.analyze(self.laparams)\n        self.pageno += 1\n        self.receive_layout(self.cur_item)\n\n    def render_string(\n        self,\n        textstate: PDFTextState,\n        seq: PDFTextSeq,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> None:\n                                                                    \n        self.textstate = textstate.copy()\n        super().render_string(self.textstate, seq, ncs, graphicstate)\n\n    def render_char(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        cid: int,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> float:\n                                                                  \n        try:\n            text = font.to_unichr(cid)\n            assert isinstance(text, str), str(type(text))\n        except PDFUnicodeNotDefined:\n            text = self.handle_undefined_char(font, cid)\n        textwidth = font.char_width(cid)\n        textdisp = font.char_disp(cid)\n        item = LTStateAwareChar(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n            self.textstate,\n        )\n        self.cur_item.add(item)\n        return item.adv\n\n    def receive_layout(self, ltpage: LTPage) -> None:\n                                     \n        self.result = ltpage\n\n    def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_code_string": "class TextPositionTracker(PDFLayoutAnalyzer):\n                                                                        \n\n    textstate: PDFTextState\n\n    def __init__(\n        self,\n        rsrcmgr: PDFResourceManager,\n        pageno: int = 1,\n        laparams: LAParams | None = None,\n    ):\n                                             \n        super().__init__(rsrcmgr, pageno, laparams)\n        self.result: LTPage | None = None\n\n    def begin_page(self, page: PDFPage, ctm: Matrix) -> None:\n                                         \n        super().begin_page(page, ctm)\n        self.cur_item = LTPage(self.pageno, page.mediabox)\n\n    def end_page(self, page: PDFPage) -> None:\n                                       \n        assert not self._stack, str(len(self._stack))\n        assert isinstance(self.cur_item, LTPage), str(type(self.cur_item))\n        if self.laparams is not None:\n            self.cur_item.analyze(self.laparams)\n        self.pageno += 1\n        self.receive_layout(self.cur_item)\n\n    def render_string(\n        self,\n        textstate: PDFTextState,\n        seq: PDFTextSeq,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> None:\n                                                                    \n        self.textstate = textstate.copy()\n        super().render_string(self.textstate, seq, ncs, graphicstate)\n\n    def render_char(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        cid: int,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> float:\n                                                                  \n        try:\n            text = font.to_unichr(cid)\n            assert isinstance(text, str), str(type(text))\n        except PDFUnicodeNotDefined:\n            text = self.handle_undefined_char(font, cid)\n        textwidth = font.char_width(cid)\n        textdisp = font.char_disp(cid)\n        item = LTStateAwareChar(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n            self.textstate,\n        )\n        self.cur_item.add(item)\n        return item.adv\n\n    def receive_layout(self, ltpage: LTPage) -> None:\n                                     \n        self.result = ltpage\n\n    def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "patch_pdfminer", "whole_func_string": "def patch_pdfminer(pscript5_mode: bool):\n                                                                             \n    if pscript5_mode:\n        with patch.multiple(\n            'pdfminer.pdffont.PDFType3Font',\n            spec=True,\n            get_ascent=pdftype3font__pscript5_get_ascent,\n            get_descent=pdftype3font__pscript5_get_descent,\n            get_height=pdftype3font__pscript5_get_height,\n        ):\n            yield\n    else:\n        yield", "func_code_string": "def patch_pdfminer(pscript5_mode: bool):\n                                                                             \n    if pscript5_mode:\n        with patch.multiple(\n            'pdfminer.pdffont.PDFType3Font',\n            spec=True,\n            get_ascent=pdftype3font__pscript5_get_ascent,\n            get_descent=pdftype3font__pscript5_get_descent,\n            get_height=pdftype3font__pscript5_get_height,\n        ):\n            yield\n    else:\n        yield", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_page_analysis", "whole_func_string": "def get_page_analysis(\n    infile: PathLike, pageno: int, pscript5_mode: bool\n) -> LTPage | None:\n                                                 \n    rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n    disable_boxes_flow = None\n    dev = TextPositionTracker(\n        rman,\n        laparams=LAParams(\n            all_texts=True, detect_vertical=True, boxes_flow=disable_boxes_flow\n        ),\n    )\n    interp = pdfminer.pdfinterp.PDFPageInterpreter(rman, dev)\n\n    with patch_pdfminer(pscript5_mode):\n        try:\n            with Path(infile).open('rb') as f:\n                page_iter = PDFPage.get_pages(f, pagenos=[pageno], maxpages=0)\n                page = next(page_iter, None)\n                if page is None:\n                    raise InputFileError(\n                        f\"pdfminer could not process page {pageno} (counting from 0).\"\n                    )\n                interp.process_page(page)\n        except PDFTextExtractionNotAllowed as e:\n            raise EncryptedPdfError() from e\n\n    return dev.get_result()", "func_code_string": "def get_page_analysis(\n    infile: PathLike, pageno: int, pscript5_mode: bool\n) -> LTPage | None:\n                                                 \n    rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n    disable_boxes_flow = None\n    dev = TextPositionTracker(\n        rman,\n        laparams=LAParams(\n            all_texts=True, detect_vertical=True, boxes_flow=disable_boxes_flow\n        ),\n    )\n    interp = pdfminer.pdfinterp.PDFPageInterpreter(rman, dev)\n\n    with patch_pdfminer(pscript5_mode):\n        try:\n            with Path(infile).open('rb') as f:\n                page_iter = PDFPage.get_pages(f, pagenos=[pageno], maxpages=0)\n                page = next(page_iter, None)\n                if page is None:\n                    raise InputFileError(\n                        f\"pdfminer could not process page {pageno} (counting from 0).\"\n                    )\n                interp.process_page(page)\n        except PDFTextExtractionNotAllowed as e:\n            raise EncryptedPdfError() from e\n\n    return dev.get_result()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "PdfMinerState", "whole_func_string": "class PdfMinerState:\n           \n\n    def __init__(self, infile: Path, pscript5_mode: bool) -> None:\n                   \n        self.infile = infile\n        self.rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n        self.disable_boxes_flow = None\n        self.page_iter = None\n        self.page_cache: list[PDFPage] = []\n        self.pscript5_mode = pscript5_mode\n        self.file = None\n\n    def __enter__(self):\n                                        \n        self.file = Path(self.infile).open('rb')\n        self.page_iter = PDFPage.get_pages(self.file)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True\n\n    def get_page_analysis(self, pageno: int):\n                                                     \n        while len(self.page_cache) <= pageno:\n            try:\n                self.page_cache.append(next(self.page_iter))\n            except StopIteration:\n                raise InputFileError(\n                    f\"pdfminer did not find page {pageno} in the input file.\"\n                )\n        page = self.page_cache[pageno]\n        if not page:\n            raise InputFileError(\n                f\"pdfminer could not process page {pageno} (counting from 0).\"\n            )\n        dev = TextPositionTracker(\n            self.rman,\n            laparams=LAParams(\n                all_texts=True, detect_vertical=True, boxes_flow=self.disable_boxes_flow\n            ),\n        )\n        interp = pdfminer.pdfinterp.PDFPageInterpreter(self.rman, dev)\n\n        with patch_pdfminer(self.pscript5_mode):\n            interp.process_page(page)\n\n        return dev.get_result()", "func_code_string": "class PdfMinerState:\n           \n\n    def __init__(self, infile: Path, pscript5_mode: bool) -> None:\n                   \n        self.infile = infile\n        self.rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n        self.disable_boxes_flow = None\n        self.page_iter = None\n        self.page_cache: list[PDFPage] = []\n        self.pscript5_mode = pscript5_mode\n        self.file = None\n\n    def __enter__(self):\n                                        \n        self.file = Path(self.infile).open('rb')\n        self.page_iter = PDFPage.get_pages(self.file)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True\n\n    def get_page_analysis(self, pageno: int):\n                                                     \n        while len(self.page_cache) <= pageno:\n            try:\n                self.page_cache.append(next(self.page_iter))\n            except StopIteration:\n                raise InputFileError(\n                    f\"pdfminer did not find page {pageno} in the input file.\"\n                )\n        page = self.page_cache[pageno]\n        if not page:\n            raise InputFileError(\n                f\"pdfminer could not process page {pageno} (counting from 0).\"\n            )\n        dev = TextPositionTracker(\n            self.rman,\n            laparams=LAParams(\n                all_texts=True, detect_vertical=True, boxes_flow=self.disable_boxes_flow\n            ),\n        )\n        interp = pdfminer.pdfinterp.PDFPageInterpreter(self.rman, dev)\n\n        with patch_pdfminer(self.pscript5_mode):\n            interp.process_page(page)\n\n        return dev.get_result()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_text_boxes", "whole_func_string": "def get_text_boxes(obj) -> Iterator[LTTextBox]:\n                                                          \n    for child in obj:\n        if isinstance(child, (LTTextBox)):\n            yield child\n        else:\n            try:\n                yield from get_text_boxes(child)\n            except TypeError:\n                continue", "func_code_string": "def get_text_boxes(obj) -> Iterator[LTTextBox]:\n                                                          \n    for child in obj:\n        if isinstance(child, (LTTextBox)):\n            yield child\n        else:\n            try:\n                yield from get_text_boxes(child)\n            except TypeError:\n                continue", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render", "func_code_string": "def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "is_compatible", "whole_func_string": "def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode", "func_code_string": "def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_text", "whole_func_string": "def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text", "func_code_string": "def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__repr__", "whole_func_string": "def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_code_string": "def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        rsrcmgr: PDFResourceManager,\n        pageno: int = 1,\n        laparams: LAParams | None = None,\n    ):\n                                             \n        super().__init__(rsrcmgr, pageno, laparams)\n        self.result: LTPage | None = None", "func_code_string": "def __init__(\n        self,\n        rsrcmgr: PDFResourceManager,\n        pageno: int = 1,\n        laparams: LAParams | None = None,\n    ):\n                                             \n        super().__init__(rsrcmgr, pageno, laparams)\n        self.result: LTPage | None = None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "begin_page", "whole_func_string": "def begin_page(self, page: PDFPage, ctm: Matrix) -> None:\n                                         \n        super().begin_page(page, ctm)\n        self.cur_item = LTPage(self.pageno, page.mediabox)", "func_code_string": "def begin_page(self, page: PDFPage, ctm: Matrix) -> None:\n                                         \n        super().begin_page(page, ctm)\n        self.cur_item = LTPage(self.pageno, page.mediabox)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "end_page", "whole_func_string": "def end_page(self, page: PDFPage) -> None:\n                                       \n        assert not self._stack, str(len(self._stack))\n        assert isinstance(self.cur_item, LTPage), str(type(self.cur_item))\n        if self.laparams is not None:\n            self.cur_item.analyze(self.laparams)\n        self.pageno += 1\n        self.receive_layout(self.cur_item)", "func_code_string": "def end_page(self, page: PDFPage) -> None:\n                                       \n        assert not self._stack, str(len(self._stack))\n        assert isinstance(self.cur_item, LTPage), str(type(self.cur_item))\n        if self.laparams is not None:\n            self.cur_item.analyze(self.laparams)\n        self.pageno += 1\n        self.receive_layout(self.cur_item)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "render_string", "whole_func_string": "def render_string(\n        self,\n        textstate: PDFTextState,\n        seq: PDFTextSeq,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> None:\n                                                                    \n        self.textstate = textstate.copy()\n        super().render_string(self.textstate, seq, ncs, graphicstate)", "func_code_string": "def render_string(\n        self,\n        textstate: PDFTextState,\n        seq: PDFTextSeq,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> None:\n                                                                    \n        self.textstate = textstate.copy()\n        super().render_string(self.textstate, seq, ncs, graphicstate)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "render_char", "whole_func_string": "def render_char(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        cid: int,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> float:\n                                                                  \n        try:\n            text = font.to_unichr(cid)\n            assert isinstance(text, str), str(type(text))\n        except PDFUnicodeNotDefined:\n            text = self.handle_undefined_char(font, cid)\n        textwidth = font.char_width(cid)\n        textdisp = font.char_disp(cid)\n        item = LTStateAwareChar(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n            self.textstate,\n        )\n        self.cur_item.add(item)\n        return item.adv", "func_code_string": "def render_char(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        cid: int,\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n    ) -> float:\n                                                                  \n        try:\n            text = font.to_unichr(cid)\n            assert isinstance(text, str), str(type(text))\n        except PDFUnicodeNotDefined:\n            text = self.handle_undefined_char(font, cid)\n        textwidth = font.char_width(cid)\n        textdisp = font.char_disp(cid)\n        item = LTStateAwareChar(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n            self.textstate,\n        )\n        self.cur_item.add(item)\n        return item.adv", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "receive_layout", "whole_func_string": "def receive_layout(self, ltpage: LTPage) -> None:\n                                     \n        self.result = ltpage", "func_code_string": "def receive_layout(self, ltpage: LTPage) -> None:\n                                     \n        self.result = ltpage", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_result", "whole_func_string": "def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_code_string": "def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__init__", "whole_func_string": "def __init__(self, infile: Path, pscript5_mode: bool) -> None:\n                   \n        self.infile = infile\n        self.rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n        self.disable_boxes_flow = None\n        self.page_iter = None\n        self.page_cache: list[PDFPage] = []\n        self.pscript5_mode = pscript5_mode\n        self.file = None", "func_code_string": "def __init__(self, infile: Path, pscript5_mode: bool) -> None:\n                   \n        self.infile = infile\n        self.rman = pdfminer.pdfinterp.PDFResourceManager(caching=True)\n        self.disable_boxes_flow = None\n        self.page_iter = None\n        self.page_cache: list[PDFPage] = []\n        self.pscript5_mode = pscript5_mode\n        self.file = None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__enter__", "whole_func_string": "def __enter__(self):\n                                        \n        self.file = Path(self.infile).open('rb')\n        self.page_iter = PDFPage.get_pages(self.file)\n        return self", "func_code_string": "def __enter__(self):\n                                        \n        self.file = Path(self.infile).open('rb')\n        self.page_iter = PDFPage.get_pages(self.file)\n        return self", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_page_analysis", "whole_func_string": "def get_page_analysis(self, pageno: int):\n                                                     \n        while len(self.page_cache) <= pageno:\n            try:\n                self.page_cache.append(next(self.page_iter))\n            except StopIteration:\n                raise InputFileError(\n                    f\"pdfminer did not find page {pageno} in the input file.\"\n                )\n        page = self.page_cache[pageno]\n        if not page:\n            raise InputFileError(\n                f\"pdfminer could not process page {pageno} (counting from 0).\"\n            )\n        dev = TextPositionTracker(\n            self.rman,\n            laparams=LAParams(\n                all_texts=True, detect_vertical=True, boxes_flow=self.disable_boxes_flow\n            ),\n        )\n        interp = pdfminer.pdfinterp.PDFPageInterpreter(self.rman, dev)\n\n        with patch_pdfminer(self.pscript5_mode):\n            interp.process_page(page)\n\n        return dev.get_result()", "func_code_string": "def get_page_analysis(self, pageno: int):\n                                                     \n        while len(self.page_cache) <= pageno:\n            try:\n                self.page_cache.append(next(self.page_iter))\n            except StopIteration:\n                raise InputFileError(\n                    f\"pdfminer did not find page {pageno} in the input file.\"\n                )\n        page = self.page_cache[pageno]\n        if not page:\n            raise InputFileError(\n                f\"pdfminer could not process page {pageno} (counting from 0).\"\n            )\n        dev = TextPositionTracker(\n            self.rman,\n            laparams=LAParams(\n                all_texts=True, detect_vertical=True, boxes_flow=self.disable_boxes_flow\n            ),\n        )\n        interp = pdfminer.pdfinterp.PDFPageInterpreter(self.rman, dev)\n\n        with patch_pdfminer(self.pscript5_mode):\n            interp.process_page(page)\n\n        return dev.get_result()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/optimize.py", "func_name": "add_options", "whole_func_string": "def add_options(parser):\n    optimizing = parser.add_argument_group(\n        \"Optimization options\", \"Control how the PDF is optimized after OCR\"\n    )\n    optimizing.add_argument(\n        '-O',\n        '--optimize',\n        type=int,\n        choices=range(0, 4),\n        default=1,\n        help=(\n            \"Control how PDF is optimized after processing:\"\n            \"0 - do not optimize; \"\n            \"1 - do safe, lossless optimizations (default); \"\n            \"2 - do lossy JPEG and JPEG2000 optimizations; \"\n            \"3 - do more aggressive lossy JPEG and JPEG2000 optimizations. \"\n            \"To enable lossy JBIG2, see --jbig2-lossy.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jpeg-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        help=(\n            \"Adjust JPEG quality level for JPEG optimization. \"\n            \"100 is best quality and largest output size; \"\n            \"1 is lowest quality and smallest output; \"\n            \"0 uses the default.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jpg-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        dest='jpeg_quality',\n        help=argparse.SUPPRESS,                            \n    )\n    optimizing.add_argument(\n        '--png-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        help=(\n            \"Adjust PNG quality level to use when quantizing PNGs. \"\n            \"Values have same meaning as with --jpeg-quality\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jbig2-lossy',\n        action='store_true',\n        help=(\n            \"Enable JBIG2 lossy mode (better compression, not suitable for some \"\n            \"use cases - see documentation). Only takes effect if --optimize 1 or \"\n            \"higher is also enabled.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jbig2-page-group-size',\n        type=numeric(int, 1, 10000),\n        default=0,\n        metavar='N',\n                                                                          \n        help=argparse.SUPPRESS,\n    )\n    optimizing.add_argument(\n        '--jbig2-threshold',\n        type=numeric(float, 0.4, 0.9),\n        default=0.85,\n        metavar='T',\n        help=(\n            \"Adjust JBIG2 symbol code classification threshold \"\n            \"(default 0.85), range 0.4 to 0.9.\"\n        ),\n    )", "func_code_string": "def add_options(parser):\n    optimizing = parser.add_argument_group(\n        \"Optimization options\", \"Control how the PDF is optimized after OCR\"\n    )\n    optimizing.add_argument(\n        '-O',\n        '--optimize',\n        type=int,\n        choices=range(0, 4),\n        default=1,\n        help=(\n            \"Control how PDF is optimized after processing:\"\n            \"0 - do not optimize; \"\n            \"1 - do safe, lossless optimizations (default); \"\n            \"2 - do lossy JPEG and JPEG2000 optimizations; \"\n            \"3 - do more aggressive lossy JPEG and JPEG2000 optimizations. \"\n            \"To enable lossy JBIG2, see --jbig2-lossy.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jpeg-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        help=(\n            \"Adjust JPEG quality level for JPEG optimization. \"\n            \"100 is best quality and largest output size; \"\n            \"1 is lowest quality and smallest output; \"\n            \"0 uses the default.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jpg-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        dest='jpeg_quality',\n        help=argparse.SUPPRESS,                            \n    )\n    optimizing.add_argument(\n        '--png-quality',\n        type=numeric(int, 0, 100),\n        default=0,\n        metavar='Q',\n        help=(\n            \"Adjust PNG quality level to use when quantizing PNGs. \"\n            \"Values have same meaning as with --jpeg-quality\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jbig2-lossy',\n        action='store_true',\n        help=(\n            \"Enable JBIG2 lossy mode (better compression, not suitable for some \"\n            \"use cases - see documentation). Only takes effect if --optimize 1 or \"\n            \"higher is also enabled.\"\n        ),\n    )\n    optimizing.add_argument(\n        '--jbig2-page-group-size',\n        type=numeric(int, 1, 10000),\n        default=0,\n        metavar='N',\n                                                                          \n        help=argparse.SUPPRESS,\n    )\n    optimizing.add_argument(\n        '--jbig2-threshold',\n        type=numeric(float, 0.4, 0.9),\n        default=0.85,\n        metavar='T',\n        help=(\n            \"Adjust JBIG2 symbol code classification threshold \"\n            \"(default 0.85), range 0.4 to 0.9.\"\n        ),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/optimize.py", "func_name": "check_options", "whole_func_string": "def check_options(options):\n    if options.optimize >= 2:\n        check_external_program(\n            program='pngquant',\n            package='pngquant',\n            version_checker=pngquant.version,\n            need_version='2.12.2',\n            required_for='--optimize {2,3}',\n        )\n\n    if options.optimize >= 2:\n                                                                             \n                                              \n        check_external_program(\n            program='jbig2',\n            package='jbig2enc',\n            version_checker=jbig2enc.version,\n            need_version='0.28',\n            required_for='--optimize {2,3} | --jbig2-lossy',\n            recommended=True if not options.jbig2_lossy else False,\n        )\n\n    if options.optimize == 0 and any(\n        [options.jbig2_lossy, options.png_quality, options.jpeg_quality]\n    ):\n        log.warning(\n            \"The arguments --jbig2-lossy, --png-quality, and --jpeg-quality \"\n            \"will be ignored because --optimize=0.\"\n        )", "func_code_string": "def check_options(options):\n    if options.optimize >= 2:\n        check_external_program(\n            program='pngquant',\n            package='pngquant',\n            version_checker=pngquant.version,\n            need_version='2.12.2',\n            required_for='--optimize {2,3}',\n        )\n\n    if options.optimize >= 2:\n                                                                             \n                                              \n        check_external_program(\n            program='jbig2',\n            package='jbig2enc',\n            version_checker=jbig2enc.version,\n            need_version='0.28',\n            required_for='--optimize {2,3} | --jbig2-lossy',\n            recommended=True if not options.jbig2_lossy else False,\n        )\n\n    if options.optimize == 0 and any(\n        [options.jbig2_lossy, options.png_quality, options.jpeg_quality]\n    ):\n        log.warning(\n            \"The arguments --jbig2-lossy, --png-quality, and --jpeg-quality \"\n            \"will be ignored because --optimize=0.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/optimize.py", "func_name": "optimize_pdf", "whole_func_string": "def optimize_pdf(\n    input_pdf: Path,\n    output_pdf: Path,\n    context: PdfContext,\n    executor: Executor,\n    linearize: bool,\n) -> tuple[Path, Sequence[str]]:\n    save_settings = dict(\n        linearize=linearize,\n        **get_pdf_save_settings(context.options.output_type),\n    )\n    result_path = optimize(input_pdf, output_pdf, context, save_settings, executor)\n    messages = []\n    if context.options.optimize == 0:\n        messages.append(\"Optimization was disabled.\")\n    else:\n        image_optimizers = {\n            'jbig2': jbig2enc.available(),\n            'pngquant': pngquant.available(),\n        }\n        for name, available in image_optimizers.items():\n            if not available:\n                messages.append(\n                    f\"The optional dependency '{name}' was not found, so some image \"\n                    f\"optimizations could not be attempted.\"\n                )\n    return result_path, messages", "func_code_string": "def optimize_pdf(\n    input_pdf: Path,\n    output_pdf: Path,\n    context: PdfContext,\n    executor: Executor,\n    linearize: bool,\n) -> tuple[Path, Sequence[str]]:\n    save_settings = dict(\n        linearize=linearize,\n        **get_pdf_save_settings(context.options.output_type),\n    )\n    result_path = optimize(input_pdf, output_pdf, context, save_settings, executor)\n    messages = []\n    if context.options.optimize == 0:\n        messages.append(\"Optimization was disabled.\")\n    else:\n        image_optimizers = {\n            'jbig2': jbig2enc.available(),\n            'pngquant': pngquant.available(),\n        }\n        for name, available in image_optimizers.items():\n            if not available:\n                messages.append(\n                    f\"The optional dependency '{name}' was not found, so some image \"\n                    f\"optimizations could not be attempted.\"\n                )\n    return result_path, messages", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/optimize.py", "func_name": "is_optimization_enabled", "whole_func_string": "def is_optimization_enabled(context: PdfContext) -> bool:\n    return context.options.optimize != 0", "func_code_string": "def is_optimization_enabled(context: PdfContext) -> bool:\n    return context.options.optimize != 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "log_listener", "whole_func_string": "def log_listener(q: Queue):\n           \n    while True:\n        try:\n            record = q.get()\n            if record is None:\n                break\n            logger = logging.getLogger(record.name)\n            logger.handle(record)\n        except Exception:                                \n            import traceback                                           \n\n            print(\"Logging problem\", file=sys.stderr)\n            traceback.print_exc(file=sys.stderr)", "func_code_string": "def log_listener(q: Queue):\n           \n    while True:\n        try:\n            record = q.get()\n            if record is None:\n                break\n            logger = logging.getLogger(record.name)\n            logger.handle(record)\n        except Exception:                                \n            import traceback                                           \n\n            print(\"Logging problem\", file=sys.stderr)\n            traceback.print_exc(file=sys.stderr)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "process_sigbus", "whole_func_string": "def process_sigbus(*args):\n                                                   \n    raise InputFileError(\"A worker process lost access to an input file\")", "func_code_string": "def process_sigbus(*args):\n                                                   \n    raise InputFileError(\"A worker process lost access to an input file\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "process_init", "whole_func_string": "def process_init(q: Queue, user_init: UserInit, loglevel) -> None:\n                                           \n                                                                \n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n                                                                                  \n    with suppress(AttributeError):                                         \n                                                                  \n        signal.signal(signal.SIGBUS, process_sigbus)\n\n                                                               \n    root = logging.getLogger()\n    remove_all_log_handlers(root)\n\n                                                                     \n    root.setLevel(loglevel)\n    root.addHandler(logging.handlers.QueueHandler(q))\n\n    user_init()\n    return", "func_code_string": "def process_init(q: Queue, user_init: UserInit, loglevel) -> None:\n                                           \n                                                                \n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n                                                                                  \n    with suppress(AttributeError):                                         \n                                                                  \n        signal.signal(signal.SIGBUS, process_sigbus)\n\n                                                               \n    root = logging.getLogger()\n    remove_all_log_handlers(root)\n\n                                                                     \n    root.setLevel(loglevel)\n    root.addHandler(logging.handlers.QueueHandler(q))\n\n    user_init()\n    return", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "thread_init", "whole_func_string": "def thread_init(q: Queue, user_init: UserInit, loglevel) -> None:\n                                     \n    del q                                \n    del loglevel                                \n                                                                   \n    with suppress(AttributeError):\n        signal.pthread_sigmask(signal.SIG_BLOCK, {signal.SIGBUS})\n\n    user_init()\n    return", "func_code_string": "def thread_init(q: Queue, user_init: UserInit, loglevel) -> None:\n                                     \n    del q                                \n    del loglevel                                \n                                                                   \n    with suppress(AttributeError):\n        signal.pthread_sigmask(signal.SIG_BLOCK, {signal.SIGBUS})\n\n    user_init()\n    return", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "StandardExecutor", "whole_func_string": "class StandardExecutor(Executor):\n                                                     \n\n    def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads:\n            log_queue: Queue = queue.Queue(-1)\n            executor_class: FuturesExecutorClass = ThreadPoolExecutor\n            initializer: WorkerInit = thread_init\n        else:\n            log_queue = multiprocessing.Queue(-1)\n            executor_class = ProcessPoolExecutor\n            initializer = process_init\n\n                                                                                     \n                                                                                   \n                                                          \n                                                                                      \n                                                                            \n                                                                               \n                                                                              \n                                                   \n        listener = threading.Thread(target=log_listener, args=(log_queue,))\n        listener.start()\n\n        with (\n            self.pbar_class(**progress_kwargs) as pbar,\n            executor_class(\n                max_workers=max_workers,\n                initializer=initializer,\n                initargs=(log_queue, worker_initializer, logging.getLogger(\"\").level),\n            ) as executor,\n        ):\n            futures = [executor.submit(task, *args) for args in task_arguments]\n            try:\n                for future in as_completed(futures):\n                    result = future.result()\n                    task_finished(result, pbar)\n            except KeyboardInterrupt:\n                                                     \n                executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            except Exception:\n                if not os.environ.get(\"PYTEST_CURRENT_TEST\", \"\"):\n                                                                                  \n                                                                                    \n                                                                                  \n                                                                                   \n                                                                                \n                    executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            finally:\n                                        \n                log_queue.put_nowait(None)\n\n                                                                            \n                                                                           \n        listener.join()", "func_code_string": "class StandardExecutor(Executor):\n                                                     \n\n    def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads:\n            log_queue: Queue = queue.Queue(-1)\n            executor_class: FuturesExecutorClass = ThreadPoolExecutor\n            initializer: WorkerInit = thread_init\n        else:\n            log_queue = multiprocessing.Queue(-1)\n            executor_class = ProcessPoolExecutor\n            initializer = process_init\n\n                                                                                     \n                                                                                   \n                                                          \n                                                                                      \n                                                                            \n                                                                               \n                                                                              \n                                                   \n        listener = threading.Thread(target=log_listener, args=(log_queue,))\n        listener.start()\n\n        with (\n            self.pbar_class(**progress_kwargs) as pbar,\n            executor_class(\n                max_workers=max_workers,\n                initializer=initializer,\n                initargs=(log_queue, worker_initializer, logging.getLogger(\"\").level),\n            ) as executor,\n        ):\n            futures = [executor.submit(task, *args) for args in task_arguments]\n            try:\n                for future in as_completed(futures):\n                    result = future.result()\n                    task_finished(result, pbar)\n            except KeyboardInterrupt:\n                                                     \n                executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            except Exception:\n                if not os.environ.get(\"PYTEST_CURRENT_TEST\", \"\"):\n                                                                                  \n                                                                                    \n                                                                                  \n                                                                                   \n                                                                                \n                    executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            finally:\n                                        \n                log_queue.put_nowait(None)\n\n                                                                            \n                                                                           \n        listener.join()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "get_executor", "whole_func_string": "def get_executor(progressbar_class):\n                                      \n    return StandardExecutor(pbar_class=progressbar_class)", "func_code_string": "def get_executor(progressbar_class):\n                                      \n    return StandardExecutor(pbar_class=progressbar_class)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "get_progressbar_class", "whole_func_string": "def get_progressbar_class():\n                                                \n\n    def partial_RichProgressBar(*args, **kwargs):\n        return RichProgressBar(*args, **kwargs, console=RICH_CONSOLE)\n\n    return partial_RichProgressBar", "func_code_string": "def get_progressbar_class():\n                                                \n\n    def partial_RichProgressBar(*args, **kwargs):\n        return RichProgressBar(*args, **kwargs, console=RICH_CONSOLE)\n\n    return partial_RichProgressBar", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "get_logging_console", "whole_func_string": "def get_logging_console():\n                                                     \n    return RichLoggingHandler(console=RICH_CONSOLE)", "func_code_string": "def get_logging_console():\n                                                     \n    return RichLoggingHandler(console=RICH_CONSOLE)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "_execute", "whole_func_string": "def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads:\n            log_queue: Queue = queue.Queue(-1)\n            executor_class: FuturesExecutorClass = ThreadPoolExecutor\n            initializer: WorkerInit = thread_init\n        else:\n            log_queue = multiprocessing.Queue(-1)\n            executor_class = ProcessPoolExecutor\n            initializer = process_init\n\n                                                                                     \n                                                                                   \n                                                          \n                                                                                      \n                                                                            \n                                                                               \n                                                                              \n                                                   \n        listener = threading.Thread(target=log_listener, args=(log_queue,))\n        listener.start()\n\n        with (\n            self.pbar_class(**progress_kwargs) as pbar,\n            executor_class(\n                max_workers=max_workers,\n                initializer=initializer,\n                initargs=(log_queue, worker_initializer, logging.getLogger(\"\").level),\n            ) as executor,\n        ):\n            futures = [executor.submit(task, *args) for args in task_arguments]\n            try:\n                for future in as_completed(futures):\n                    result = future.result()\n                    task_finished(result, pbar)\n            except KeyboardInterrupt:\n                                                     \n                executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            except Exception:\n                if not os.environ.get(\"PYTEST_CURRENT_TEST\", \"\"):\n                                                                                  \n                                                                                    \n                                                                                  \n                                                                                   \n                                                                                \n                    executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            finally:\n                                        \n                log_queue.put_nowait(None)\n\n                                                                            \n                                                                           \n        listener.join()", "func_code_string": "def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads:\n            log_queue: Queue = queue.Queue(-1)\n            executor_class: FuturesExecutorClass = ThreadPoolExecutor\n            initializer: WorkerInit = thread_init\n        else:\n            log_queue = multiprocessing.Queue(-1)\n            executor_class = ProcessPoolExecutor\n            initializer = process_init\n\n                                                                                     \n                                                                                   \n                                                          \n                                                                                      \n                                                                            \n                                                                               \n                                                                              \n                                                   \n        listener = threading.Thread(target=log_listener, args=(log_queue,))\n        listener.start()\n\n        with (\n            self.pbar_class(**progress_kwargs) as pbar,\n            executor_class(\n                max_workers=max_workers,\n                initializer=initializer,\n                initargs=(log_queue, worker_initializer, logging.getLogger(\"\").level),\n            ) as executor,\n        ):\n            futures = [executor.submit(task, *args) for args in task_arguments]\n            try:\n                for future in as_completed(futures):\n                    result = future.result()\n                    task_finished(result, pbar)\n            except KeyboardInterrupt:\n                                                     \n                executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            except Exception:\n                if not os.environ.get(\"PYTEST_CURRENT_TEST\", \"\"):\n                                                                                  \n                                                                                    \n                                                                                  \n                                                                                   \n                                                                                \n                    executor.shutdown(wait=False, cancel_futures=True)\n                raise\n            finally:\n                                        \n                log_queue.put_nowait(None)\n\n                                                                            \n                                                                           \n        listener.join()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/concurrency.py", "func_name": "partial_RichProgressBar", "whole_func_string": "def partial_RichProgressBar(*args, **kwargs):\n        return RichProgressBar(*args, **kwargs, console=RICH_CONSOLE)", "func_code_string": "def partial_RichProgressBar(*args, **kwargs):\n        return RichProgressBar(*args, **kwargs, console=RICH_CONSOLE)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/default_filters.py", "func_name": "filter_pdf_page", "whole_func_string": "def filter_pdf_page(page, image_filename, output_pdf):                                   \n    return output_pdf", "func_code_string": "def filter_pdf_page(page, image_filename, output_pdf):                                   \n    return output_pdf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "add_options", "whole_func_string": "def add_options(parser):\n    tess = parser.add_argument_group(\"Tesseract\", \"Advanced control of Tesseract OCR\")\n    tess.add_argument(\n        '--tesseract-config',\n        action='append',\n        metavar='CFG',\n        default=[],\n        help=\"Additional Tesseract configuration files -- see documentation.\",\n    )\n    tess.add_argument(\n        '--tesseract-pagesegmode',\n        action='store',\n        type=int,\n        metavar='PSM',\n        choices=range(0, 14),\n        help=\"Set Tesseract page segmentation mode (see tesseract --help).\",\n    )\n    tess.add_argument(\n        '--tesseract-oem',\n        action='store',\n        type=int,\n        metavar='MODE',\n        choices=range(0, 4),\n        help=(\n            \"Set Tesseract 4+ OCR engine mode: \"\n            \"0 - original Tesseract only; \"\n            \"1 - neural nets LSTM only; \"\n            \"2 - Tesseract + LSTM; \"\n            \"3 - default.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-thresholding',\n        action='store',\n        type=str_to_int(tesseract.TESSERACT_THRESHOLDING_METHODS),\n        default='auto',\n        metavar='METHOD',\n        help=(\n            \"Set Tesseract 5.0+ input image thresholding mode. This may improve OCR \"\n            \"results on low quality images or those that contain high contrast color. \"\n            \"legacy-otsu is the Tesseract default; adaptive-otsu is an improved Otsu \"\n            \"algorithm with improved sort for background color changes; sauvola is \"\n            \"based on local standard deviation.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-timeout',\n        default=180.0,\n        type=numeric(float, 0),\n        metavar='SECONDS',\n        help=(\n            \"Give up on OCR after the timeout, but copy the preprocessed page \"\n            \"into the final output. This timeout is only used when using Tesseract \"\n            \"for OCR. When Tesseract is used for other operations such as \"\n            \"deskewing and orientation, the timeout is controlled by \"\n            \"--tesseract-non-ocr-timeout.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-non-ocr-timeout',\n        default=180.0,\n        type=numeric(float, 0),\n        metavar='SECONDS',\n        help=(\n            \"Give up on non-OCR operations such as deskewing and orientation \"\n            \"after timeout. This is a separate timeout from --tesseract-timeout \"\n            \"because these operations are not as expensive as OCR.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-downsample-large-images',\n        action=argparse.BooleanOptionalAction,\n        default=True,\n        help=(\n            \"Downsample large images before OCR. Tesseract has an upper limit on the \"\n            \"size images it will support. If this argument is given, OCRmyPDF will \"\n            \"downsample large images to fit Tesseract. This may reduce OCR quality, \"\n            \"on large images the most desirable text is usually larger. If this \"\n            \"parameter is not supplied, Tesseract will error out and produce no OCR \"\n            \"on the page in question. This argument should be used with a high value \"\n            \"of --tesseract-timeout to ensure Tesseract has enough to time.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-downsample-above',\n        action='store',\n        type=numeric(int, 100, 32767),\n        default=32767,\n        help=(\n            \"Downsample images larger than this size pixel size in either dimension \"\n            \"before OCR. --tesseract-downsample-large-images downsamples only when \"\n            \"an image exceeds Tesseract's internal limits. This argument causes \"\n            \"downsampling to occur when an image exceeds the given size. This may \"\n            \"reduce OCR quality, but on large images the most desirable text is \"\n            \"usually larger.\"\n        ),\n    )\n    tess.add_argument(\n        '--user-words',\n        metavar='FILE',\n        help=\"Specify the location of the Tesseract user words file. This is a \"\n        \"list of words Tesseract should consider while performing OCR in \"\n        \"addition to its standard language dictionaries. This can improve \"\n        \"OCR quality especially for specialized and technical documents.\",\n    )\n    tess.add_argument(\n        '--user-patterns',\n        metavar='FILE',\n        help=\"Specify the location of the Tesseract user patterns file.\",\n    )", "func_code_string": "def add_options(parser):\n    tess = parser.add_argument_group(\"Tesseract\", \"Advanced control of Tesseract OCR\")\n    tess.add_argument(\n        '--tesseract-config',\n        action='append',\n        metavar='CFG',\n        default=[],\n        help=\"Additional Tesseract configuration files -- see documentation.\",\n    )\n    tess.add_argument(\n        '--tesseract-pagesegmode',\n        action='store',\n        type=int,\n        metavar='PSM',\n        choices=range(0, 14),\n        help=\"Set Tesseract page segmentation mode (see tesseract --help).\",\n    )\n    tess.add_argument(\n        '--tesseract-oem',\n        action='store',\n        type=int,\n        metavar='MODE',\n        choices=range(0, 4),\n        help=(\n            \"Set Tesseract 4+ OCR engine mode: \"\n            \"0 - original Tesseract only; \"\n            \"1 - neural nets LSTM only; \"\n            \"2 - Tesseract + LSTM; \"\n            \"3 - default.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-thresholding',\n        action='store',\n        type=str_to_int(tesseract.TESSERACT_THRESHOLDING_METHODS),\n        default='auto',\n        metavar='METHOD',\n        help=(\n            \"Set Tesseract 5.0+ input image thresholding mode. This may improve OCR \"\n            \"results on low quality images or those that contain high contrast color. \"\n            \"legacy-otsu is the Tesseract default; adaptive-otsu is an improved Otsu \"\n            \"algorithm with improved sort for background color changes; sauvola is \"\n            \"based on local standard deviation.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-timeout',\n        default=180.0,\n        type=numeric(float, 0),\n        metavar='SECONDS',\n        help=(\n            \"Give up on OCR after the timeout, but copy the preprocessed page \"\n            \"into the final output. This timeout is only used when using Tesseract \"\n            \"for OCR. When Tesseract is used for other operations such as \"\n            \"deskewing and orientation, the timeout is controlled by \"\n            \"--tesseract-non-ocr-timeout.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-non-ocr-timeout',\n        default=180.0,\n        type=numeric(float, 0),\n        metavar='SECONDS',\n        help=(\n            \"Give up on non-OCR operations such as deskewing and orientation \"\n            \"after timeout. This is a separate timeout from --tesseract-timeout \"\n            \"because these operations are not as expensive as OCR.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-downsample-large-images',\n        action=argparse.BooleanOptionalAction,\n        default=True,\n        help=(\n            \"Downsample large images before OCR. Tesseract has an upper limit on the \"\n            \"size images it will support. If this argument is given, OCRmyPDF will \"\n            \"downsample large images to fit Tesseract. This may reduce OCR quality, \"\n            \"on large images the most desirable text is usually larger. If this \"\n            \"parameter is not supplied, Tesseract will error out and produce no OCR \"\n            \"on the page in question. This argument should be used with a high value \"\n            \"of --tesseract-timeout to ensure Tesseract has enough to time.\"\n        ),\n    )\n    tess.add_argument(\n        '--tesseract-downsample-above',\n        action='store',\n        type=numeric(int, 100, 32767),\n        default=32767,\n        help=(\n            \"Downsample images larger than this size pixel size in either dimension \"\n            \"before OCR. --tesseract-downsample-large-images downsamples only when \"\n            \"an image exceeds Tesseract's internal limits. This argument causes \"\n            \"downsampling to occur when an image exceeds the given size. This may \"\n            \"reduce OCR quality, but on large images the most desirable text is \"\n            \"usually larger.\"\n        ),\n    )\n    tess.add_argument(\n        '--user-words',\n        metavar='FILE',\n        help=\"Specify the location of the Tesseract user words file. This is a \"\n        \"list of words Tesseract should consider while performing OCR in \"\n        \"addition to its standard language dictionaries. This can improve \"\n        \"OCR quality especially for specialized and technical documents.\",\n    )\n    tess.add_argument(\n        '--user-patterns',\n        metavar='FILE',\n        help=\"Specify the location of the Tesseract user patterns file.\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "check_options", "whole_func_string": "def check_options(options):\n    check_external_program(\n        program='tesseract',\n        package={'linux': 'tesseract-ocr'},\n        version_checker=tesseract.version,\n        need_version='4.1.1',                                     \n        version_parser=tesseract.TesseractVersion,\n    )\n    tess_version = tesseract.version()\n    if tess_version == tesseract.TesseractVersion('5.4.0'):\n        raise MissingDependencyError(\n            \"Tesseract 5.4.0 is not supported due to regressions in this version. \"\n            \"Please upgrade to a newer or supported older version.\"\n        )\n\n                                    \n    if options.pdf_renderer == 'auto':\n        if {'ara', 'heb', 'fas', 'per'} & set(options.languages):\n            log.info(\"Using sandwich renderer since there is an RTL language\")\n            options.pdf_renderer = 'sandwich'\n        else:\n            options.pdf_renderer = 'hocr'\n\n    if not tesseract.has_thresholding() and options.tesseract_thresholding != 0:\n        log.warning(\n            \"The installed version of Tesseract does not support changes to its \"\n            \"thresholding method. The --tesseract-threshold argument will be \"\n            \"ignored.\"\n        )\n    if options.tesseract_pagesegmode in (0, 2):\n        log.warning(\n            \"The --tesseract-pagesegmode argument you select will disable OCR. \"\n            \"This may cause processing to fail.\"\n        )\n    DENIED_LANGUAGES = {'equ', 'osd'}\n    if DENIED_LANGUAGES & set(options.languages):\n        raise BadArgsError(\n            \"The following languages for Tesseract's internal use and should not \"\n            \"be issued explicitly: \"\n            f\"{', '.join(DENIED_LANGUAGES & set(options.languages))}\\n\"\n            \"Remove them from the -l/--language argument.\"\n        )", "func_code_string": "def check_options(options):\n    check_external_program(\n        program='tesseract',\n        package={'linux': 'tesseract-ocr'},\n        version_checker=tesseract.version,\n        need_version='4.1.1',                                     \n        version_parser=tesseract.TesseractVersion,\n    )\n    tess_version = tesseract.version()\n    if tess_version == tesseract.TesseractVersion('5.4.0'):\n        raise MissingDependencyError(\n            \"Tesseract 5.4.0 is not supported due to regressions in this version. \"\n            \"Please upgrade to a newer or supported older version.\"\n        )\n\n                                    \n    if options.pdf_renderer == 'auto':\n        if {'ara', 'heb', 'fas', 'per'} & set(options.languages):\n            log.info(\"Using sandwich renderer since there is an RTL language\")\n            options.pdf_renderer = 'sandwich'\n        else:\n            options.pdf_renderer = 'hocr'\n\n    if not tesseract.has_thresholding() and options.tesseract_thresholding != 0:\n        log.warning(\n            \"The installed version of Tesseract does not support changes to its \"\n            \"thresholding method. The --tesseract-threshold argument will be \"\n            \"ignored.\"\n        )\n    if options.tesseract_pagesegmode in (0, 2):\n        log.warning(\n            \"The --tesseract-pagesegmode argument you select will disable OCR. \"\n            \"This may cause processing to fail.\"\n        )\n    DENIED_LANGUAGES = {'equ', 'osd'}\n    if DENIED_LANGUAGES & set(options.languages):\n        raise BadArgsError(\n            \"The following languages for Tesseract's internal use and should not \"\n            \"be issued explicitly: \"\n            f\"{', '.join(DENIED_LANGUAGES & set(options.languages))}\\n\"\n            \"Remove them from the -l/--language argument.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "validate", "whole_func_string": "def validate(pdfinfo, options):\n                                                                                   \n                                                                                    \n                                                \n                                                                                  \n                                                                                   \n                                                                                 \n                                                                          \n                                                                                       \n    if not os.environ.get('OMP_THREAD_LIMIT', '').isnumeric():\n        tess_threads = clamp(options.jobs // len(pdfinfo), 1, 3)\n        os.environ['OMP_THREAD_LIMIT'] = str(tess_threads)\n    else:\n        tess_threads = int(os.environ['OMP_THREAD_LIMIT'])\n    log.debug(\"Using Tesseract OpenMP thread limit %d\", tess_threads)\n\n    if (\n        options.tesseract_downsample_above != 32767\n        and not options.tesseract_downsample_large_images\n    ):\n        log.warning(\n            \"The --tesseract-downsample-above argument will have no effect unless \"\n            \"--tesseract-downsample-large-images is also given.\"\n        )", "func_code_string": "def validate(pdfinfo, options):\n                                                                                   \n                                                                                    \n                                                \n                                                                                  \n                                                                                   \n                                                                                 \n                                                                          \n                                                                                       \n    if not os.environ.get('OMP_THREAD_LIMIT', '').isnumeric():\n        tess_threads = clamp(options.jobs // len(pdfinfo), 1, 3)\n        os.environ['OMP_THREAD_LIMIT'] = str(tess_threads)\n    else:\n        tess_threads = int(os.environ['OMP_THREAD_LIMIT'])\n    log.debug(\"Using Tesseract OpenMP thread limit %d\", tess_threads)\n\n    if (\n        options.tesseract_downsample_above != 32767\n        and not options.tesseract_downsample_large_images\n    ):\n        log.warning(\n            \"The --tesseract-downsample-above argument will have no effect unless \"\n            \"--tesseract-downsample-large-images is also given.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "filter_ocr_image", "whole_func_string": "def filter_ocr_image(page: PageContext, image: Image.Image) -> Image.Image:\n           \n    threshold = min(page.options.tesseract_downsample_above, 32767)\n\n    options = page.options\n    if options.tesseract_downsample_large_images:\n        size = calculate_downsample(\n            image, max_size=(threshold, threshold), max_bytes=(2**31) - 1\n        )\n        image = downsample_image(image, size)\n    return image", "func_code_string": "def filter_ocr_image(page: PageContext, image: Image.Image) -> Image.Image:\n           \n    threshold = min(page.options.tesseract_downsample_above, 32767)\n\n    options = page.options\n    if options.tesseract_downsample_large_images:\n        size = calculate_downsample(\n            image, max_size=(threshold, threshold), max_bytes=(2**31) - 1\n        )\n        image = downsample_image(image, size)\n    return image", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "TesseractOcrEngine", "whole_func_string": "class TesseractOcrEngine(OcrEngine):\n                                        \n\n    @staticmethod\n    def version():\n        return str(tesseract.version())\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"Tesseract OCR{tag} {TesseractOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"Tesseract OCR {TesseractOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return tesseract.get_languages()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        return tesseract.get_deskew(\n            input_file,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        tesseract.generate_hocr(\n            input_file=input_file,\n            output_hocr=output_hocr,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        tesseract.generate_pdf(\n            input_file=input_file,\n            output_pdf=output_pdf,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_code_string": "class TesseractOcrEngine(OcrEngine):\n                                        \n\n    @staticmethod\n    def version():\n        return str(tesseract.version())\n\n    @staticmethod\n    def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"Tesseract OCR{tag} {TesseractOcrEngine.version()}\"\n\n    def __str__(self):\n        return f\"Tesseract OCR {TesseractOcrEngine.version()}\"\n\n    @staticmethod\n    def languages(options):\n        return tesseract.get_languages()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        return tesseract.get_deskew(\n            input_file,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        tesseract.generate_hocr(\n            input_file=input_file,\n            output_hocr=output_hocr,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        tesseract.generate_pdf(\n            input_file=input_file,\n            output_pdf=output_pdf,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return TesseractOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return TesseractOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "version", "whole_func_string": "def version():\n        return str(tesseract.version())", "func_code_string": "def version():\n        return str(tesseract.version())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "creator_tag", "whole_func_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"Tesseract OCR{tag} {TesseractOcrEngine.version()}\"", "func_code_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"Tesseract OCR{tag} {TesseractOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n        return f\"Tesseract OCR {TesseractOcrEngine.version()}\"", "func_code_string": "def __str__(self):\n        return f\"Tesseract OCR {TesseractOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "languages", "whole_func_string": "def languages(options):\n        return tesseract.get_languages()", "func_code_string": "def languages(options):\n        return tesseract.get_languages()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_code_string": "def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "get_deskew", "whole_func_string": "def get_deskew(input_file, options) -> float:\n        return tesseract.get_deskew(\n            input_file,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_code_string": "def get_deskew(input_file, options) -> float:\n        return tesseract.get_deskew(\n            input_file,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        tesseract.generate_hocr(\n            input_file=input_file,\n            output_hocr=output_hocr,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        tesseract.generate_hocr(\n            input_file=input_file,\n            output_hocr=output_hocr,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        tesseract.generate_pdf(\n            input_file=input_file,\n            output_pdf=output_pdf,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        tesseract.generate_pdf(\n            input_file=input_file,\n            output_pdf=output_pdf,\n            output_text=output_text,\n            languages=options.languages,\n            engine_mode=options.tesseract_oem,\n            tessconfig=options.tesseract_config,\n            timeout=options.tesseract_timeout,\n            pagesegmode=options.tesseract_pagesegmode,\n            thresholding=options.tesseract_thresholding,\n            user_words=options.user_words,\n            user_patterns=options.user_patterns,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/ghostscript.py", "func_name": "add_options", "whole_func_string": "def add_options(parser):\n    gs = parser.add_argument_group(\"Ghostscript\", \"Advanced control of Ghostscript\")\n    gs.add_argument(\n        '--color-conversion-strategy',\n        action='store',\n        type=str,\n        metavar='STRATEGY',\n        choices=ghostscript.COLOR_CONVERSION_STRATEGIES,\n        default='LeaveColorUnchanged',\n        help=\"Set Ghostscript color conversion strategy\",\n    )\n    gs.add_argument(\n        '--pdfa-image-compression',\n        choices=['auto', 'jpeg', 'lossless'],\n        default='auto',\n        help=\"Specify how to compress images in the output PDF/A. 'auto' lets \"\n        \"OCRmyPDF decide.  'jpeg' changes all grayscale and color images to \"\n        \"JPEG compression.  'lossless' uses PNG-style lossless compression \"\n        \"for all images.  Monochrome images are always compressed using a \"\n        \"lossless codec.  Compression settings \"\n        \"are applied to all pages, including those for which OCR was \"\n        \"skipped.  Not supported for --output-type=pdf ; that setting \"\n        \"preserves the original compression of all images.\",\n    )", "func_code_string": "def add_options(parser):\n    gs = parser.add_argument_group(\"Ghostscript\", \"Advanced control of Ghostscript\")\n    gs.add_argument(\n        '--color-conversion-strategy',\n        action='store',\n        type=str,\n        metavar='STRATEGY',\n        choices=ghostscript.COLOR_CONVERSION_STRATEGIES,\n        default='LeaveColorUnchanged',\n        help=\"Set Ghostscript color conversion strategy\",\n    )\n    gs.add_argument(\n        '--pdfa-image-compression',\n        choices=['auto', 'jpeg', 'lossless'],\n        default='auto',\n        help=\"Specify how to compress images in the output PDF/A. 'auto' lets \"\n        \"OCRmyPDF decide.  'jpeg' changes all grayscale and color images to \"\n        \"JPEG compression.  'lossless' uses PNG-style lossless compression \"\n        \"for all images.  Monochrome images are always compressed using a \"\n        \"lossless codec.  Compression settings \"\n        \"are applied to all pages, including those for which OCR was \"\n        \"skipped.  Not supported for --output-type=pdf ; that setting \"\n        \"preserves the original compression of all images.\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/ghostscript.py", "func_name": "check_options", "whole_func_string": "def check_options(options):\n                                                           \n    check_external_program(\n        program='gs',\n        package='ghostscript',\n        version_checker=ghostscript.version,\n        need_version='9.54',                                           \n    )\n    gs_version = ghostscript.version()\n    if gs_version in BLACKLISTED_GS_VERSIONS:\n        raise MissingDependencyError(\n            f\"Ghostscript {gs_version} contains serious regressions and is not \"\n            \"supported. Please upgrade to a newer version.\"\n        )\n    if Version('10.0.0') <= gs_version < Version('10.02.1') and (\n        options.skip_text or options.redo_ocr\n    ):\n        raise MissingDependencyError(\n            f\"Ghostscript 10.0.0 through 10.02.0 (your version: {gs_version}) \"\n            \"contain serious regressions that corrupt PDFs with existing text, \"\n            \"such as those processed using --skip-text or --redo-ocr. \"\n            \"Please upgrade to a \"\n            \"newer version, or use --output-type pdf to avoid Ghostscript, or \"\n            \"use --force-ocr to discard existing text.\"\n        )\n\n    if options.output_type == 'pdfa':\n        options.output_type = 'pdfa-2'\n    if options.color_conversion_strategy not in ghostscript.COLOR_CONVERSION_STRATEGIES:\n        raise ValueError(\n            f\"Invalid color conversion strategy: {options.color_conversion_strategy}\"\n        )\n    if options.pdfa_image_compression != 'auto' and not options.output_type.startswith(\n        'pdfa'\n    ):\n        log.warning(\n            \"--pdfa-image-compression argument only applies when \"\n            \"--output-type is one of 'pdfa', 'pdfa-1', or 'pdfa-2'\"\n        )", "func_code_string": "def check_options(options):\n                                                           \n    check_external_program(\n        program='gs',\n        package='ghostscript',\n        version_checker=ghostscript.version,\n        need_version='9.54',                                           \n    )\n    gs_version = ghostscript.version()\n    if gs_version in BLACKLISTED_GS_VERSIONS:\n        raise MissingDependencyError(\n            f\"Ghostscript {gs_version} contains serious regressions and is not \"\n            \"supported. Please upgrade to a newer version.\"\n        )\n    if Version('10.0.0') <= gs_version < Version('10.02.1') and (\n        options.skip_text or options.redo_ocr\n    ):\n        raise MissingDependencyError(\n            f\"Ghostscript 10.0.0 through 10.02.0 (your version: {gs_version}) \"\n            \"contain serious regressions that corrupt PDFs with existing text, \"\n            \"such as those processed using --skip-text or --redo-ocr. \"\n            \"Please upgrade to a \"\n            \"newer version, or use --output-type pdf to avoid Ghostscript, or \"\n            \"use --force-ocr to discard existing text.\"\n        )\n\n    if options.output_type == 'pdfa':\n        options.output_type = 'pdfa-2'\n    if options.color_conversion_strategy not in ghostscript.COLOR_CONVERSION_STRATEGIES:\n        raise ValueError(\n            f\"Invalid color conversion strategy: {options.color_conversion_strategy}\"\n        )\n    if options.pdfa_image_compression != 'auto' and not options.output_type.startswith(\n        'pdfa'\n    ):\n        log.warning(\n            \"--pdfa-image-compression argument only applies when \"\n            \"--output-type is one of 'pdfa', 'pdfa-1', or 'pdfa-2'\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/ghostscript.py", "func_name": "rasterize_pdf_page", "whole_func_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n):\n                                                                  \n    ghostscript.rasterize_pdf(\n        input_file,\n        output_file,\n        raster_device=raster_device,\n        raster_dpi=raster_dpi,\n        pageno=pageno,\n        page_dpi=page_dpi,\n        rotation=rotation,\n        filter_vector=filter_vector,\n        stop_on_error=stop_on_soft_error,\n    )\n    return output_file", "func_code_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n):\n                                                                  \n    ghostscript.rasterize_pdf(\n        input_file,\n        output_file,\n        raster_device=raster_device,\n        raster_dpi=raster_dpi,\n        pageno=pageno,\n        page_dpi=page_dpi,\n        rotation=rotation,\n        filter_vector=filter_vector,\n        stop_on_error=stop_on_soft_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/ghostscript.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(\n    pdf_pages,\n    pdfmark,\n    output_file,\n    context,\n    pdf_version,\n    pdfa_part,\n    progressbar_class,\n    stop_on_soft_error,\n):\n                                                                         \n    ghostscript.generate_pdfa(\n        pdf_pages=[pdfmark, *pdf_pages],\n        output_file=output_file,\n        compression=context.options.pdfa_image_compression,\n        color_conversion_strategy=context.options.color_conversion_strategy,\n        pdf_version=pdf_version,\n        pdfa_part=pdfa_part,\n        progressbar_class=progressbar_class,\n        stop_on_error=stop_on_soft_error,\n    )\n    return output_file", "func_code_string": "def generate_pdfa(\n    pdf_pages,\n    pdfmark,\n    output_file,\n    context,\n    pdf_version,\n    pdfa_part,\n    progressbar_class,\n    stop_on_soft_error,\n):\n                                                                         \n    ghostscript.generate_pdfa(\n        pdf_pages=[pdfmark, *pdf_pages],\n        output_file=output_file,\n        compression=context.options.pdfa_image_compression,\n        color_conversion_strategy=context.options.color_conversion_strategy,\n        pdf_version=pdf_version,\n        pdfa_part=pdfa_part,\n        progressbar_class=progressbar_class,\n        stop_on_error=stop_on_soft_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "run", "whole_func_string": "def run(\n    args: Args,\n    *,\n    env: OsEnviron | None = None,\n    logs_errors_to_stdout: bool = False,\n    check: bool = False,\n    **kwargs,\n) -> CompletedProcess:\n           \n    args, env, process_log, _text = _fix_process_args(args, env, kwargs)\n\n    stderr = None\n    stderr_name = 'stderr' if not logs_errors_to_stdout else 'stdout'\n    try:\n        proc = subprocess_run(args, env=env, check=check, **kwargs)\n    except CalledProcessError as e:\n        stderr = getattr(e, stderr_name, None)\n        raise\n    else:\n        stderr = getattr(proc, stderr_name, None)\n    finally:\n        if process_log.isEnabledFor(logging.DEBUG) and stderr:\n            with suppress(AttributeError, UnicodeDecodeError):\n                stderr = stderr.decode('utf-8', 'replace')\n            if logs_errors_to_stdout:\n                process_log.debug(\"stdout/stderr = %s\", stderr)\n            else:\n                process_log.debug(\"stderr = %s\", stderr)\n    return proc", "func_code_string": "def run(\n    args: Args,\n    *,\n    env: OsEnviron | None = None,\n    logs_errors_to_stdout: bool = False,\n    check: bool = False,\n    **kwargs,\n) -> CompletedProcess:\n           \n    args, env, process_log, _text = _fix_process_args(args, env, kwargs)\n\n    stderr = None\n    stderr_name = 'stderr' if not logs_errors_to_stdout else 'stdout'\n    try:\n        proc = subprocess_run(args, env=env, check=check, **kwargs)\n    except CalledProcessError as e:\n        stderr = getattr(e, stderr_name, None)\n        raise\n    else:\n        stderr = getattr(proc, stderr_name, None)\n    finally:\n        if process_log.isEnabledFor(logging.DEBUG) and stderr:\n            with suppress(AttributeError, UnicodeDecodeError):\n                stderr = stderr.decode('utf-8', 'replace')\n            if logs_errors_to_stdout:\n                process_log.debug(\"stdout/stderr = %s\", stderr)\n            else:\n                process_log.debug(\"stderr = %s\", stderr)\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "run_polling_stderr", "whole_func_string": "def run_polling_stderr(\n    args: Args,\n    *,\n    callback: Callable[[str], None],\n    check: bool = False,\n    env: OsEnviron | None = None,\n    **kwargs,\n) -> CompletedProcess:\n           \n    args, env, process_log, text = _fix_process_args(args, env, kwargs)\n    assert text, \"Must use text=True\"\n\n    with Popen(args, env=env, **kwargs) as proc:\n        lines = []\n        while proc.poll() is None:\n            if proc.stderr is None:\n                continue\n            for msg in iter(proc.stderr.readline, ''):\n                if process_log.isEnabledFor(logging.DEBUG):\n                    process_log.debug(msg.strip())\n                callback(msg)\n                lines.append(msg)\n        stderr = ''.join(lines)\n\n        if check and proc.returncode != 0:\n            raise CalledProcessError(proc.returncode, args, output=None, stderr=stderr)\n        return CompletedProcess(args, proc.returncode, None, stderr=stderr)", "func_code_string": "def run_polling_stderr(\n    args: Args,\n    *,\n    callback: Callable[[str], None],\n    check: bool = False,\n    env: OsEnviron | None = None,\n    **kwargs,\n) -> CompletedProcess:\n           \n    args, env, process_log, text = _fix_process_args(args, env, kwargs)\n    assert text, \"Must use text=True\"\n\n    with Popen(args, env=env, **kwargs) as proc:\n        lines = []\n        while proc.poll() is None:\n            if proc.stderr is None:\n                continue\n            for msg in iter(proc.stderr.readline, ''):\n                if process_log.isEnabledFor(logging.DEBUG):\n                    process_log.debug(msg.strip())\n                callback(msg)\n                lines.append(msg)\n        stderr = ''.join(lines)\n\n        if check and proc.returncode != 0:\n            raise CalledProcessError(proc.returncode, args, output=None, stderr=stderr)\n        return CompletedProcess(args, proc.returncode, None, stderr=stderr)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "_fix_process_args", "whole_func_string": "def _fix_process_args(\n    args: Args, env: OsEnviron | None, kwargs\n) -> tuple[Args, OsEnviron, logging.Logger, bool]:\n    if not env:\n        env = os.environ\n\n                                       \n    program = str(args[0])\n\n    if sys.platform == 'win32':\n                                                 \n        from ocrmypdf.subprocess._windows import fix_windows_args\n\n        args = fix_windows_args(program, args, env)\n\n    log.debug(\"Running: %s\", args)\n    process_log = log.getChild(os.path.basename(program))\n    text = bool(kwargs.get('text', False))\n\n    return args, env, process_log, text", "func_code_string": "def _fix_process_args(\n    args: Args, env: OsEnviron | None, kwargs\n) -> tuple[Args, OsEnviron, logging.Logger, bool]:\n    if not env:\n        env = os.environ\n\n                                       \n    program = str(args[0])\n\n    if sys.platform == 'win32':\n                                                 \n        from ocrmypdf.subprocess._windows import fix_windows_args\n\n        args = fix_windows_args(program, args, env)\n\n    log.debug(\"Running: %s\", args)\n    process_log = log.getChild(os.path.basename(program))\n    text = bool(kwargs.get('text', False))\n\n    return args, env, process_log, text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "get_version", "whole_func_string": "def get_version(\n    program: str,\n    *,\n    version_arg: str = '--version',\n    regex=r'(\\d+(\\.\\d+)*)',\n    env: OsEnviron | None = None,\n) -> str:\n           \n    args_prog = [program, version_arg]\n    try:\n        proc = run(\n            args_prog,\n            close_fds=True,\n            text=True,\n            stdout=PIPE,\n            stderr=STDOUT,\n            check=True,\n            env=env,\n        )\n        output: str = proc.stdout\n    except FileNotFoundError as e:\n        raise MissingDependencyError(\n            f\"Could not find program '{program}' on the PATH\"\n        ) from e\n    except CalledProcessError as e:\n        if e.returncode != 0:\n            log.exception(e)\n            raise MissingDependencyError(\n                f\"Ran program '{program}' but it exited with an error:\\n{e.output}\"\n            ) from e\n        raise MissingDependencyError(\n            f\"Could not find program '{program}' on the PATH\"\n        ) from e\n\n    match = re.match(regex, output.strip())\n    if not match:\n        raise MissingDependencyError(\n            f\"The program '{program}' did not report its version. \"\n            f\"Message was:\\n{output}\"\n        )\n    version = match.group(1)\n\n    return version", "func_code_string": "def get_version(\n    program: str,\n    *,\n    version_arg: str = '--version',\n    regex=r'(\\d+(\\.\\d+)*)',\n    env: OsEnviron | None = None,\n) -> str:\n           \n    args_prog = [program, version_arg]\n    try:\n        proc = run(\n            args_prog,\n            close_fds=True,\n            text=True,\n            stdout=PIPE,\n            stderr=STDOUT,\n            check=True,\n            env=env,\n        )\n        output: str = proc.stdout\n    except FileNotFoundError as e:\n        raise MissingDependencyError(\n            f\"Could not find program '{program}' on the PATH\"\n        ) from e\n    except CalledProcessError as e:\n        if e.returncode != 0:\n            log.exception(e)\n            raise MissingDependencyError(\n                f\"Ran program '{program}' but it exited with an error:\\n{e.output}\"\n            ) from e\n        raise MissingDependencyError(\n            f\"Could not find program '{program}' on the PATH\"\n        ) from e\n\n    match = re.match(regex, output.strip())\n    if not match:\n        raise MissingDependencyError(\n            f\"The program '{program}' did not report its version. \"\n            f\"Message was:\\n{output}\"\n        )\n    version = match.group(1)\n\n    return version", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "_get_platform", "whole_func_string": "def _get_platform() -> str:\n    if sys.platform.startswith('freebsd'):\n        return 'freebsd'\n    elif sys.platform.startswith('linux'):\n        return 'linux'\n    elif sys.platform.startswith('win'):\n        return 'windows'\n    return sys.platform", "func_code_string": "def _get_platform() -> str:\n    if sys.platform.startswith('freebsd'):\n        return 'freebsd'\n    elif sys.platform.startswith('linux'):\n        return 'linux'\n    elif sys.platform.startswith('win'):\n        return 'windows'\n    return sys.platform", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "_error_trailer", "whole_func_string": "def _error_trailer(program: str, package: str | Mapping[str, str], **kwargs) -> None:\n    del kwargs\n    if isinstance(package, Mapping):\n        package = package.get(_get_platform(), program)\n\n    if _get_platform() == 'darwin':\n        log.info(OSX_INSTALL_ADVICE.format(**locals()))\n    elif _get_platform() == 'linux':\n        log.info(LINUX_INSTALL_ADVICE.format(**locals()))\n    elif _get_platform() == 'windows':\n        log.info(WINDOWS_INSTALL_ADVICE.format(**locals()))", "func_code_string": "def _error_trailer(program: str, package: str | Mapping[str, str], **kwargs) -> None:\n    del kwargs\n    if isinstance(package, Mapping):\n        package = package.get(_get_platform(), program)\n\n    if _get_platform() == 'darwin':\n        log.info(OSX_INSTALL_ADVICE.format(**locals()))\n    elif _get_platform() == 'linux':\n        log.info(LINUX_INSTALL_ADVICE.format(**locals()))\n    elif _get_platform() == 'windows':\n        log.info(WINDOWS_INSTALL_ADVICE.format(**locals()))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "_error_missing_program", "whole_func_string": "def _error_missing_program(\n    program: str, package: str, required_for: str | None, recommended: bool\n) -> None:\n                                     \n    if recommended:\n        log.warning(MISSING_RECOMMEND_PROGRAM.format(**locals()))\n    elif required_for:\n        log.error(MISSING_OPTIONAL_PROGRAM.format(**locals()))\n    else:\n        log.error(MISSING_PROGRAM.format(**locals()))\n    _error_trailer(**locals())", "func_code_string": "def _error_missing_program(\n    program: str, package: str, required_for: str | None, recommended: bool\n) -> None:\n                                     \n    if recommended:\n        log.warning(MISSING_RECOMMEND_PROGRAM.format(**locals()))\n    elif required_for:\n        log.error(MISSING_OPTIONAL_PROGRAM.format(**locals()))\n    else:\n        log.error(MISSING_PROGRAM.format(**locals()))\n    _error_trailer(**locals())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "_error_old_version", "whole_func_string": "def _error_old_version(\n    program: str,\n    package: str,\n    need_version: str,\n    found_version: str,\n    required_for: str | None,\n) -> None:\n                                     \n    if required_for:\n        log.error(OLD_VERSION_REQUIRED_FOR.format(**locals()))\n    else:\n        log.error(OLD_VERSION.format(**locals()))\n    _error_trailer(**locals())", "func_code_string": "def _error_old_version(\n    program: str,\n    package: str,\n    need_version: str,\n    found_version: str,\n    required_for: str | None,\n) -> None:\n                                     \n    if required_for:\n        log.error(OLD_VERSION_REQUIRED_FOR.format(**locals()))\n    else:\n        log.error(OLD_VERSION.format(**locals()))\n    _error_trailer(**locals())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/__init__.py", "func_name": "check_external_program", "whole_func_string": "def check_external_program(\n    *,\n    program: str,\n    package: str,\n    version_checker: Callable[[], Version],\n    need_version: str | Version,\n    required_for: str | None = None,\n    recommended: bool = False,\n    version_parser: type[Version] = Version,\n) -> None:\n           \n    if not isinstance(need_version, Version):\n        need_version = version_parser(need_version)\n    try:\n        found_version = version_checker()\n    except (CalledProcessError, FileNotFoundError) as e:\n        _error_missing_program(program, package, required_for, recommended)\n        if not recommended:\n            raise MissingDependencyError(program) from e\n        return\n    except MissingDependencyError:\n        _error_missing_program(program, package, required_for, recommended)\n        if not recommended:\n            raise\n        return\n\n    if found_version and found_version < need_version:\n        _error_old_version(\n            program, package, str(need_version), str(found_version), required_for\n        )\n        if not recommended:\n            raise MissingDependencyError(program)\n\n    log.debug('Found %s %s', program, found_version)", "func_code_string": "def check_external_program(\n    *,\n    program: str,\n    package: str,\n    version_checker: Callable[[], Version],\n    need_version: str | Version,\n    required_for: str | None = None,\n    recommended: bool = False,\n    version_parser: type[Version] = Version,\n) -> None:\n           \n    if not isinstance(need_version, Version):\n        need_version = version_parser(need_version)\n    try:\n        found_version = version_checker()\n    except (CalledProcessError, FileNotFoundError) as e:\n        _error_missing_program(program, package, required_for, recommended)\n        if not recommended:\n            raise MissingDependencyError(program) from e\n        return\n    except MissingDependencyError:\n        _error_missing_program(program, package, required_for, recommended)\n        if not recommended:\n            raise\n        return\n\n    if found_version and found_version < need_version:\n        _error_old_version(\n            program, package, str(need_version), str(found_version), required_for\n        )\n        if not recommended:\n            raise MissingDependencyError(program)\n\n    log.debug('Found %s %s', program, found_version)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "ghostscript_version_key", "whole_func_string": "def ghostscript_version_key(s: str) -> tuple[int, int, int]:\n                                              \n    try:\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\n        while len(release) < 3:\n            release.append(0)\n        return (release[0], release[1], release[2])\n    except ValueError:\n        return (0, 0, 0)", "func_code_string": "def ghostscript_version_key(s: str) -> tuple[int, int, int]:\n                                              \n    try:\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\n        while len(release) < 3:\n            release.append(0)\n        return (release[0], release[1], release[2])\n    except ValueError:\n        return (0, 0, 0)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "registry_enum", "whole_func_string": "def registry_enum(key: HKEYType, enum_fn: Callable[[HKEYType, int], T]) -> Iterator[T]:\n    limit = 999\n    n = 0\n    while n < limit:\n        try:\n            yield enum_fn(key, n)\n            n += 1\n        except OSError:\n            break\n    if n == limit:\n        raise ValueError(f\"Too many registry keys under {key}\")", "func_code_string": "def registry_enum(key: HKEYType, enum_fn: Callable[[HKEYType, int], T]) -> Iterator[T]:\n    limit = 999\n    n = 0\n    while n < limit:\n        try:\n            yield enum_fn(key, n)\n            n += 1\n        except OSError:\n            break\n    if n == limit:\n        raise ValueError(f\"Too many registry keys under {key}\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "registry_subkeys", "whole_func_string": "def registry_subkeys(key: HKEYType) -> Iterator[str]:\n    return registry_enum(key, winreg.EnumKey)", "func_code_string": "def registry_subkeys(key: HKEYType) -> Iterator[str]:\n    return registry_enum(key, winreg.EnumKey)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "registry_values", "whole_func_string": "def registry_values(key: HKEYType) -> Iterator[tuple[str, Any, int]]:\n    return registry_enum(key, winreg.EnumValue)", "func_code_string": "def registry_values(key: HKEYType) -> Iterator[tuple[str, Any, int]]:\n    return registry_enum(key, winreg.EnumValue)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "registry_path_ghostscript", "whole_func_string": "def registry_path_ghostscript(env=None) -> Iterator[Path]:\n    del env                                    \n    try:\n        with winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Artifex\\GPL Ghostscript\"\n        ) as k:\n            latest_gs = max(\n                registry_subkeys(k), key=ghostscript_version_key, default=(0, 0, 0)\n            )\n        with winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, rf\"SOFTWARE\\Artifex\\GPL Ghostscript\\{latest_gs}\"\n        ) as k:\n            for _, gs_path, _ in registry_values(k):\n                yield Path(gs_path) / 'bin'\n    except OSError as e:\n        log.warning(e)", "func_code_string": "def registry_path_ghostscript(env=None) -> Iterator[Path]:\n    del env                                    \n    try:\n        with winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Artifex\\GPL Ghostscript\"\n        ) as k:\n            latest_gs = max(\n                registry_subkeys(k), key=ghostscript_version_key, default=(0, 0, 0)\n            )\n        with winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, rf\"SOFTWARE\\Artifex\\GPL Ghostscript\\{latest_gs}\"\n        ) as k:\n            for _, gs_path, _ in registry_values(k):\n                yield Path(gs_path) / 'bin'\n    except OSError as e:\n        log.warning(e)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "registry_path_tesseract", "whole_func_string": "def registry_path_tesseract(env=None) -> Iterator[Path]:\n    del env                                    \n    try:\n        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Tesseract-OCR\") as k:\n            for subkey, val, _valtype in registry_values(k):\n                if subkey == 'InstallDir':\n                    tesseract_path = Path(val)\n                    yield tesseract_path\n    except OSError as e:\n        log.warning(e)", "func_code_string": "def registry_path_tesseract(env=None) -> Iterator[Path]:\n    del env                                    \n    try:\n        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Tesseract-OCR\") as k:\n            for subkey, val, _valtype in registry_values(k):\n                if subkey == 'InstallDir':\n                    tesseract_path = Path(val)\n                    yield tesseract_path\n    except OSError as e:\n        log.warning(e)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "_gs_version_in_path_key", "whole_func_string": "def _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\n           \n    match = re.search(r'gs[/\\\\]?([0-9.]+)[/\\\\]bin', str(path))\n    if match:\n        try:\n            version_str = match.group(1)\n            version = Version(version_str)\n            return 'gs', version\n        except InvalidVersion:\n            pass\n    return path.name, None", "func_code_string": "def _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\n           \n    match = re.search(r'gs[/\\\\]?([0-9.]+)[/\\\\]bin', str(path))\n    if match:\n        try:\n            version_str = match.group(1)\n            version = Version(version_str)\n            return 'gs', version\n        except InvalidVersion:\n            pass\n    return path.name, None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "program_files_paths", "whole_func_string": "def program_files_paths(env=None) -> Iterator[Path]:\n    if not env:\n        env = os.environ\n    program_files = env.get('PROGRAMFILES', '')\n\n    def path_walker() -> Iterator[Path]:\n        for path in Path(program_files).iterdir():\n            if not path.is_dir():\n                continue\n            if path.name.lower() == 'tesseract-ocr':\n                yield path\n            elif path.name.lower() == 'gs':\n                yield from (p for p in path.glob('**/bin') if p.is_dir())\n\n    return iter(\n        sorted(\n            (p for p in path_walker()),\n            key=_gs_version_in_path_key,\n            reverse=True,\n        )\n    )", "func_code_string": "def program_files_paths(env=None) -> Iterator[Path]:\n    if not env:\n        env = os.environ\n    program_files = env.get('PROGRAMFILES', '')\n\n    def path_walker() -> Iterator[Path]:\n        for path in Path(program_files).iterdir():\n            if not path.is_dir():\n                continue\n            if path.name.lower() == 'tesseract-ocr':\n                yield path\n            elif path.name.lower() == 'gs':\n                yield from (p for p in path.glob('**/bin') if p.is_dir())\n\n    return iter(\n        sorted(\n            (p for p in path_walker()),\n            key=_gs_version_in_path_key,\n            reverse=True,\n        )\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "paths_from_env", "whole_func_string": "def paths_from_env(env=None) -> Iterator[Path]:\n    return (Path(p) for p in os.get_exec_path(env) if p)", "func_code_string": "def paths_from_env(env=None) -> Iterator[Path]:\n    return (Path(p) for p in os.get_exec_path(env) if p)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "shim_path", "whole_func_string": "def shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\n    if not env:\n        env = os.environ\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)", "func_code_string": "def shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\n    if not env:\n        env = os.environ\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "fix_windows_args", "whole_func_string": "def fix_windows_args(program: str, args, env):\n                                                                                   \n                                                                            \n                                   \n    if program.lower().endswith('.py'):\n        args = [sys.executable] + args\n\n                                                                \n    for shim in SHIMS:\n        shimmed_path = shim_path(shim, env)\n        new_args0 = shutil.which(args[0], path=shimmed_path)\n        if new_args0:\n            args[0] = new_args0\n            break\n\n    return args", "func_code_string": "def fix_windows_args(program: str, args, env):\n                                                                                   \n                                                                            \n                                   \n    if program.lower().endswith('.py'):\n        args = [sys.executable] + args\n\n                                                                \n    for shim in SHIMS:\n        shimmed_path = shim_path(shim, env)\n        new_args0 = shutil.which(args[0], path=shimmed_path)\n        if new_args0:\n            args[0] = new_args0\n            break\n\n    return args", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "unique_everseen", "whole_func_string": "def unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\n                                                 \n                                                    \n                                                       \n    seen: set[Tkey] = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k not in seen:\n            seen_add(k)\n            yield element", "func_code_string": "def unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\n                                                 \n                                                    \n                                                       \n    seen: set[Tkey] = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k not in seen:\n            seen_add(k)\n            yield element", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "_casefold_path", "whole_func_string": "def _casefold_path(path: Path) -> str:\n    return str.casefold(str(path))", "func_code_string": "def _casefold_path(path: Path) -> str:\n    return str.casefold(str(path))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "shim_env_path", "whole_func_string": "def shim_env_path(env=None):\n    if env is None:\n        env = os.environ\n\n    shim_paths = chain.from_iterable(shim(env) for shim in SHIMS)\n    return os.pathsep.join(\n        str(p) for p in unique_everseen(shim_paths, key=_casefold_path)\n    )", "func_code_string": "def shim_env_path(env=None):\n    if env is None:\n        env = os.environ\n\n    shim_paths = chain.from_iterable(shim(env) for shim in SHIMS)\n    return os.pathsep.join(\n        str(p) for p in unique_everseen(shim_paths, key=_casefold_path)\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "path_walker", "whole_func_string": "def path_walker() -> Iterator[Path]:\n        for path in Path(program_files).iterdir():\n            if not path.is_dir():\n                continue\n            if path.name.lower() == 'tesseract-ocr':\n                yield path\n            elif path.name.lower() == 'gs':\n                yield from (p for p in path.glob('**/bin') if p.is_dir())", "func_code_string": "def path_walker() -> Iterator[Path]:\n        for path in Path(program_files).iterdir():\n            if not path.is_dir():\n                continue\n            if path.name.lower() == 'tesseract-ocr':\n                yield path\n            elif path.name.lower() == 'gs':\n                yield from (p for p in path.glob('**/bin') if p.is_dir())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "EncodableFont", "whole_func_string": "class EncodableFont(Font):\n    def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_code_string": "class EncodableFont(Font):\n    def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "GlyphlessFont", "whole_func_string": "class GlyphlessFont(EncodableFont):\n    CID_TO_GID_DATA = zlib.compress(b\"\\x00\\x01\" * 65536)\n    GLYPHLESS_FONT_NAME = 'pdf.ttf'\n    GLYPHLESS_FONT = (package_files('ocrmypdf.data') / GLYPHLESS_FONT_NAME).read_bytes()\n    CHAR_ASPECT = 2\n\n    def __init__(self):\n        pass\n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n                                                   \n        return len(unicodedata.normalize(\"NFKC\", text)) * (fontsize / self.CHAR_ASPECT)\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('utf-16be')\n\n    def register(self, pdf: Pdf):\n                   \n        PLACEHOLDER = Name.Placeholder\n\n        basefont = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                DescendantFonts=[PLACEHOLDER],\n                Encoding=Name(\"/Identity-H\"),\n                Subtype=Name.Type0,\n                ToUnicode=PLACEHOLDER,\n                Type=Name.Font,\n            )\n        )\n        cid_font_type2 = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                CIDToGIDMap=PLACEHOLDER,\n                CIDSystemInfo=Dictionary(\n                    Ordering=\"Identity\",\n                    Registry=\"Adobe\",\n                    Supplement=0,\n                ),\n                FontDescriptor=PLACEHOLDER,\n                Subtype=Name.CIDFontType2,\n                Type=Name.Font,\n                DW=1000 // self.CHAR_ASPECT,\n            )\n        )\n        basefont.DescendantFonts = [cid_font_type2]\n        cid_font_type2.CIDToGIDMap = pdf.make_stream(\n            self.CID_TO_GID_DATA, Filter=Name.FlateDecode\n        )\n        basefont.ToUnicode = pdf.make_stream(\n            b\"/CIDInit /ProcSet findresource begin\\n\"\n            b\"12 dict begin\\n\"\n            b\"begincmap\\n\"\n            b\"/CIDSystemInfo\\n\"\n            b\"<<\\n\"\n            b\"  /Registry (Adobe)\\n\"\n            b\"  /Ordering (UCS)\\n\"\n            b\"  /Supplement 0\\n\"\n            b\">> def\\n\"\n            b\"/CMapName /Adobe-Identify-UCS def\\n\"\n            b\"/CMapType 2 def\\n\"\n            b\"1 begincodespacerange\\n\"\n            b\"<0000> <FFFF>\\n\"\n            b\"endcodespacerange\\n\"\n            b\"1 beginbfrange\\n\"\n            b\"<0000> <FFFF> <0000>\\n\"\n            b\"endbfrange\\n\"\n            b\"endcmap\\n\"\n            b\"CMapName currentdict /CMap defineresource pop\\n\"\n            b\"end\\n\"\n            b\"end\\n\"\n        )\n        font_descriptor = pdf.make_indirect(\n            Dictionary(\n                Ascent=1000,\n                CapHeight=1000,\n                Descent=-1,\n                Flags=5,                            \n                FontBBox=[0, 0, 1000 // self.CHAR_ASPECT, 1000],\n                FontFile2=PLACEHOLDER,\n                FontName=Name.GlyphLessFont,\n                ItalicAngle=0,\n                StemV=80,\n                Type=Name.FontDescriptor,\n            )\n        )\n        font_descriptor.FontFile2 = pdf.make_stream(self.GLYPHLESS_FONT)\n        cid_font_type2.FontDescriptor = font_descriptor\n        return basefont", "func_code_string": "class GlyphlessFont(EncodableFont):\n    CID_TO_GID_DATA = zlib.compress(b\"\\x00\\x01\" * 65536)\n    GLYPHLESS_FONT_NAME = 'pdf.ttf'\n    GLYPHLESS_FONT = (package_files('ocrmypdf.data') / GLYPHLESS_FONT_NAME).read_bytes()\n    CHAR_ASPECT = 2\n\n    def __init__(self):\n        pass\n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n                                                   \n        return len(unicodedata.normalize(\"NFKC\", text)) * (fontsize / self.CHAR_ASPECT)\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('utf-16be')\n\n    def register(self, pdf: Pdf):\n                   \n        PLACEHOLDER = Name.Placeholder\n\n        basefont = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                DescendantFonts=[PLACEHOLDER],\n                Encoding=Name(\"/Identity-H\"),\n                Subtype=Name.Type0,\n                ToUnicode=PLACEHOLDER,\n                Type=Name.Font,\n            )\n        )\n        cid_font_type2 = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                CIDToGIDMap=PLACEHOLDER,\n                CIDSystemInfo=Dictionary(\n                    Ordering=\"Identity\",\n                    Registry=\"Adobe\",\n                    Supplement=0,\n                ),\n                FontDescriptor=PLACEHOLDER,\n                Subtype=Name.CIDFontType2,\n                Type=Name.Font,\n                DW=1000 // self.CHAR_ASPECT,\n            )\n        )\n        basefont.DescendantFonts = [cid_font_type2]\n        cid_font_type2.CIDToGIDMap = pdf.make_stream(\n            self.CID_TO_GID_DATA, Filter=Name.FlateDecode\n        )\n        basefont.ToUnicode = pdf.make_stream(\n            b\"/CIDInit /ProcSet findresource begin\\n\"\n            b\"12 dict begin\\n\"\n            b\"begincmap\\n\"\n            b\"/CIDSystemInfo\\n\"\n            b\"<<\\n\"\n            b\"  /Registry (Adobe)\\n\"\n            b\"  /Ordering (UCS)\\n\"\n            b\"  /Supplement 0\\n\"\n            b\">> def\\n\"\n            b\"/CMapName /Adobe-Identify-UCS def\\n\"\n            b\"/CMapType 2 def\\n\"\n            b\"1 begincodespacerange\\n\"\n            b\"<0000> <FFFF>\\n\"\n            b\"endcodespacerange\\n\"\n            b\"1 beginbfrange\\n\"\n            b\"<0000> <FFFF> <0000>\\n\"\n            b\"endbfrange\\n\"\n            b\"endcmap\\n\"\n            b\"CMapName currentdict /CMap defineresource pop\\n\"\n            b\"end\\n\"\n            b\"end\\n\"\n        )\n        font_descriptor = pdf.make_indirect(\n            Dictionary(\n                Ascent=1000,\n                CapHeight=1000,\n                Descent=-1,\n                Flags=5,                            \n                FontBBox=[0, 0, 1000 // self.CHAR_ASPECT, 1000],\n                FontFile2=PLACEHOLDER,\n                FontName=Name.GlyphLessFont,\n                ItalicAngle=0,\n                StemV=80,\n                Type=Name.FontDescriptor,\n            )\n        )\n        font_descriptor.FontFile2 = pdf.make_stream(self.GLYPHLESS_FONT)\n        cid_font_type2.FontDescriptor = font_descriptor\n        return basefont", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "Courier", "whole_func_string": "class Courier(EncodableFont):\n                       \n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')\n\n    def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_code_string": "class Courier(EncodableFont):\n                       \n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')\n\n    def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_encode", "whole_func_string": "def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_code_string": "def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "__init__", "whole_func_string": "def __init__(self):\n        pass", "func_code_string": "def __init__(self):\n        pass", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_width", "whole_func_string": "def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n                                                   \n        return len(unicodedata.normalize(\"NFKC\", text)) * (fontsize / self.CHAR_ASPECT)", "func_code_string": "def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n                                                   \n        return len(unicodedata.normalize(\"NFKC\", text)) * (fontsize / self.CHAR_ASPECT)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_encode", "whole_func_string": "def text_encode(self, text: str) -> bytes:\n        return text.encode('utf-16be')", "func_code_string": "def text_encode(self, text: str) -> bytes:\n        return text.encode('utf-16be')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "register", "whole_func_string": "def register(self, pdf: Pdf):\n                   \n        PLACEHOLDER = Name.Placeholder\n\n        basefont = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                DescendantFonts=[PLACEHOLDER],\n                Encoding=Name(\"/Identity-H\"),\n                Subtype=Name.Type0,\n                ToUnicode=PLACEHOLDER,\n                Type=Name.Font,\n            )\n        )\n        cid_font_type2 = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                CIDToGIDMap=PLACEHOLDER,\n                CIDSystemInfo=Dictionary(\n                    Ordering=\"Identity\",\n                    Registry=\"Adobe\",\n                    Supplement=0,\n                ),\n                FontDescriptor=PLACEHOLDER,\n                Subtype=Name.CIDFontType2,\n                Type=Name.Font,\n                DW=1000 // self.CHAR_ASPECT,\n            )\n        )\n        basefont.DescendantFonts = [cid_font_type2]\n        cid_font_type2.CIDToGIDMap = pdf.make_stream(\n            self.CID_TO_GID_DATA, Filter=Name.FlateDecode\n        )\n        basefont.ToUnicode = pdf.make_stream(\n            b\"/CIDInit /ProcSet findresource begin\\n\"\n            b\"12 dict begin\\n\"\n            b\"begincmap\\n\"\n            b\"/CIDSystemInfo\\n\"\n            b\"<<\\n\"\n            b\"  /Registry (Adobe)\\n\"\n            b\"  /Ordering (UCS)\\n\"\n            b\"  /Supplement 0\\n\"\n            b\">> def\\n\"\n            b\"/CMapName /Adobe-Identify-UCS def\\n\"\n            b\"/CMapType 2 def\\n\"\n            b\"1 begincodespacerange\\n\"\n            b\"<0000> <FFFF>\\n\"\n            b\"endcodespacerange\\n\"\n            b\"1 beginbfrange\\n\"\n            b\"<0000> <FFFF> <0000>\\n\"\n            b\"endbfrange\\n\"\n            b\"endcmap\\n\"\n            b\"CMapName currentdict /CMap defineresource pop\\n\"\n            b\"end\\n\"\n            b\"end\\n\"\n        )\n        font_descriptor = pdf.make_indirect(\n            Dictionary(\n                Ascent=1000,\n                CapHeight=1000,\n                Descent=-1,\n                Flags=5,                            \n                FontBBox=[0, 0, 1000 // self.CHAR_ASPECT, 1000],\n                FontFile2=PLACEHOLDER,\n                FontName=Name.GlyphLessFont,\n                ItalicAngle=0,\n                StemV=80,\n                Type=Name.FontDescriptor,\n            )\n        )\n        font_descriptor.FontFile2 = pdf.make_stream(self.GLYPHLESS_FONT)\n        cid_font_type2.FontDescriptor = font_descriptor\n        return basefont", "func_code_string": "def register(self, pdf: Pdf):\n                   \n        PLACEHOLDER = Name.Placeholder\n\n        basefont = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                DescendantFonts=[PLACEHOLDER],\n                Encoding=Name(\"/Identity-H\"),\n                Subtype=Name.Type0,\n                ToUnicode=PLACEHOLDER,\n                Type=Name.Font,\n            )\n        )\n        cid_font_type2 = pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.GlyphLessFont,\n                CIDToGIDMap=PLACEHOLDER,\n                CIDSystemInfo=Dictionary(\n                    Ordering=\"Identity\",\n                    Registry=\"Adobe\",\n                    Supplement=0,\n                ),\n                FontDescriptor=PLACEHOLDER,\n                Subtype=Name.CIDFontType2,\n                Type=Name.Font,\n                DW=1000 // self.CHAR_ASPECT,\n            )\n        )\n        basefont.DescendantFonts = [cid_font_type2]\n        cid_font_type2.CIDToGIDMap = pdf.make_stream(\n            self.CID_TO_GID_DATA, Filter=Name.FlateDecode\n        )\n        basefont.ToUnicode = pdf.make_stream(\n            b\"/CIDInit /ProcSet findresource begin\\n\"\n            b\"12 dict begin\\n\"\n            b\"begincmap\\n\"\n            b\"/CIDSystemInfo\\n\"\n            b\"<<\\n\"\n            b\"  /Registry (Adobe)\\n\"\n            b\"  /Ordering (UCS)\\n\"\n            b\"  /Supplement 0\\n\"\n            b\">> def\\n\"\n            b\"/CMapName /Adobe-Identify-UCS def\\n\"\n            b\"/CMapType 2 def\\n\"\n            b\"1 begincodespacerange\\n\"\n            b\"<0000> <FFFF>\\n\"\n            b\"endcodespacerange\\n\"\n            b\"1 beginbfrange\\n\"\n            b\"<0000> <FFFF> <0000>\\n\"\n            b\"endbfrange\\n\"\n            b\"endcmap\\n\"\n            b\"CMapName currentdict /CMap defineresource pop\\n\"\n            b\"end\\n\"\n            b\"end\\n\"\n        )\n        font_descriptor = pdf.make_indirect(\n            Dictionary(\n                Ascent=1000,\n                CapHeight=1000,\n                Descent=-1,\n                Flags=5,                            \n                FontBBox=[0, 0, 1000 // self.CHAR_ASPECT, 1000],\n                FontFile2=PLACEHOLDER,\n                FontName=Name.GlyphLessFont,\n                ItalicAngle=0,\n                StemV=80,\n                Type=Name.FontDescriptor,\n            )\n        )\n        font_descriptor.FontFile2 = pdf.make_stream(self.GLYPHLESS_FONT)\n        cid_font_type2.FontDescriptor = font_descriptor\n        return basefont", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_width", "whole_func_string": "def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize", "func_code_string": "def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_encode", "whole_func_string": "def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')", "func_code_string": "def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "register", "whole_func_string": "def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_code_string": "def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py", "func_name": "_exec_hocrtransform_sync", "whole_func_string": "def _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\n                            \n    hocr_json = page_context.get_path('hocr.json')\n    if not hocr_json.exists():\n                                                             \n        return HOCRResult(pageno=page_context.pageno)\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\n    hocr_result.textpdf = render_hocr_page(\n        page_context.get_path('ocr_hocr.hocr'), page_context\n    )\n    return hocr_result", "func_code_string": "def _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\n                            \n    hocr_json = page_context.get_path('hocr.json')\n    if not hocr_json.exists():\n                                                             \n        return HOCRResult(pageno=page_context.pageno)\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\n    hocr_result.textpdf = render_hocr_page(\n        page_context.get_path('ocr_hocr.hocr'), page_context\n    )\n    return hocr_result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py", "func_name": "exec_hocr_to_ocr_pdf", "whole_func_string": "def exec_hocr_to_ocr_pdf(context: PdfContext, executor: Executor) -> Sequence[str]:\n                                        \n                                      \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Continue processing %d pages concurrently\", max_workers)\n\n    ocrgraft = OcrGrafter(context)\n\n    def graft_page(result: HOCRResult, pbar: ProgressBar):\n                                                        \n        try:\n            set_thread_pageno(result.pageno + 1)\n            pbar.update()\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.textpdf,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update()\n        finally:\n            set_thread_pageno(None)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=(2 * len(context.pdfinfo)),\n            desc='Grafting hOCR to PDF',\n            unit='page',\n            unit_scale=0.5,\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_hocrtransform_sync,\n        task_arguments=context.get_page_context_args(),\n        task_finished=graft_page,\n    )\n\n    pdf = ocrgraft.finalize()\n    messages: Sequence[str] = []\n    if options.output_type != 'none':\n                            \n        log.info(\"Postprocessing...\")\n        pdf, messages = postprocess(pdf, context, executor)\n\n                                                                              \n        copy_final(pdf, options.output_file, None)\n    return messages", "func_code_string": "def exec_hocr_to_ocr_pdf(context: PdfContext, executor: Executor) -> Sequence[str]:\n                                        \n                                      \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Continue processing %d pages concurrently\", max_workers)\n\n    ocrgraft = OcrGrafter(context)\n\n    def graft_page(result: HOCRResult, pbar: ProgressBar):\n                                                        \n        try:\n            set_thread_pageno(result.pageno + 1)\n            pbar.update()\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.textpdf,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update()\n        finally:\n            set_thread_pageno(None)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=(2 * len(context.pdfinfo)),\n            desc='Grafting hOCR to PDF',\n            unit='page',\n            unit_scale=0.5,\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_hocrtransform_sync,\n        task_arguments=context.get_page_context_args(),\n        task_finished=graft_page,\n    )\n\n    pdf = ocrgraft.finalize()\n    messages: Sequence[str] = []\n    if options.output_type != 'none':\n                            \n        log.info(\"Postprocessing...\")\n        pdf, messages = postprocess(pdf, context, executor)\n\n                                                                              \n        copy_final(pdf, options.output_file, None)\n    return messages", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py", "func_name": "run_hocr_to_ocr_pdf_pipeline", "whole_func_string": "def run_hocr_to_ocr_pdf_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n                                                           \n    with manage_work_folder(\n        work_folder=options.work_folder, retain=True, print_location=False\n    ) as work_folder:\n        executor = setup_pipeline(options, plugin_manager)\n        origin_pdf = work_folder / 'origin.pdf'\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n        plugin_manager.hook.check_options(options=options)\n        optimize_messages = exec_hocr_to_ocr_pdf(context, executor)\n\n        return report_output_pdf(options, origin_pdf, optimize_messages)", "func_code_string": "def run_hocr_to_ocr_pdf_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n                                                           \n    with manage_work_folder(\n        work_folder=options.work_folder, retain=True, print_location=False\n    ) as work_folder:\n        executor = setup_pipeline(options, plugin_manager)\n        origin_pdf = work_folder / 'origin.pdf'\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n        plugin_manager.hook.check_options(options=options)\n        optimize_messages = exec_hocr_to_ocr_pdf(context, executor)\n\n        return report_output_pdf(options, origin_pdf, optimize_messages)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py", "func_name": "graft_page", "whole_func_string": "def graft_page(result: HOCRResult, pbar: ProgressBar):\n                                                        \n        try:\n            set_thread_pageno(result.pageno + 1)\n            pbar.update()\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.textpdf,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update()\n        finally:\n            set_thread_pageno(None)", "func_code_string": "def graft_page(result: HOCRResult, pbar: ProgressBar):\n                                                        \n        try:\n            set_thread_pageno(result.pageno + 1)\n            pbar.update()\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.textpdf,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update()\n        finally:\n            set_thread_pageno(None)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "_set_logging_tls", "whole_func_string": "def _set_logging_tls(tls):\n                                                                       \n    old_factory = logging.getLogRecordFactory()\n\n    def wrapper(*args, **kwargs):\n        record = old_factory(*args, **kwargs)\n        if hasattr(tls, 'pageno'):\n            record.pageno = tls.pageno\n        return record\n\n    logging.setLogRecordFactory(wrapper)", "func_code_string": "def _set_logging_tls(tls):\n                                                                       \n    old_factory = logging.getLogRecordFactory()\n\n    def wrapper(*args, **kwargs):\n        record = old_factory(*args, **kwargs)\n        if hasattr(tls, 'pageno'):\n            record.pageno = tls.pageno\n        return record\n\n    logging.setLogRecordFactory(wrapper)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "set_thread_pageno", "whole_func_string": "def set_thread_pageno(pageno: int | None):\n                                                                          \n    tls.pageno = pageno", "func_code_string": "def set_thread_pageno(pageno: int | None):\n                                                                          \n    tls.pageno = pageno", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "PageResult", "whole_func_string": "class PageResult(NamedTuple):\n                                                    \n\n    pageno: int\n    \"\"\"Page number, 0-based.\"\"\"\n\n    pdf_page_from_image: Path | None = None\n    \"\"\"Single page PDF from image.\"\"\"\n\n    ocr: Path | None = None\n    \"\"\"Single page OCR PDF.\"\"\"\n\n    text: Path | None = None\n    \"\"\"Single page text file.\"\"\"\n\n    orientation_correction: int = 0\n    \"\"\"Orientation correction in degrees.\"\"\"", "func_code_string": "class PageResult(NamedTuple):\n                                                    \n\n    pageno: int\n    \"\"\"Page number, 0-based.\"\"\"\n\n    pdf_page_from_image: Path | None = None\n    \"\"\"Single page PDF from image.\"\"\"\n\n    ocr: Path | None = None\n    \"\"\"Single page OCR PDF.\"\"\"\n\n    text: Path | None = None\n    \"\"\"Single page text file.\"\"\"\n\n    orientation_correction: int = 0\n    \"\"\"Orientation correction in degrees.\"\"\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "HOCRResultEncoder", "whole_func_string": "class HOCRResultEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, Path):\n            return {'Path': str(obj)}\n        return super().default(obj)", "func_code_string": "class HOCRResultEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, Path):\n            return {'Path': str(obj)}\n        return super().default(obj)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "HOCRResultDecoder", "whole_func_string": "class HOCRResultDecoder(json.JSONDecoder):\n    def __init__(self, *args, **kwargs):\n        super().__init__(object_hook=self.dict_to_object, *args, **kwargs)\n\n    def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_code_string": "class HOCRResultDecoder(json.JSONDecoder):\n    def __init__(self, *args, **kwargs):\n        super().__init__(object_hook=self.dict_to_object, *args, **kwargs)\n\n    def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "HOCRResult", "whole_func_string": "class HOCRResult:\n                                                  \n\n    pageno: int\n    \"\"\"Page number, 0-based.\"\"\"\n\n    pdf_page_from_image: Path | None = None\n    \"\"\"Single page PDF from image.\"\"\"\n\n    hocr: Path | None = None\n    \"\"\"Single page hOCR file.\"\"\"\n\n    textpdf: Path | None = None\n    \"\"\"hOCR file after conversion to PDF.\"\"\"\n\n    orientation_correction: int = 0\n    \"\"\"Orientation correction in degrees.\"\"\"\n\n    @classmethod\n    def from_json(cls, json_str: str) -> HOCRResult:\n                                             \n        return cls(**json.loads(json_str, cls=HOCRResultDecoder))\n\n    def to_json(self) -> str:\n                                         \n        return json.dumps(self.__dict__, cls=HOCRResultEncoder)", "func_code_string": "class HOCRResult:\n                                                  \n\n    pageno: int\n    \"\"\"Page number, 0-based.\"\"\"\n\n    pdf_page_from_image: Path | None = None\n    \"\"\"Single page PDF from image.\"\"\"\n\n    hocr: Path | None = None\n    \"\"\"Single page hOCR file.\"\"\"\n\n    textpdf: Path | None = None\n    \"\"\"hOCR file after conversion to PDF.\"\"\"\n\n    orientation_correction: int = 0\n    \"\"\"Orientation correction in degrees.\"\"\"\n\n    @classmethod\n    def from_json(cls, json_str: str) -> HOCRResult:\n                                             \n        return cls(**json.loads(json_str, cls=HOCRResultDecoder))\n\n    def to_json(self) -> str:\n                                         \n        return json.dumps(self.__dict__, cls=HOCRResultEncoder)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "configure_debug_logging", "whole_func_string": "def configure_debug_logging(\n    log_filename: Path, prefix: str = ''\n) -> tuple[logging.FileHandler, Callable[[], None]]:\n           \n    log_file_handler = logging.FileHandler(log_filename, delay=True)\n    log_file_handler.setLevel(logging.DEBUG)\n    formatter = logging.Formatter(\n        '[%(asctime)s] - %(name)s - %(levelname)7s -%(pageno)s %(message)s'\n    )\n    log_file_handler.setFormatter(formatter)\n    log_file_handler.addFilter(PageNumberFilter())\n    logging.getLogger(prefix).addHandler(log_file_handler)\n\n    def remover():\n        try:\n            logging.getLogger(prefix).removeHandler(log_file_handler)\n            log_file_handler.close()\n        except OSError as e:\n            print(e, file=sys.stderr)\n\n    return log_file_handler, remover", "func_code_string": "def configure_debug_logging(\n    log_filename: Path, prefix: str = ''\n) -> tuple[logging.FileHandler, Callable[[], None]]:\n           \n    log_file_handler = logging.FileHandler(log_filename, delay=True)\n    log_file_handler.setLevel(logging.DEBUG)\n    formatter = logging.Formatter(\n        '[%(asctime)s] - %(name)s - %(levelname)7s -%(pageno)s %(message)s'\n    )\n    log_file_handler.setFormatter(formatter)\n    log_file_handler.addFilter(PageNumberFilter())\n    logging.getLogger(prefix).addHandler(log_file_handler)\n\n    def remover():\n        try:\n            logging.getLogger(prefix).removeHandler(log_file_handler)\n            log_file_handler.close()\n        except OSError as e:\n            print(e, file=sys.stderr)\n\n    return log_file_handler, remover", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "worker_init", "whole_func_string": "def worker_init(max_pixels: int | None) -> None:\n                                                \n                                                                            \n                                                                               \n                                          \n    PIL.Image.MAX_IMAGE_PIXELS = max_pixels\n    pikepdf_enable_mmap()", "func_code_string": "def worker_init(max_pixels: int | None) -> None:\n                                                \n                                                                            \n                                                                               \n                                          \n    PIL.Image.MAX_IMAGE_PIXELS = max_pixels\n    pikepdf_enable_mmap()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "manage_debug_log_handler", "whole_func_string": "def manage_debug_log_handler(\n    *,\n    options: argparse.Namespace,\n    work_folder: Path,\n):\n    remover = None\n    if (options.keep_temporary_files or options.verbose >= 1) and not os.environ.get(\n        'PYTEST_CURRENT_TEST', ''\n    ):\n                                                                       \n                                                                                   \n                                \n        _debug_log_handler, remover = configure_debug_logging(\n            work_folder / \"debug.log\", prefix=\"\"\n        )                    \n    try:\n        yield\n    finally:\n        if remover:\n            remover()", "func_code_string": "def manage_debug_log_handler(\n    *,\n    options: argparse.Namespace,\n    work_folder: Path,\n):\n    remover = None\n    if (options.keep_temporary_files or options.verbose >= 1) and not os.environ.get(\n        'PYTEST_CURRENT_TEST', ''\n    ):\n                                                                       \n                                                                                   \n                                \n        _debug_log_handler, remover = configure_debug_logging(\n            work_folder / \"debug.log\", prefix=\"\"\n        )                    \n    try:\n        yield\n    finally:\n        if remover:\n            remover()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "_print_temp_folder_location", "whole_func_string": "def _print_temp_folder_location(work_folder: Path):\n                                                          \n    msgs = [f\"Temporary working files retained at:\\n{work_folder}\"]\n    if running_in_docker():                    \n        msgs.append(\n            \"OCRmyPDF is running in a Docker container, \"\n            \"so the files will be inside the container.\"\n        )\n    elif running_in_snap():                    \n        msgs.append(\n            \"OCRmyPDF is running in a Snap container, \"\n            \"so the files will be inside the container.\"\n        )\n    print('\\n'.join(msgs), file=sys.stderr)", "func_code_string": "def _print_temp_folder_location(work_folder: Path):\n                                                          \n    msgs = [f\"Temporary working files retained at:\\n{work_folder}\"]\n    if running_in_docker():                    \n        msgs.append(\n            \"OCRmyPDF is running in a Docker container, \"\n            \"so the files will be inside the container.\"\n        )\n    elif running_in_snap():                    \n        msgs.append(\n            \"OCRmyPDF is running in a Snap container, \"\n            \"so the files will be inside the container.\"\n        )\n    print('\\n'.join(msgs), file=sys.stderr)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "manage_work_folder", "whole_func_string": "def manage_work_folder(*, work_folder: Path, retain: bool, print_location: bool):\n    try:\n        yield work_folder\n    finally:\n        if retain:\n            if print_location:\n                _print_temp_folder_location(work_folder)\n        else:\n            shutil.rmtree(work_folder, ignore_errors=True)", "func_code_string": "def manage_work_folder(*, work_folder: Path, retain: bool, print_location: bool):\n    try:\n        yield work_folder\n    finally:\n        if retain:\n            if print_location:\n                _print_temp_folder_location(work_folder)\n        else:\n            shutil.rmtree(work_folder, ignore_errors=True)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "cli_exception_handler", "whole_func_string": "def cli_exception_handler(\n    fn: Callable[[argparse.Namespace, OcrmypdfPluginManager], ExitCode],\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    try:\n                                                                                 \n                                                                                    \n               \n        return fn(options, plugin_manager)\n    except KeyboardInterrupt:\n        if options.verbose >= 1:\n            log.exception(\"KeyboardInterrupt\")\n        else:\n            log.error(\"KeyboardInterrupt\")\n        return ExitCode.ctrl_c\n    except ExitCodeException as e:\n        e = cast(ExitCodeException, e)\n        if options.verbose >= 1:\n            log.exception(\"ExitCodeException\")\n        elif str(e):\n            log.error(\"%s: %s\", type(e).__name__, str(e))\n        else:\n            log.error(type(e).__name__)\n        return e.exit_code\n    except PIL.Image.DecompressionBombError:\n        log.exception(\n            \"A decompression bomb error was encountered while executing the \"\n            \"pipeline. Use the argument --max-image-mpixels to raise the maximum \"\n            \"image pixel limit.\"\n        )\n        return ExitCode.other_error\n    except (\n        BrokenProcessPool,\n        BrokenThreadPool,\n    ):\n        log.exception(\n            \"A worker process was terminated unexpectedly. This is known to occur if \"\n            \"processing your file takes all available swap space and RAM. It may \"\n            \"help to try again with a smaller number of jobs, using the --jobs \"\n            \"argument.\"\n        )\n        return ExitCode.child_process_error\n    except Exception:                                \n        log.exception(\"An exception occurred while executing the pipeline\")\n        return ExitCode.other_error", "func_code_string": "def cli_exception_handler(\n    fn: Callable[[argparse.Namespace, OcrmypdfPluginManager], ExitCode],\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    try:\n                                                                                 \n                                                                                    \n               \n        return fn(options, plugin_manager)\n    except KeyboardInterrupt:\n        if options.verbose >= 1:\n            log.exception(\"KeyboardInterrupt\")\n        else:\n            log.error(\"KeyboardInterrupt\")\n        return ExitCode.ctrl_c\n    except ExitCodeException as e:\n        e = cast(ExitCodeException, e)\n        if options.verbose >= 1:\n            log.exception(\"ExitCodeException\")\n        elif str(e):\n            log.error(\"%s: %s\", type(e).__name__, str(e))\n        else:\n            log.error(type(e).__name__)\n        return e.exit_code\n    except PIL.Image.DecompressionBombError:\n        log.exception(\n            \"A decompression bomb error was encountered while executing the \"\n            \"pipeline. Use the argument --max-image-mpixels to raise the maximum \"\n            \"image pixel limit.\"\n        )\n        return ExitCode.other_error\n    except (\n        BrokenProcessPool,\n        BrokenThreadPool,\n    ):\n        log.exception(\n            \"A worker process was terminated unexpectedly. This is known to occur if \"\n            \"processing your file takes all available swap space and RAM. It may \"\n            \"help to try again with a smaller number of jobs, using the --jobs \"\n            \"argument.\"\n        )\n        return ExitCode.child_process_error\n    except Exception:                                \n        log.exception(\"An exception occurred while executing the pipeline\")\n        return ExitCode.other_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "setup_pipeline", "whole_func_string": "def setup_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> Executor:\n                                                                              \n                                                                \n                                                                  \n    if not options.jobs:\n        options.jobs = available_cpu_count()\n\n    pikepdf_enable_mmap()\n    executor = setup_executor(plugin_manager)\n    return executor", "func_code_string": "def setup_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> Executor:\n                                                                              \n                                                                \n                                                                  \n    if not options.jobs:\n        options.jobs = available_cpu_count()\n\n    pikepdf_enable_mmap()\n    executor = setup_executor(plugin_manager)\n    return executor", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "do_get_pdfinfo", "whole_func_string": "def do_get_pdfinfo(\n    pdf_path: Path, executor: Executor, options: argparse.Namespace\n) -> PdfInfo:\n    return get_pdfinfo(\n        pdf_path,\n        executor=executor,\n        detailed_analysis=options.redo_ocr,\n        progbar=options.progress_bar,\n        max_workers=options.jobs,\n        use_threads=options.use_threads,\n        check_pages=options.pages,\n    )", "func_code_string": "def do_get_pdfinfo(\n    pdf_path: Path, executor: Executor, options: argparse.Namespace\n) -> PdfInfo:\n    return get_pdfinfo(\n        pdf_path,\n        executor=executor,\n        detailed_analysis=options.redo_ocr,\n        progbar=options.progress_bar,\n        max_workers=options.jobs,\n        use_threads=options.use_threads,\n        check_pages=options.pages,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "preprocess", "whole_func_string": "def preprocess(\n    page_context: PageContext,\n    image: Path,\n    remove_background: bool,\n    deskew: bool,\n    clean: bool,\n) -> Path:\n                              \n    if remove_background:\n        image = preprocess_remove_background(image, page_context)\n    if deskew:\n        image = preprocess_deskew(image, page_context)\n    if clean:\n        image = preprocess_clean(image, page_context)\n    return image", "func_code_string": "def preprocess(\n    page_context: PageContext,\n    image: Path,\n    remove_background: bool,\n    deskew: bool,\n    clean: bool,\n) -> Path:\n                              \n    if remove_background:\n        image = preprocess_remove_background(image, page_context)\n    if deskew:\n        image = preprocess_deskew(image, page_context)\n    if clean:\n        image = preprocess_clean(image, page_context)\n    return image", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "make_intermediate_images", "whole_func_string": "def make_intermediate_images(\n    page_context: PageContext, orientation_correction: int\n) -> tuple[Path, Path | None]:\n                                                              \n    options = page_context.options\n\n    ocr_image = preprocess_out = None\n    rasterize_out = rasterize(\n        page_context.origin,\n        page_context,\n        correction=orientation_correction,\n        remove_vectors=False,\n    )\n\n    if not any([options.clean, options.clean_final, options.remove_vectors]):\n        ocr_image = preprocess_out = preprocess(\n            page_context,\n            rasterize_out,\n            options.remove_background,\n            options.deskew,\n            clean=False,\n        )\n    else:\n        if not options.lossless_reconstruction:\n            preprocess_out = preprocess(\n                page_context,\n                rasterize_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean_final,\n            )\n        if options.remove_vectors:\n            rasterize_ocr_out = rasterize(\n                page_context.origin,\n                page_context,\n                correction=orientation_correction,\n                remove_vectors=True,\n                output_tag='_ocr',\n            )\n        else:\n            rasterize_ocr_out = rasterize_out\n\n        if (\n            preprocess_out\n            and rasterize_ocr_out == rasterize_out\n            and options.clean == options.clean_final\n        ):\n                                                                            \n            ocr_image = preprocess_out\n        else:\n            ocr_image = preprocess(\n                page_context,\n                rasterize_ocr_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean,\n            )\n    return ocr_image, preprocess_out", "func_code_string": "def make_intermediate_images(\n    page_context: PageContext, orientation_correction: int\n) -> tuple[Path, Path | None]:\n                                                              \n    options = page_context.options\n\n    ocr_image = preprocess_out = None\n    rasterize_out = rasterize(\n        page_context.origin,\n        page_context,\n        correction=orientation_correction,\n        remove_vectors=False,\n    )\n\n    if not any([options.clean, options.clean_final, options.remove_vectors]):\n        ocr_image = preprocess_out = preprocess(\n            page_context,\n            rasterize_out,\n            options.remove_background,\n            options.deskew,\n            clean=False,\n        )\n    else:\n        if not options.lossless_reconstruction:\n            preprocess_out = preprocess(\n                page_context,\n                rasterize_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean_final,\n            )\n        if options.remove_vectors:\n            rasterize_ocr_out = rasterize(\n                page_context.origin,\n                page_context,\n                correction=orientation_correction,\n                remove_vectors=True,\n                output_tag='_ocr',\n            )\n        else:\n            rasterize_ocr_out = rasterize_out\n\n        if (\n            preprocess_out\n            and rasterize_ocr_out == rasterize_out\n            and options.clean == options.clean_final\n        ):\n                                                                            \n            ocr_image = preprocess_out\n        else:\n            ocr_image = preprocess(\n                page_context,\n                rasterize_ocr_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean,\n            )\n    return ocr_image, preprocess_out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "process_page", "whole_func_string": "def process_page(page_context: PageContext) -> tuple[Path, Path | None, int]:\n                                                                               \n    options = page_context.options\n    orientation_correction = 0\n    if options.rotate_pages:\n                   \n        rasterize_preview_out = rasterize_preview(page_context.origin, page_context)\n        orientation_correction = get_orientation_correction(\n            rasterize_preview_out, page_context\n        )\n\n    ocr_image, preprocess_out = make_intermediate_images(\n        page_context, orientation_correction\n    )\n    ocr_image_out = create_ocr_image(ocr_image, page_context)\n\n    pdf_page_from_image_out = None\n    if not options.lossless_reconstruction:\n        assert preprocess_out\n        visible_image_out = preprocess_out\n        if should_visible_page_image_use_jpg(page_context.pageinfo):\n            visible_image_out = create_visible_page_jpg(visible_image_out, page_context)\n        filtered_image = page_context.plugin_manager.hook.filter_page_image(\n            page=page_context, image_filename=visible_image_out\n        )\n        if filtered_image is not None:                              \n            visible_image_out = filtered_image\n        pdf_page_from_image_out = create_pdf_page_from_image(\n            visible_image_out, page_context, orientation_correction\n        )\n    return ocr_image_out, pdf_page_from_image_out, orientation_correction", "func_code_string": "def process_page(page_context: PageContext) -> tuple[Path, Path | None, int]:\n                                                                               \n    options = page_context.options\n    orientation_correction = 0\n    if options.rotate_pages:\n                   \n        rasterize_preview_out = rasterize_preview(page_context.origin, page_context)\n        orientation_correction = get_orientation_correction(\n            rasterize_preview_out, page_context\n        )\n\n    ocr_image, preprocess_out = make_intermediate_images(\n        page_context, orientation_correction\n    )\n    ocr_image_out = create_ocr_image(ocr_image, page_context)\n\n    pdf_page_from_image_out = None\n    if not options.lossless_reconstruction:\n        assert preprocess_out\n        visible_image_out = preprocess_out\n        if should_visible_page_image_use_jpg(page_context.pageinfo):\n            visible_image_out = create_visible_page_jpg(visible_image_out, page_context)\n        filtered_image = page_context.plugin_manager.hook.filter_page_image(\n            page=page_context, image_filename=visible_image_out\n        )\n        if filtered_image is not None:                              \n            visible_image_out = filtered_image\n        pdf_page_from_image_out = create_pdf_page_from_image(\n            visible_image_out, page_context, orientation_correction\n        )\n    return ocr_image_out, pdf_page_from_image_out, orientation_correction", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "postprocess", "whole_func_string": "def postprocess(\n    pdf_file: Path, context: PdfContext, executor: Executor\n) -> tuple[Path, Sequence[str]]:\n                                   \n                        \n    with Pdf.open(pdf_file) as pdf:\n        fix_annots = context.get_path('fix_annots.pdf')\n        if remove_broken_goto_annotations(pdf):\n            pdf.save(fix_annots)\n            pdf_out = fix_annots\n        else:\n            pdf_out = pdf_file\n    if context.options.output_type.startswith('pdfa'):\n        ps_stub_out = generate_postscript_stub(context)\n        pdf_out = convert_to_pdfa(pdf_out, ps_stub_out, context)\n\n    optimizing = context.plugin_manager.hook.is_optimization_enabled(context=context)\n    save_settings = get_pdf_save_settings(context.options.output_type)\n    save_settings['linearize'] = not optimizing and should_linearize(pdf_out, context)\n\n    pdf_out = metadata_fixup(pdf_out, context, pdf_save_settings=save_settings)\n    return optimize_pdf(pdf_out, context, executor)", "func_code_string": "def postprocess(\n    pdf_file: Path, context: PdfContext, executor: Executor\n) -> tuple[Path, Sequence[str]]:\n                                   \n                        \n    with Pdf.open(pdf_file) as pdf:\n        fix_annots = context.get_path('fix_annots.pdf')\n        if remove_broken_goto_annotations(pdf):\n            pdf.save(fix_annots)\n            pdf_out = fix_annots\n        else:\n            pdf_out = pdf_file\n    if context.options.output_type.startswith('pdfa'):\n        ps_stub_out = generate_postscript_stub(context)\n        pdf_out = convert_to_pdfa(pdf_out, ps_stub_out, context)\n\n    optimizing = context.plugin_manager.hook.is_optimization_enabled(context=context)\n    save_settings = get_pdf_save_settings(context.options.output_type)\n    save_settings['linearize'] = not optimizing and should_linearize(pdf_out, context)\n\n    pdf_out = metadata_fixup(pdf_out, context, pdf_save_settings=save_settings)\n    return optimize_pdf(pdf_out, context, executor)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "report_output_pdf", "whole_func_string": "def report_output_pdf(options, start_input_file, optimize_messages) -> ExitCode:\n    if options.output_file == '-':\n        log.info(\"Output sent to stdout\")\n    elif hasattr(options.output_file, 'writable') and options.output_file.writable():\n        log.info(\"Output written to stream\")\n    elif samefile(options.output_file, Path(os.devnull)):\n        pass                                        \n    else:\n        if options.output_type.startswith('pdfa'):\n            pdfa_info = file_claims_pdfa(options.output_file)\n            if pdfa_info['pass']:\n                log.info(\"Output file is a %s (as expected)\", pdfa_info['conformance'])\n            else:\n                log.warning(\n                    \"Output file is a valid PDF, but conversion to PDF/A did not \"\n                    \"succeed (issue: %s)\",\n                    pdfa_info['conformance'],\n                )\n                return ExitCode.pdfa_conversion_failed\n        if not check_pdf(options.output_file):\n            log.warning('Output file: The generated PDF is INVALID')\n            return ExitCode.invalid_output_pdf\n        report_output_file_size(\n            options, start_input_file, options.output_file, optimize_messages\n        )\n    return ExitCode.ok", "func_code_string": "def report_output_pdf(options, start_input_file, optimize_messages) -> ExitCode:\n    if options.output_file == '-':\n        log.info(\"Output sent to stdout\")\n    elif hasattr(options.output_file, 'writable') and options.output_file.writable():\n        log.info(\"Output written to stream\")\n    elif samefile(options.output_file, Path(os.devnull)):\n        pass                                        \n    else:\n        if options.output_type.startswith('pdfa'):\n            pdfa_info = file_claims_pdfa(options.output_file)\n            if pdfa_info['pass']:\n                log.info(\"Output file is a %s (as expected)\", pdfa_info['conformance'])\n            else:\n                log.warning(\n                    \"Output file is a valid PDF, but conversion to PDF/A did not \"\n                    \"succeed (issue: %s)\",\n                    pdfa_info['conformance'],\n                )\n                return ExitCode.pdfa_conversion_failed\n        if not check_pdf(options.output_file):\n            log.warning('Output file: The generated PDF is INVALID')\n            return ExitCode.invalid_output_pdf\n        report_output_file_size(\n            options, start_input_file, options.output_file, optimize_messages\n        )\n    return ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "wrapper", "whole_func_string": "def wrapper(*args, **kwargs):\n        record = old_factory(*args, **kwargs)\n        if hasattr(tls, 'pageno'):\n            record.pageno = tls.pageno\n        return record", "func_code_string": "def wrapper(*args, **kwargs):\n        record = old_factory(*args, **kwargs)\n        if hasattr(tls, 'pageno'):\n            record.pageno = tls.pageno\n        return record", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "default", "whole_func_string": "def default(self, obj):\n        if isinstance(obj, Path):\n            return {'Path': str(obj)}\n        return super().default(obj)", "func_code_string": "def default(self, obj):\n        if isinstance(obj, Path):\n            return {'Path': str(obj)}\n        return super().default(obj)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "__init__", "whole_func_string": "def __init__(self, *args, **kwargs):\n        super().__init__(object_hook=self.dict_to_object, *args, **kwargs)", "func_code_string": "def __init__(self, *args, **kwargs):\n        super().__init__(object_hook=self.dict_to_object, *args, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "dict_to_object", "whole_func_string": "def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_code_string": "def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "from_json", "whole_func_string": "def from_json(cls, json_str: str) -> HOCRResult:\n                                             \n        return cls(**json.loads(json_str, cls=HOCRResultDecoder))", "func_code_string": "def from_json(cls, json_str: str) -> HOCRResult:\n                                             \n        return cls(**json.loads(json_str, cls=HOCRResultDecoder))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "to_json", "whole_func_string": "def to_json(self) -> str:\n                                         \n        return json.dumps(self.__dict__, cls=HOCRResultEncoder)", "func_code_string": "def to_json(self) -> str:\n                                         \n        return json.dumps(self.__dict__, cls=HOCRResultEncoder)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "remover", "whole_func_string": "def remover():\n        try:\n            logging.getLogger(prefix).removeHandler(log_file_handler)\n            log_file_handler.close()\n        except OSError as e:\n            print(e, file=sys.stderr)", "func_code_string": "def remover():\n        try:\n            logging.getLogger(prefix).removeHandler(log_file_handler)\n            log_file_handler.close()\n        except OSError as e:\n            print(e, file=sys.stderr)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "_image_to_ocr_text", "whole_func_string": "def _image_to_ocr_text(\n    page_context: PageContext, ocr_image_out: Path\n) -> tuple[Path, Path]:\n                                                                  \n    options = page_context.options\n    if options.pdf_renderer.startswith('hocr'):\n        hocr_out, text_out = ocr_engine_hocr(ocr_image_out, page_context)\n        ocr_out = render_hocr_page(hocr_out, page_context)\n    elif options.pdf_renderer == 'sandwich':\n        ocr_out, text_out = ocr_engine_textonly_pdf(ocr_image_out, page_context)\n    else:\n        raise NotImplementedError(f\"pdf_renderer {options.pdf_renderer}\")\n    return ocr_out, text_out", "func_code_string": "def _image_to_ocr_text(\n    page_context: PageContext, ocr_image_out: Path\n) -> tuple[Path, Path]:\n                                                                  \n    options = page_context.options\n    if options.pdf_renderer.startswith('hocr'):\n        hocr_out, text_out = ocr_engine_hocr(ocr_image_out, page_context)\n        ocr_out = render_hocr_page(hocr_out, page_context)\n    elif options.pdf_renderer == 'sandwich':\n        ocr_out, text_out = ocr_engine_textonly_pdf(ocr_image_out, page_context)\n    else:\n        raise NotImplementedError(f\"pdf_renderer {options.pdf_renderer}\")\n    return ocr_out, text_out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "_exec_page_sync", "whole_func_string": "def _exec_page_sync(page_context: PageContext) -> PageResult:\n                                                             \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return PageResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    ocr_out, text_out = _image_to_ocr_text(page_context, ocr_image_out)\n    return PageResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        ocr=ocr_out,\n        text=text_out,\n        orientation_correction=orientation_correction,\n    )", "func_code_string": "def _exec_page_sync(page_context: PageContext) -> PageResult:\n                                                             \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return PageResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    ocr_out, text_out = _image_to_ocr_text(page_context, ocr_image_out)\n    return PageResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        ocr=ocr_out,\n        text=text_out,\n        orientation_correction=orientation_correction,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "exec_concurrent", "whole_func_string": "def exec_concurrent(context: PdfContext, executor: Executor) -> Sequence[str]:\n                                                \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Start processing %d pages concurrently\", max_workers)\n\n    sidecars: list[Path | None] = [None] * len(context.pdfinfo)\n    ocrgraft = OcrGrafter(context)\n\n    def update_page(result: PageResult, pbar: ProgressBar):\n                                                               \n        try:\n            set_thread_pageno(result.pageno + 1)\n            sidecars[result.pageno] = result.text\n            pbar.update(0.5)\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.ocr,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update(0.5)\n        finally:\n            set_thread_pageno(None)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=len(context.pdfinfo),\n            desc='OCR' if options.tesseract_timeout > 0 else 'Image processing',\n            unit='page',\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_page_sync,\n        task_arguments=context.get_page_context_args(),\n        task_finished=update_page,\n    )\n\n                         \n    if options.sidecar:\n        text = merge_sidecars(sidecars, context)\n                                       \n        copy_final(text, options.sidecar, options.input_file)\n\n                                    \n    pdf = ocrgraft.finalize()\n\n    messages: Sequence[str] = []\n    if options.output_type != 'none':\n                            \n        log.info(\"Postprocessing...\")\n        pdf, messages = postprocess(pdf, context, executor)\n\n                                      \n        copy_final(pdf, options.output_file, options.input_file)\n    return messages", "func_code_string": "def exec_concurrent(context: PdfContext, executor: Executor) -> Sequence[str]:\n                                                \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Start processing %d pages concurrently\", max_workers)\n\n    sidecars: list[Path | None] = [None] * len(context.pdfinfo)\n    ocrgraft = OcrGrafter(context)\n\n    def update_page(result: PageResult, pbar: ProgressBar):\n                                                               \n        try:\n            set_thread_pageno(result.pageno + 1)\n            sidecars[result.pageno] = result.text\n            pbar.update(0.5)\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.ocr,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update(0.5)\n        finally:\n            set_thread_pageno(None)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=len(context.pdfinfo),\n            desc='OCR' if options.tesseract_timeout > 0 else 'Image processing',\n            unit='page',\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_page_sync,\n        task_arguments=context.get_page_context_args(),\n        task_finished=update_page,\n    )\n\n                         \n    if options.sidecar:\n        text = merge_sidecars(sidecars, context)\n                                       \n        copy_final(text, options.sidecar, options.input_file)\n\n                                    \n    pdf = ocrgraft.finalize()\n\n    messages: Sequence[str] = []\n    if options.output_type != 'none':\n                            \n        log.info(\"Postprocessing...\")\n        pdf, messages = postprocess(pdf, context, executor)\n\n                                      \n        copy_final(pdf, options.output_file, options.input_file)\n    return messages", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "_run_pipeline", "whole_func_string": "def _run_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n    with (\n        manage_work_folder(\n            work_folder=Path(mkdtemp(prefix=\"ocrmypdf.io.\")),\n            retain=options.keep_temporary_files,\n            print_location=options.keep_temporary_files,\n        ) as work_folder,\n        manage_debug_log_handler(options=options, work_folder=work_folder),\n    ):\n        executor = setup_pipeline(options, plugin_manager)\n        check_requested_output_file(options)\n        start_input_file, original_filename = create_input_file(options, work_folder)\n\n                             \n        origin_pdf = triage(\n            original_filename, start_input_file, work_folder / 'origin.pdf', options\n        )\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n\n                                                \n        validate_pdfinfo_options(context)\n\n                              \n        optimize_messages = exec_concurrent(context, executor)\n\n        exitcode = report_output_pdf(options, start_input_file, optimize_messages)\n        return exitcode", "func_code_string": "def _run_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n    with (\n        manage_work_folder(\n            work_folder=Path(mkdtemp(prefix=\"ocrmypdf.io.\")),\n            retain=options.keep_temporary_files,\n            print_location=options.keep_temporary_files,\n        ) as work_folder,\n        manage_debug_log_handler(options=options, work_folder=work_folder),\n    ):\n        executor = setup_pipeline(options, plugin_manager)\n        check_requested_output_file(options)\n        start_input_file, original_filename = create_input_file(options, work_folder)\n\n                             \n        origin_pdf = triage(\n            original_filename, start_input_file, work_folder / 'origin.pdf', options\n        )\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n\n                                                \n        validate_pdfinfo_options(context)\n\n                              \n        optimize_messages = exec_concurrent(context, executor)\n\n        exitcode = report_output_pdf(options, start_input_file, optimize_messages)\n        return exitcode", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "run_pipeline_cli", "whole_func_string": "def run_pipeline_cli(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return cli_exception_handler(_run_pipeline, options, plugin_manager)", "func_code_string": "def run_pipeline_cli(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return cli_exception_handler(_run_pipeline, options, plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "run_pipeline", "whole_func_string": "def run_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return _run_pipeline(options, plugin_manager)", "func_code_string": "def run_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return _run_pipeline(options, plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "update_page", "whole_func_string": "def update_page(result: PageResult, pbar: ProgressBar):\n                                                               \n        try:\n            set_thread_pageno(result.pageno + 1)\n            sidecars[result.pageno] = result.text\n            pbar.update(0.5)\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.ocr,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update(0.5)\n        finally:\n            set_thread_pageno(None)", "func_code_string": "def update_page(result: PageResult, pbar: ProgressBar):\n                                                               \n        try:\n            set_thread_pageno(result.pageno + 1)\n            sidecars[result.pageno] = result.text\n            pbar.update(0.5)\n            ocrgraft.graft_page(\n                pageno=result.pageno,\n                image=result.pdf_page_from_image,\n                textpdf=result.ocr,\n                autorotate_correction=result.orientation_correction,\n            )\n            pbar.update(0.5)\n        finally:\n            set_thread_pageno(None)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/pdf_to_hocr.py", "func_name": "_exec_page_hocr_sync", "whole_func_string": "def _exec_page_hocr_sync(page_context: PageContext) -> HOCRResult:\n                                                    \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return HOCRResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    hocr_out, _ = ocr_engine_hocr(ocr_image_out, page_context)\n\n    result = HOCRResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        hocr=hocr_out,\n        orientation_correction=orientation_correction,\n    )\n    page_context.get_path('hocr.json').write_text(result.to_json())\n    return result", "func_code_string": "def _exec_page_hocr_sync(page_context: PageContext) -> HOCRResult:\n                                                    \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return HOCRResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    hocr_out, _ = ocr_engine_hocr(ocr_image_out, page_context)\n\n    result = HOCRResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        hocr=hocr_out,\n        orientation_correction=orientation_correction,\n    )\n    page_context.get_path('hocr.json').write_text(result.to_json())\n    return result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/pdf_to_hocr.py", "func_name": "exec_pdf_to_hocr", "whole_func_string": "def exec_pdf_to_hocr(context: PdfContext, executor: Executor) -> None:\n                                                                \n                                      \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Start processing %d pages concurrently\", max_workers)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=(2 * len(context.pdfinfo)),\n            desc='hOCR',\n            unit='page',\n            unit_scale=0.5,\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_page_hocr_sync,\n        task_arguments=context.get_page_context_args(),\n    )", "func_code_string": "def exec_pdf_to_hocr(context: PdfContext, executor: Executor) -> None:\n                                                                \n                                      \n    options = context.options\n    max_workers = min(len(context.pdfinfo), options.jobs)\n    if max_workers > 1:\n        log.info(\"Start processing %d pages concurrently\", max_workers)\n\n    executor(\n        use_threads=options.use_threads,\n        max_workers=max_workers,\n        progress_kwargs=dict(\n            total=(2 * len(context.pdfinfo)),\n            desc='hOCR',\n            unit='page',\n            unit_scale=0.5,\n            disable=not options.progress_bar,\n        ),\n        worker_initializer=partial(worker_init, PIL.Image.MAX_IMAGE_PIXELS),\n        task=_exec_page_hocr_sync,\n        task_arguments=context.get_page_context_args(),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/pdf_to_hocr.py", "func_name": "run_hocr_pipeline", "whole_func_string": "def run_hocr_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> None:\n                                      \n    with manage_work_folder(\n        work_folder=options.output_folder, retain=True, print_location=False\n    ) as work_folder:\n        executor = setup_pipeline(options, plugin_manager)\n        origin_pdf = work_folder / 'origin.pdf'\n        shutil.copy2(options.input_file, origin_pdf)\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(\n            options, work_folder, options.input_file, pdfinfo, plugin_manager\n        )\n                                                \n        set_lossless_reconstruction(options)\n        validate_pdfinfo_options(context)\n        exec_pdf_to_hocr(context, executor)", "func_code_string": "def run_hocr_pipeline(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> None:\n                                      \n    with manage_work_folder(\n        work_folder=options.output_folder, retain=True, print_location=False\n    ) as work_folder:\n        executor = setup_pipeline(options, plugin_manager)\n        origin_pdf = work_folder / 'origin.pdf'\n        shutil.copy2(options.input_file, origin_pdf)\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(\n            options, work_folder, options.input_file, pdfinfo, plugin_manager\n        )\n                                                \n        set_lossless_reconstruction(options)\n        validate_pdfinfo_options(context)\n        exec_pdf_to_hocr(context, executor)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "MessageType", "whole_func_string": "class MessageType(Enum):\n                                        \n\n    exception = auto()                                \n    result = auto()                                \n    complete = auto()", "func_code_string": "class MessageType(Enum):\n                                        \n\n    exception = auto()                                \n    result = auto()                                \n    complete = auto()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "split_every", "whole_func_string": "def split_every(n: int, iterable: Iterable) -> Iterator:\n           \n    iterator = iter(iterable)\n    return takewhile(bool, (list(islice(iterator, n)) for _ in repeat(None)))", "func_code_string": "def split_every(n: int, iterable: Iterable) -> Iterator:\n           \n    iterator = iter(iterable)\n    return takewhile(bool, (list(islice(iterator, n)) for _ in repeat(None)))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "process_sigbus", "whole_func_string": "def process_sigbus(*args):\n                                                   \n    raise InputFileError(\"A worker process lost access to an input file\")", "func_code_string": "def process_sigbus(*args):\n                                                   \n    raise InputFileError(\"A worker process lost access to an input file\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "ConnectionLogHandler", "whole_func_string": "class ConnectionLogHandler(logging.handlers.QueueHandler):\n                                                                            \n\n    def __init__(self, conn: Connection) -> None:\n                                     \n                                                                     \n                                        \n        super().__init__(None)                \n        self.conn = conn\n\n    def enqueue(self, record):\n                                    \n        self.conn.send(('log', record))", "func_code_string": "class ConnectionLogHandler(logging.handlers.QueueHandler):\n                                                                            \n\n    def __init__(self, conn: Connection) -> None:\n                                     \n                                                                     \n                                        \n        super().__init__(None)                \n        self.conn = conn\n\n    def enqueue(self, record):\n                                    \n        self.conn.send(('log', record))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "process_loop", "whole_func_string": "def process_loop(\n    conn: Connection, user_init: Callable[[], None], loglevel, task, task_args\n):\n                                           \n                                                                                  \n    with suppress(AttributeError):                                         \n                                                                  \n        signal.signal(signal.SIGBUS, process_sigbus)\n\n                                                                                  \n    h = ConnectionLogHandler(conn)\n    root = logging.getLogger()\n    remove_all_log_handlers(root)\n    root.setLevel(loglevel)\n    root.addHandler(h)\n\n    user_init()\n\n    for args in task_args:\n        try:\n            result = task(*args)\n        except Exception as e:                                \n            conn.send((MessageType.exception, e))\n            break\n        else:\n            conn.send((MessageType.result, result))\n\n    conn.send((MessageType.complete, None))\n    conn.close()\n    return", "func_code_string": "def process_loop(\n    conn: Connection, user_init: Callable[[], None], loglevel, task, task_args\n):\n                                           \n                                                                                  \n    with suppress(AttributeError):                                         \n                                                                  \n        signal.signal(signal.SIGBUS, process_sigbus)\n\n                                                                                  \n    h = ConnectionLogHandler(conn)\n    root = logging.getLogger()\n    remove_all_log_handlers(root)\n    root.setLevel(loglevel)\n    root.addHandler(h)\n\n    user_init()\n\n    for args in task_args:\n        try:\n            result = task(*args)\n        except Exception as e:                                \n            conn.send((MessageType.exception, e))\n            break\n        else:\n            conn.send((MessageType.result, result))\n\n    conn.send((MessageType.complete, None))\n    conn.close()\n    return", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "LambdaExecutor", "whole_func_string": "class LambdaExecutor(Executor):\n                                                                               \n\n    def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads and max_workers == 1:\n            with self.pbar_class(**progress_kwargs) as pbar:\n                for args in task_arguments:\n                    result = task(*args)\n                    task_finished(result, pbar)\n            return\n\n        task_arguments = list(task_arguments)\n        grouped_args = list(\n            zip_longest(*list(split_every(max_workers, task_arguments)))\n        )\n        if not grouped_args:\n            return\n\n        processes: list[Process] = []\n        connections: list[Connection] = []\n        for chunk in grouped_args:\n            parent_conn, child_conn = Pipe()\n\n            worker_args = [args for args in chunk if args is not None]\n            process = Process(\n                target=process_loop,\n                args=(\n                    child_conn,\n                    worker_initializer,\n                    logging.getLogger(\"\").level,\n                    task,\n                    worker_args,\n                ),\n            )\n            process.daemon = True\n            processes.append(process)\n            connections.append(parent_conn)\n\n        for process in processes:\n            process.start()\n\n        with self.pbar_class(**progress_kwargs) as pbar:\n            while connections:\n                for result in wait(connections):\n                    if not isinstance(result, Connection):\n                        raise NotImplementedError(\"We only support Connection()\")\n                    try:\n                        msg_type, msg = result.recv()\n                    except EOFError:\n                        connections.remove(result)\n                        continue\n\n                    if msg_type == MessageType.result:\n                        task_finished(msg, pbar)\n                    elif msg_type == 'log':\n                        record = msg\n                        logger = logging.getLogger(record.name)\n                        logger.handle(record)\n                    elif msg_type == MessageType.complete:\n                        connections.remove(result)\n                    elif msg_type == MessageType.exception:\n                        for process in processes:\n                            process.terminate()\n                        raise msg\n\n        for process in processes:\n            process.join()", "func_code_string": "class LambdaExecutor(Executor):\n                                                                               \n\n    def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads and max_workers == 1:\n            with self.pbar_class(**progress_kwargs) as pbar:\n                for args in task_arguments:\n                    result = task(*args)\n                    task_finished(result, pbar)\n            return\n\n        task_arguments = list(task_arguments)\n        grouped_args = list(\n            zip_longest(*list(split_every(max_workers, task_arguments)))\n        )\n        if not grouped_args:\n            return\n\n        processes: list[Process] = []\n        connections: list[Connection] = []\n        for chunk in grouped_args:\n            parent_conn, child_conn = Pipe()\n\n            worker_args = [args for args in chunk if args is not None]\n            process = Process(\n                target=process_loop,\n                args=(\n                    child_conn,\n                    worker_initializer,\n                    logging.getLogger(\"\").level,\n                    task,\n                    worker_args,\n                ),\n            )\n            process.daemon = True\n            processes.append(process)\n            connections.append(parent_conn)\n\n        for process in processes:\n            process.start()\n\n        with self.pbar_class(**progress_kwargs) as pbar:\n            while connections:\n                for result in wait(connections):\n                    if not isinstance(result, Connection):\n                        raise NotImplementedError(\"We only support Connection()\")\n                    try:\n                        msg_type, msg = result.recv()\n                    except EOFError:\n                        connections.remove(result)\n                        continue\n\n                    if msg_type == MessageType.result:\n                        task_finished(msg, pbar)\n                    elif msg_type == 'log':\n                        record = msg\n                        logger = logging.getLogger(record.name)\n                        logger.handle(record)\n                    elif msg_type == MessageType.complete:\n                        connections.remove(result)\n                    elif msg_type == MessageType.exception:\n                        for process in processes:\n                            process.terminate()\n                        raise msg\n\n        for process in processes:\n            process.join()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "get_executor", "whole_func_string": "def get_executor(progressbar_class):\n                                           \n    return LambdaExecutor(pbar_class=progressbar_class)", "func_code_string": "def get_executor(progressbar_class):\n                                           \n    return LambdaExecutor(pbar_class=progressbar_class)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "get_logging_console", "whole_func_string": "def get_logging_console():\n                                                  \n    return logging.StreamHandler()", "func_code_string": "def get_logging_console():\n                                                  \n    return logging.StreamHandler()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "get_progressbar_class", "whole_func_string": "def get_progressbar_class():\n           \n    return NullProgressBar", "func_code_string": "def get_progressbar_class():\n           \n    return NullProgressBar", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "__init__", "whole_func_string": "def __init__(self, conn: Connection) -> None:\n                                     \n                                                                     \n                                        \n        super().__init__(None)                \n        self.conn = conn", "func_code_string": "def __init__(self, conn: Connection) -> None:\n                                     \n                                                                     \n                                        \n        super().__init__(None)                \n        self.conn = conn", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "enqueue", "whole_func_string": "def enqueue(self, record):\n                                    \n        self.conn.send(('log', record))", "func_code_string": "def enqueue(self, record):\n                                    \n        self.conn.send(('log', record))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "_execute", "whole_func_string": "def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads and max_workers == 1:\n            with self.pbar_class(**progress_kwargs) as pbar:\n                for args in task_arguments:\n                    result = task(*args)\n                    task_finished(result, pbar)\n            return\n\n        task_arguments = list(task_arguments)\n        grouped_args = list(\n            zip_longest(*list(split_every(max_workers, task_arguments)))\n        )\n        if not grouped_args:\n            return\n\n        processes: list[Process] = []\n        connections: list[Connection] = []\n        for chunk in grouped_args:\n            parent_conn, child_conn = Pipe()\n\n            worker_args = [args for args in chunk if args is not None]\n            process = Process(\n                target=process_loop,\n                args=(\n                    child_conn,\n                    worker_initializer,\n                    logging.getLogger(\"\").level,\n                    task,\n                    worker_args,\n                ),\n            )\n            process.daemon = True\n            processes.append(process)\n            connections.append(parent_conn)\n\n        for process in processes:\n            process.start()\n\n        with self.pbar_class(**progress_kwargs) as pbar:\n            while connections:\n                for result in wait(connections):\n                    if not isinstance(result, Connection):\n                        raise NotImplementedError(\"We only support Connection()\")\n                    try:\n                        msg_type, msg = result.recv()\n                    except EOFError:\n                        connections.remove(result)\n                        continue\n\n                    if msg_type == MessageType.result:\n                        task_finished(msg, pbar)\n                    elif msg_type == 'log':\n                        record = msg\n                        logger = logging.getLogger(record.name)\n                        logger.handle(record)\n                    elif msg_type == MessageType.complete:\n                        connections.remove(result)\n                    elif msg_type == MessageType.exception:\n                        for process in processes:\n                            process.terminate()\n                        raise msg\n\n        for process in processes:\n            process.join()", "func_code_string": "def _execute(\n        self,\n        *,\n        use_threads: bool,\n        max_workers: int,\n        progress_kwargs: dict,\n        worker_initializer: Callable,\n        task: Callable,\n        task_arguments: Iterable,\n        task_finished: Callable,\n    ):\n        if use_threads and max_workers == 1:\n            with self.pbar_class(**progress_kwargs) as pbar:\n                for args in task_arguments:\n                    result = task(*args)\n                    task_finished(result, pbar)\n            return\n\n        task_arguments = list(task_arguments)\n        grouped_args = list(\n            zip_longest(*list(split_every(max_workers, task_arguments)))\n        )\n        if not grouped_args:\n            return\n\n        processes: list[Process] = []\n        connections: list[Connection] = []\n        for chunk in grouped_args:\n            parent_conn, child_conn = Pipe()\n\n            worker_args = [args for args in chunk if args is not None]\n            process = Process(\n                target=process_loop,\n                args=(\n                    child_conn,\n                    worker_initializer,\n                    logging.getLogger(\"\").level,\n                    task,\n                    worker_args,\n                ),\n            )\n            process.daemon = True\n            processes.append(process)\n            connections.append(parent_conn)\n\n        for process in processes:\n            process.start()\n\n        with self.pbar_class(**progress_kwargs) as pbar:\n            while connections:\n                for result in wait(connections):\n                    if not isinstance(result, Connection):\n                        raise NotImplementedError(\"We only support Connection()\")\n                    try:\n                        msg_type, msg = result.recv()\n                    except EOFError:\n                        connections.remove(result)\n                        continue\n\n                    if msg_type == MessageType.result:\n                        task_finished(msg, pbar)\n                    elif msg_type == 'log':\n                        record = msg\n                        logger = logging.getLogger(record.name)\n                        logger.handle(record)\n                    elif msg_type == MessageType.complete:\n                        connections.remove(result)\n                    elif msg_type == MessageType.exception:\n                        for process in processes:\n                            process.terminate()\n                        raise msg\n\n        for process in processes:\n            process.join()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "TesseractLoggerAdapter", "whole_func_string": "class TesseractLoggerAdapter(logging.LoggerAdapter):\n                                                                 \n\n    def process(self, msg, kwargs):\n        kwargs['extra'] = self.extra\n        return f'[tesseract] {msg}', kwargs", "func_code_string": "class TesseractLoggerAdapter(logging.LoggerAdapter):\n                                                                 \n\n    def process(self, msg, kwargs):\n        kwargs['extra'] = self.extra\n        return f'[tesseract] {msg}', kwargs", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "TesseractVersion", "whole_func_string": "class TesseractVersion(Version):\n                                                                                      \n\n    _regex = re.compile(\n        r\"^\\s*\" + TESSERACT_VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE\n    )", "func_code_string": "class TesseractVersion(Version):\n                                                                                      \n\n    _regex = re.compile(\n        r\"^\\s*\" + TESSERACT_VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "version", "whole_func_string": "def version() -> Version:\n    return TesseractVersion(get_version('tesseract', regex=r'tesseract\\s(.+)'))", "func_code_string": "def version() -> Version:\n    return TesseractVersion(get_version('tesseract', regex=r'tesseract\\s(.+)'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "has_thresholding", "whole_func_string": "def has_thresholding() -> bool:\n                                                                \n    return version() >= Version('5.0')", "func_code_string": "def has_thresholding() -> bool:\n                                                                \n    return version() >= Version('5.0')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "get_languages", "whole_func_string": "def get_languages() -> set[str]:\n    def lang_error(output):\n        msg = (\n            \"Tesseract failed to report available languages.\\n\"\n            \"Output from Tesseract:\\n\"\n            \"-----------\\n\"\n        )\n        msg += output\n        return msg\n\n    args_tess = ['tesseract', '--list-langs']\n    try:\n        proc = run(\n            args_tess,\n            text=True,\n            stdout=PIPE,\n            stderr=STDOUT,\n            logs_errors_to_stdout=True,\n            check=True,\n        )\n        output = proc.stdout\n    except CalledProcessError as e:\n        raise MissingDependencyError(lang_error(e.output)) from e\n\n    for line in output.splitlines():\n        if line.startswith('Error'):\n            raise MissingDependencyError(lang_error(output))\n    _header, *rest = output.splitlines()\n    return {lang.strip() for lang in rest}", "func_code_string": "def get_languages() -> set[str]:\n    def lang_error(output):\n        msg = (\n            \"Tesseract failed to report available languages.\\n\"\n            \"Output from Tesseract:\\n\"\n            \"-----------\\n\"\n        )\n        msg += output\n        return msg\n\n    args_tess = ['tesseract', '--list-langs']\n    try:\n        proc = run(\n            args_tess,\n            text=True,\n            stdout=PIPE,\n            stderr=STDOUT,\n            logs_errors_to_stdout=True,\n            check=True,\n        )\n        output = proc.stdout\n    except CalledProcessError as e:\n        raise MissingDependencyError(lang_error(e.output)) from e\n\n    for line in output.splitlines():\n        if line.startswith('Error'):\n            raise MissingDependencyError(lang_error(output))\n    _header, *rest = output.splitlines()\n    return {lang.strip() for lang in rest}", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "tess_base_args", "whole_func_string": "def tess_base_args(langs: list[str], engine_mode: int | None) -> list[str]:\n    args = ['tesseract']\n    if langs:\n        args.extend(['-l', '+'.join(langs)])\n    if engine_mode is not None:\n        args.extend(['--oem', str(engine_mode)])\n    return args", "func_code_string": "def tess_base_args(langs: list[str], engine_mode: int | None) -> list[str]:\n    args = ['tesseract']\n    if langs:\n        args.extend(['-l', '+'.join(langs)])\n    if engine_mode is not None:\n        args.extend(['--oem', str(engine_mode)])\n    return args", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "_parse_tesseract_output", "whole_func_string": "def _parse_tesseract_output(binary_output: bytes) -> dict[str, str]:\n    def gen():\n        for line in binary_output.decode().splitlines():\n            line = line.strip()\n            parts = line.split(':', maxsplit=2)\n            if len(parts) == 2:\n                yield parts[0].strip(), parts[1].strip()\n\n    return dict(gen())", "func_code_string": "def _parse_tesseract_output(binary_output: bytes) -> dict[str, str]:\n    def gen():\n        for line in binary_output.decode().splitlines():\n            line = line.strip()\n            parts = line.split(':', maxsplit=2)\n            if len(parts) == 2:\n                yield parts[0].strip(), parts[1].strip()\n\n    return dict(gen())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(\n    input_file: Path, engine_mode: int | None, timeout: float\n) -> OrientationConfidence:\n    args_tesseract = tess_base_args(['osd'], engine_mode) + [\n        '--psm',\n        '0',\n        fspath(input_file),\n        'stdout',\n    ]\n\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n    except TimeoutExpired:\n        return OrientationConfidence(angle=0, confidence=0.0)\n    except CalledProcessError as e:\n        tesseract_log_output(e.stdout)\n        tesseract_log_output(e.stderr)\n        if (\n            b'Too few characters. Skipping this page' in e.output\n            or b'Image too large' in e.output\n        ):\n            return OrientationConfidence(0, 0)\n        raise SubprocessOutputError() from e\n\n    osd = _parse_tesseract_output(p.stdout)\n    angle = int(osd.get('Orientation in degrees', 0))\n    orient_conf = OrientationConfidence(\n        angle=angle, confidence=float(osd.get('Orientation confidence', 0))\n    )\n    return orient_conf", "func_code_string": "def get_orientation(\n    input_file: Path, engine_mode: int | None, timeout: float\n) -> OrientationConfidence:\n    args_tesseract = tess_base_args(['osd'], engine_mode) + [\n        '--psm',\n        '0',\n        fspath(input_file),\n        'stdout',\n    ]\n\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n    except TimeoutExpired:\n        return OrientationConfidence(angle=0, confidence=0.0)\n    except CalledProcessError as e:\n        tesseract_log_output(e.stdout)\n        tesseract_log_output(e.stderr)\n        if (\n            b'Too few characters. Skipping this page' in e.output\n            or b'Image too large' in e.output\n        ):\n            return OrientationConfidence(0, 0)\n        raise SubprocessOutputError() from e\n\n    osd = _parse_tesseract_output(p.stdout)\n    angle = int(osd.get('Orientation in degrees', 0))\n    orient_conf = OrientationConfidence(\n        angle=angle, confidence=float(osd.get('Orientation confidence', 0))\n    )\n    return orient_conf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "get_deskew", "whole_func_string": "def get_deskew(\n    input_file: Path, languages: list[str], engine_mode: int | None, timeout: float\n) -> float:\n                                                     \n    args_tesseract = tess_base_args(languages, engine_mode) + [\n        '--psm',\n        '2',\n        fspath(input_file),\n        'stdout',\n    ]\n\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n    except TimeoutExpired:\n        return 0.0\n    except CalledProcessError as e:\n        tesseract_log_output(e.stdout)\n        tesseract_log_output(e.stderr)\n        if b'Empty page!!' in e.output or (\n            e.output == b'' and e.returncode == 1\n        ):                                                                           \n            return 0.0\n\n        raise SubprocessOutputError() from e\n\n    parsed = _parse_tesseract_output(p.stdout)\n    deskew_radians = float(parsed.get('Deskew angle', 0))\n    deskew_degrees = 180 / pi * deskew_radians\n    log.debug(f\"Deskew angle: {deskew_degrees:.3f}\")\n    return deskew_degrees", "func_code_string": "def get_deskew(\n    input_file: Path, languages: list[str], engine_mode: int | None, timeout: float\n) -> float:\n                                                     \n    args_tesseract = tess_base_args(languages, engine_mode) + [\n        '--psm',\n        '2',\n        fspath(input_file),\n        'stdout',\n    ]\n\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n    except TimeoutExpired:\n        return 0.0\n    except CalledProcessError as e:\n        tesseract_log_output(e.stdout)\n        tesseract_log_output(e.stderr)\n        if b'Empty page!!' in e.output or (\n            e.output == b'' and e.returncode == 1\n        ):                                                                           \n            return 0.0\n\n        raise SubprocessOutputError() from e\n\n    parsed = _parse_tesseract_output(p.stdout)\n    deskew_radians = float(parsed.get('Deskew angle', 0))\n    deskew_degrees = 180 / pi * deskew_radians\n    log.debug(f\"Deskew angle: {deskew_degrees:.3f}\")\n    return deskew_degrees", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "tesseract_log_output", "whole_func_string": "def tesseract_log_output(stream: bytes) -> None:\n    tlog = TesseractLoggerAdapter(\n        log,\n        extra=log.extra if hasattr(log, 'extra') else None,                \n    )\n\n    if not stream:\n        return\n    try:\n        text = stream.decode()\n    except UnicodeDecodeError:\n        text = stream.decode('utf-8', 'ignore')\n\n    lines = text.splitlines()\n    for line in lines:\n        if line.startswith(\"Tesseract Open Source\"):\n            continue\n        elif line.startswith(\"Warning in pixReadMem\"):\n            continue\n        elif 'diacritics' in line:\n            tlog.warning(\"lots of diacritics - possibly poor OCR\")\n        elif line.startswith('OSD: Weak margin'):\n            tlog.warning(\"unsure about page orientation\")\n        elif 'Error in pixScanForForeground' in line:\n            pass                                                        \n        elif 'Error in boxClipToRectangle' in line:\n            pass                                                    \n        elif 'parameter not found: ' in line.lower():\n            tlog.error(line.strip())\n            problem = line.split('found: ')[1]\n            raise TesseractConfigError(problem)\n        elif 'error' in line.lower() or 'exception' in line.lower():\n            tlog.error(line.strip())\n        elif 'warning' in line.lower():\n            tlog.warning(line.strip())\n        elif 'read_params_file' in line.lower():\n            tlog.error(line.strip())\n        else:\n            tlog.info(line.strip())", "func_code_string": "def tesseract_log_output(stream: bytes) -> None:\n    tlog = TesseractLoggerAdapter(\n        log,\n        extra=log.extra if hasattr(log, 'extra') else None,                \n    )\n\n    if not stream:\n        return\n    try:\n        text = stream.decode()\n    except UnicodeDecodeError:\n        text = stream.decode('utf-8', 'ignore')\n\n    lines = text.splitlines()\n    for line in lines:\n        if line.startswith(\"Tesseract Open Source\"):\n            continue\n        elif line.startswith(\"Warning in pixReadMem\"):\n            continue\n        elif 'diacritics' in line:\n            tlog.warning(\"lots of diacritics - possibly poor OCR\")\n        elif line.startswith('OSD: Weak margin'):\n            tlog.warning(\"unsure about page orientation\")\n        elif 'Error in pixScanForForeground' in line:\n            pass                                                        \n        elif 'Error in boxClipToRectangle' in line:\n            pass                                                    \n        elif 'parameter not found: ' in line.lower():\n            tlog.error(line.strip())\n            problem = line.split('found: ')[1]\n            raise TesseractConfigError(problem)\n        elif 'error' in line.lower() or 'exception' in line.lower():\n            tlog.error(line.strip())\n        elif 'warning' in line.lower():\n            tlog.warning(line.strip())\n        elif 'read_params_file' in line.lower():\n            tlog.error(line.strip())\n        else:\n            tlog.info(line.strip())", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "page_timedout", "whole_func_string": "def page_timedout(timeout: float) -> None:\n    if timeout == 0:\n        return\n    log.warning(\"[tesseract] took too long to OCR - skipping\")", "func_code_string": "def page_timedout(timeout: float) -> None:\n    if timeout == 0:\n        return\n    log.warning(\"[tesseract] took too long to OCR - skipping\")", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "_generate_null_hocr", "whole_func_string": "def _generate_null_hocr(output_hocr: Path, output_text: Path, image: Path) -> None:\n           \n    output_hocr.write_text('', encoding='utf-8')\n    output_text.write_text('[skipped page]', encoding='utf-8')", "func_code_string": "def _generate_null_hocr(output_hocr: Path, output_text: Path, image: Path) -> None:\n           \n    output_hocr.write_text('', encoding='utf-8')\n    output_text.write_text('[skipped page]', encoding='utf-8')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(\n    *,\n    input_file: Path,\n    output_hocr: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n                                                               \n    prefix = output_hocr.with_suffix('')\n\n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n                                                                              \n                                            \n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'hocr', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n    except TimeoutExpired:\n                                                                             \n                                                                             \n                                             \n        page_timedout(timeout)\n        _generate_null_hocr(output_hocr, output_text, input_file)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            _generate_null_hocr(output_hocr, output_text, input_file)\n            return\n\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)\n                                                                      \n                                        \n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)", "func_code_string": "def generate_hocr(\n    *,\n    input_file: Path,\n    output_hocr: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n                                                               \n    prefix = output_hocr.with_suffix('')\n\n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n                                                                              \n                                            \n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'hocr', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n    except TimeoutExpired:\n                                                                             \n                                                                             \n                                             \n        page_timedout(timeout)\n        _generate_null_hocr(output_hocr, output_text, input_file)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            _generate_null_hocr(output_hocr, output_text, input_file)\n            return\n\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)\n                                                                      \n                                        \n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "use_skip_page", "whole_func_string": "def use_skip_page(output_pdf: Path, output_text: Path) -> None:\n    output_text.write_text('[skipped page]', encoding='utf-8')\n\n                                                    \n    output_pdf.write_bytes(b'')", "func_code_string": "def use_skip_page(output_pdf: Path, output_text: Path) -> None:\n    output_text.write_text('[skipped page]', encoding='utf-8')\n\n                                                    \n    output_pdf.write_bytes(b'')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(\n    *,\n    input_file: Path,\n    output_pdf: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n           \n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    args_tesseract.extend(['-c', 'textonly_pdf=1'])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n    prefix = output_pdf.parent / Path(output_pdf.stem)\n\n                                                                               \n                                            \n\n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'pdf', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)\n    except TimeoutExpired:\n        page_timedout(timeout)\n        use_skip_page(output_pdf, output_text)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            use_skip_page(output_pdf, output_text)\n            return\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)", "func_code_string": "def generate_pdf(\n    *,\n    input_file: Path,\n    output_pdf: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n           \n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    args_tesseract.extend(['-c', 'textonly_pdf=1'])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n    prefix = output_pdf.parent / Path(output_pdf.stem)\n\n                                                                               \n                                            \n\n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'pdf', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)\n    except TimeoutExpired:\n        page_timedout(timeout)\n        use_skip_page(output_pdf, output_text)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            use_skip_page(output_pdf, output_text)\n            return\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "process", "whole_func_string": "def process(self, msg, kwargs):\n        kwargs['extra'] = self.extra\n        return f'[tesseract] {msg}', kwargs", "func_code_string": "def process(self, msg, kwargs):\n        kwargs['extra'] = self.extra\n        return f'[tesseract] {msg}', kwargs", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "lang_error", "whole_func_string": "def lang_error(output):\n        msg = (\n            \"Tesseract failed to report available languages.\\n\"\n            \"Output from Tesseract:\\n\"\n            \"-----------\\n\"\n        )\n        msg += output\n        return msg", "func_code_string": "def lang_error(output):\n        msg = (\n            \"Tesseract failed to report available languages.\\n\"\n            \"Output from Tesseract:\\n\"\n            \"-----------\\n\"\n        )\n        msg += output\n        return msg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "gen", "whole_func_string": "def gen():\n        for line in binary_output.decode().splitlines():\n            line = line.strip()\n            parts = line.split(':', maxsplit=2)\n            if len(parts) == 2:\n                yield parts[0].strip(), parts[1].strip()", "func_code_string": "def gen():\n        for line in binary_output.decode().splitlines():\n            line = line.strip()\n            parts = line.split(':', maxsplit=2)\n            if len(parts) == 2:\n                yield parts[0].strip(), parts[1].strip()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/jbig2enc.py", "func_name": "version", "whole_func_string": "def version() -> Version:\n    try:\n        version = get_version('jbig2', regex=r'jbig2enc (\\d+(\\.\\d+)*).*')\n    except CalledProcessError as e:\n                                                                           \n                         \n        raise MissingDependencyError('jbig2enc') from e\n    return Version(version)", "func_code_string": "def version() -> Version:\n    try:\n        version = get_version('jbig2', regex=r'jbig2enc (\\d+(\\.\\d+)*).*')\n    except CalledProcessError as e:\n                                                                           \n                         \n        raise MissingDependencyError('jbig2enc') from e\n    return Version(version)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/jbig2enc.py", "func_name": "available", "whole_func_string": "def available():\n    try:\n        version()\n    except MissingDependencyError:\n        return False\n    return True", "func_code_string": "def available():\n    try:\n        version()\n    except MissingDependencyError:\n        return False\n    return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/jbig2enc.py", "func_name": "convert_group", "whole_func_string": "def convert_group(cwd, infiles, out_prefix, threshold):\n    args = [\n        'jbig2',\n        '-b',\n        out_prefix,\n        '--symbol-mode',                       \n        '-t',\n        str(threshold),             \n                                                                              \n                \n        '--pdf',\n    ]\n    args.extend(infiles)\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_code_string": "def convert_group(cwd, infiles, out_prefix, threshold):\n    args = [\n        'jbig2',\n        '-b',\n        out_prefix,\n        '--symbol-mode',                       \n        '-t',\n        str(threshold),             \n                                                                              \n                \n        '--pdf',\n    ]\n    args.extend(infiles)\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/jbig2enc.py", "func_name": "convert_single", "whole_func_string": "def convert_single(cwd, infile, outfile, threshold):\n    args = ['jbig2', '--pdf', '-t', str(threshold), infile]\n    with open(outfile, 'wb') as fstdout:\n        proc = run(args, cwd=cwd, stdout=fstdout, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_code_string": "def convert_single(cwd, infile, outfile, threshold):\n    args = ['jbig2', '--pdf', '-t', str(threshold), infile]\n    with open(outfile, 'wb') as fstdout:\n        proc = run(args, cwd=cwd, stdout=fstdout, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/pngquant.py", "func_name": "version", "whole_func_string": "def version() -> Version:\n    return Version(get_version('pngquant', regex=r'(\\d+(\\.\\d+)*).*'))", "func_code_string": "def version() -> Version:\n    return Version(get_version('pngquant', regex=r'(\\d+(\\.\\d+)*).*'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/pngquant.py", "func_name": "available", "whole_func_string": "def available():\n    try:\n        version()\n    except MissingDependencyError:\n        return False\n    return True", "func_code_string": "def available():\n    try:\n        version()\n    except MissingDependencyError:\n        return False\n    return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/pngquant.py", "func_name": "quantize", "whole_func_string": "def quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\n           \n    with open(input_file, 'rb') as input_stream:\n        args = [\n            'pngquant',\n            '--force',\n            '--skip-if-larger',\n            '--quality',\n            f'{quality_min}-{quality_max}',\n            '--',                                       \n            '-',                                     \n        ]\n        result = run(args, stdin=input_stream, stdout=PIPE, stderr=PIPE, check=False)\n\n    if result.returncode == 0:\n                                                                            \n        output_file.write_bytes(result.stdout)", "func_code_string": "def quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\n           \n    with open(input_file, 'rb') as input_stream:\n        args = [\n            'pngquant',\n            '--force',\n            '--skip-if-larger',\n            '--quality',\n            f'{quality_min}-{quality_max}',\n            '--',                                       \n            '-',                                     \n        ]\n        result = run(args, stdin=input_stream, stdout=PIPE, stderr=PIPE, check=False)\n\n    if result.returncode == 0:\n                                                                            \n        output_file.write_bytes(result.stdout)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "UnpaperImageTooLargeError", "whole_func_string": "class UnpaperImageTooLargeError(Exception):\n                                                                    \n\n    def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_code_string": "class UnpaperImageTooLargeError(Exception):\n                                                                    \n\n    def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "version", "whole_func_string": "def version() -> Version:\n    return Version(get_version('unpaper', regex=r'(?m).*?(\\d+(\\.\\d+)(\\.\\d+)?)'))", "func_code_string": "def version() -> Version:\n    return Version(get_version('unpaper', regex=r'(?m).*?(\\d+(\\.\\d+)(\\.\\d+)?)'))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "_setup_unpaper_io", "whole_func_string": "def _setup_unpaper_io(input_file: Path) -> Iterator[tuple[Path, Path, Path]]:\n    with Image.open(input_file) as im:\n        if im.width * im.height >= UNPAPER_IMAGE_PIXEL_LIMIT:\n            raise UnpaperImageTooLargeError(w=im.width, h=im.height)\n\n    with TemporaryDirectory(ignore_cleanup_errors=True) as tmpdir:\n        tmppath = Path(tmpdir)\n                                                                  \n        input_png = input_file\n                                                                       \n                                                            \n        output_pnm = tmppath / 'output.pnm'\n        yield input_png, output_pnm, tmppath", "func_code_string": "def _setup_unpaper_io(input_file: Path) -> Iterator[tuple[Path, Path, Path]]:\n    with Image.open(input_file) as im:\n        if im.width * im.height >= UNPAPER_IMAGE_PIXEL_LIMIT:\n            raise UnpaperImageTooLargeError(w=im.width, h=im.height)\n\n    with TemporaryDirectory(ignore_cleanup_errors=True) as tmpdir:\n        tmppath = Path(tmpdir)\n                                                                  \n        input_png = input_file\n                                                                       \n                                                            \n        output_pnm = tmppath / 'output.pnm'\n        yield input_png, output_pnm, tmppath", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "run_unpaper", "whole_func_string": "def run_unpaper(\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\n) -> None:\n    args_unpaper = ['unpaper', '-v', '--dpi', str(round(dpi, 6))] + mode_args\n\n    with _setup_unpaper_io(input_file) as (input_png, output_pnm, tmpdir):\n                                                                           \n                             \n                                                                   \n                                                                          \n                                                                \n                                                                            \n                                                                      \n        args_unpaper.extend([os.fspath(input_png), os.fspath(output_pnm)])\n        run(\n            args_unpaper,\n            close_fds=True,\n            check=True,\n            stderr=STDOUT,                                                      \n            stdout=PIPE,                                         \n            cwd=tmpdir,\n            logs_errors_to_stdout=True,\n        )\n        try:\n            with Image.open(output_pnm) as imout:\n                imout.save(output_file, dpi=(dpi, dpi))\n        except OSError as e:\n            raise SubprocessOutputError(\n                \"unpaper: failed to produce the expected output file. \"\n                + \" Called with: \"\n                + str(args_unpaper)\n            ) from e", "func_code_string": "def run_unpaper(\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\n) -> None:\n    args_unpaper = ['unpaper', '-v', '--dpi', str(round(dpi, 6))] + mode_args\n\n    with _setup_unpaper_io(input_file) as (input_png, output_pnm, tmpdir):\n                                                                           \n                             \n                                                                   \n                                                                          \n                                                                \n                                                                            \n                                                                      \n        args_unpaper.extend([os.fspath(input_png), os.fspath(output_pnm)])\n        run(\n            args_unpaper,\n            close_fds=True,\n            check=True,\n            stderr=STDOUT,                                                      \n            stdout=PIPE,                                         \n            cwd=tmpdir,\n            logs_errors_to_stdout=True,\n        )\n        try:\n            with Image.open(output_pnm) as imout:\n                imout.save(output_file, dpi=(dpi, dpi))\n        except OSError as e:\n            raise SubprocessOutputError(\n                \"unpaper: failed to produce the expected output file. \"\n                + \" Called with: \"\n                + str(args_unpaper)\n            ) from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "validate_custom_args", "whole_func_string": "def validate_custom_args(args: str) -> list[str]:\n    unpaper_args = shlex.split(args)\n    if any(('/' in arg or arg == '.' or arg == '..') for arg in unpaper_args):\n        raise ValueError('No filenames allowed in --unpaper-args')\n    return unpaper_args", "func_code_string": "def validate_custom_args(args: str) -> list[str]:\n    unpaper_args = shlex.split(args)\n    if any(('/' in arg or arg == '.' or arg == '..') for arg in unpaper_args):\n        raise ValueError('No filenames allowed in --unpaper-args')\n    return unpaper_args", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "clean", "whole_func_string": "def clean(\n    input_file: Path,\n    output_file: Path,\n    *,\n    dpi: DecFloat,\n    unpaper_args: list[str] | None = None,\n) -> Path:\n    default_args = [\n        '--layout',\n        'none',\n        '--mask-scan-size',\n        '100',                                  \n        '--no-border-align',                                          \n        '--no-mask-center',                                            \n        '--no-grayfilter',                                 \n        '--no-blackfilter',                                  \n        '--no-deskew',                \n    ]\n    if not unpaper_args:\n        unpaper_args = default_args\n    try:\n        run_unpaper(input_file, output_file, dpi=dpi, mode_args=unpaper_args)\n        return output_file\n    except UnpaperImageTooLargeError as e:\n        log.warning(str(e))\n        return input_file", "func_code_string": "def clean(\n    input_file: Path,\n    output_file: Path,\n    *,\n    dpi: DecFloat,\n    unpaper_args: list[str] | None = None,\n) -> Path:\n    default_args = [\n        '--layout',\n        'none',\n        '--mask-scan-size',\n        '100',                                  \n        '--no-border-align',                                          \n        '--no-mask-center',                                            \n        '--no-grayfilter',                                 \n        '--no-blackfilter',                                  \n        '--no-deskew',                \n    ]\n    if not unpaper_args:\n        unpaper_args = default_args\n    try:\n        run_unpaper(input_file, output_file, dpi=dpi, mode_args=unpaper_args)\n        return output_file\n    except UnpaperImageTooLargeError as e:\n        log.warning(str(e))\n        return input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_code_string": "def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "DuplicateFilter", "whole_func_string": "class DuplicateFilter(logging.Filter):\n           \n\n    def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0\n\n    def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_code_string": "class DuplicateFilter(logging.Filter):\n           \n\n    def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0\n\n    def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "version", "whole_func_string": "def version() -> Version:\n    return Version(get_version(GS))", "func_code_string": "def version() -> Version:\n    return Version(get_version(GS))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "_gs_error_reported", "whole_func_string": "def _gs_error_reported(stream) -> bool:\n    match = re.search(r'error', stream, flags=re.IGNORECASE)\n    return bool(match)", "func_code_string": "def _gs_error_reported(stream) -> bool:\n    match = re.search(r'error', stream, flags=re.IGNORECASE)\n    return bool(match)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "_gs_devicen_reported", "whole_func_string": "def _gs_devicen_reported(stream) -> bool:\n           \n    match = re.search(\n        r'DeviceN.*inappropriate alternate',\n        stream,\n        flags=re.IGNORECASE | re.MULTILINE,\n    )\n    return bool(match)", "func_code_string": "def _gs_devicen_reported(stream) -> bool:\n           \n    match = re.search(\n        r'DeviceN.*inappropriate alternate',\n        stream,\n        flags=re.IGNORECASE | re.MULTILINE,\n    )\n    return bool(match)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "rasterize_pdf", "whole_func_string": "def rasterize_pdf(\n    input_file: os.PathLike,\n    output_file: os.PathLike,\n    *,\n    raster_device: str,\n    raster_dpi: Resolution,\n    pageno: int = 1,\n    page_dpi: Resolution | None = None,\n    rotation: int | None = None,\n    filter_vector: bool = False,\n    stop_on_error: bool = False,\n):\n                                                                               \n    raster_dpi = raster_dpi.round(6)\n    if not page_dpi:\n        page_dpi = raster_dpi\n\n    args_gs = (\n        [\n            GS,\n            '-dSAFER',\n            '-dBATCH',\n            '-dNOPAUSE',\n            '-dInterpolateControl=-1',\n            f'-sDEVICE={raster_device}',\n            f'-dFirstPage={pageno}',\n            f'-dLastPage={pageno}',\n            f'-r{raster_dpi.x:f}x{raster_dpi.y:f}',\n        ]\n        + (['-dFILTERVECTOR'] if filter_vector else [])\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + [\n            '-o',\n            fspath(output_file),\n            '-sstdout=%stderr',                                        \n            '-dAutoRotatePages=/None',                                    \n            '-f',\n            fspath(input_file),\n        ]\n    )\n\n    try:\n        p = run(args_gs, stdout=PIPE, stderr=PIPE, check=True)\n    except CalledProcessError as e:\n        log.error(e.stderr.decode(errors='replace'))\n        Path(output_file).unlink(missing_ok=True)\n        raise SubprocessOutputError(\"Ghostscript rasterizing failed\") from e\n\n    stderr = p.stderr.decode(errors='replace')\n    if _gs_error_reported(stderr):\n        log.error(stderr)\n        if stop_on_error and \"recoverable image error\" in stderr:\n            Path(output_file).unlink(missing_ok=True)\n            raise InputFileError(\n                \"Ghostscript rasterizing failed. The input file contains errors that \"\n                \"cause PDF viewers to interpret it differently and incorrectly. \"\n                \"Try using --continue-on-soft-render-error and manually inspect the \"\n                \"input and output files to check for visual differences or errors.\"\n            )\n\n    try:\n        with Image.open(output_file) as im:\n            if rotation is not None:\n                log.debug(\"Rotating output by %i\", rotation)\n                                                                     \n                                                                   \n                if rotation == 90:\n                    im = im.transpose(Image.Transpose.ROTATE_90)\n                elif rotation == 180:\n                    im = im.transpose(Image.Transpose.ROTATE_180)\n                elif rotation == 270:\n                    im = im.transpose(Image.Transpose.ROTATE_270)\n                if rotation % 180 == 90:\n                    page_dpi = page_dpi.flip_axis()\n            im.save(output_file, dpi=page_dpi)\n    except UnidentifiedImageError:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise\n    except OSError as e:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise UnidentifiedImageError() from e", "func_code_string": "def rasterize_pdf(\n    input_file: os.PathLike,\n    output_file: os.PathLike,\n    *,\n    raster_device: str,\n    raster_dpi: Resolution,\n    pageno: int = 1,\n    page_dpi: Resolution | None = None,\n    rotation: int | None = None,\n    filter_vector: bool = False,\n    stop_on_error: bool = False,\n):\n                                                                               \n    raster_dpi = raster_dpi.round(6)\n    if not page_dpi:\n        page_dpi = raster_dpi\n\n    args_gs = (\n        [\n            GS,\n            '-dSAFER',\n            '-dBATCH',\n            '-dNOPAUSE',\n            '-dInterpolateControl=-1',\n            f'-sDEVICE={raster_device}',\n            f'-dFirstPage={pageno}',\n            f'-dLastPage={pageno}',\n            f'-r{raster_dpi.x:f}x{raster_dpi.y:f}',\n        ]\n        + (['-dFILTERVECTOR'] if filter_vector else [])\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + [\n            '-o',\n            fspath(output_file),\n            '-sstdout=%stderr',                                        \n            '-dAutoRotatePages=/None',                                    \n            '-f',\n            fspath(input_file),\n        ]\n    )\n\n    try:\n        p = run(args_gs, stdout=PIPE, stderr=PIPE, check=True)\n    except CalledProcessError as e:\n        log.error(e.stderr.decode(errors='replace'))\n        Path(output_file).unlink(missing_ok=True)\n        raise SubprocessOutputError(\"Ghostscript rasterizing failed\") from e\n\n    stderr = p.stderr.decode(errors='replace')\n    if _gs_error_reported(stderr):\n        log.error(stderr)\n        if stop_on_error and \"recoverable image error\" in stderr:\n            Path(output_file).unlink(missing_ok=True)\n            raise InputFileError(\n                \"Ghostscript rasterizing failed. The input file contains errors that \"\n                \"cause PDF viewers to interpret it differently and incorrectly. \"\n                \"Try using --continue-on-soft-render-error and manually inspect the \"\n                \"input and output files to check for visual differences or errors.\"\n            )\n\n    try:\n        with Image.open(output_file) as im:\n            if rotation is not None:\n                log.debug(\"Rotating output by %i\", rotation)\n                                                                     \n                                                                   \n                if rotation == 90:\n                    im = im.transpose(Image.Transpose.ROTATE_90)\n                elif rotation == 180:\n                    im = im.transpose(Image.Transpose.ROTATE_180)\n                elif rotation == 270:\n                    im = im.transpose(Image.Transpose.ROTATE_270)\n                if rotation % 180 == 90:\n                    page_dpi = page_dpi.flip_axis()\n            im.save(output_file, dpi=page_dpi)\n    except UnidentifiedImageError:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise\n    except OSError as e:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise UnidentifiedImageError() from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "GhostscriptFollower", "whole_func_string": "class GhostscriptFollower:\n                                                                                  \n\n    re_process = re.compile(r\"Processing pages \\d+ through (\\d+).\")\n    re_page = re.compile(r\"Page (\\d+)\")\n\n    def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None\n\n    def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False\n\n    def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_code_string": "class GhostscriptFollower:\n                                                                                  \n\n    re_process = re.compile(r\"Processing pages \\d+ through (\\d+).\")\n    re_page = re.compile(r\"Page (\\d+)\")\n\n    def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None\n\n    def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False\n\n    def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "generate_pdfa", "whole_func_string": "def generate_pdfa(\n    pdf_pages,\n    output_file: os.PathLike,\n    *,\n    compression: str,\n    color_conversion_strategy: str,\n    pdf_version: str = '1.5',\n    pdfa_part: str = '2',\n    progressbar_class=None,\n    stop_on_error: bool = False,\n):\n                                                                                 \n                                                                                 \n                                              \n    compression_args = []\n    if compression == 'jpeg':\n        compression_args = [\n            \"-dAutoFilterColorImages=false\",\n            \"-dColorImageFilter=/DCTEncode\",\n            \"-dAutoFilterGrayImages=false\",\n            \"-dGrayImageFilter=/DCTEncode\",\n        ]\n    elif compression == 'lossless':\n        compression_args = [\n            \"-dAutoFilterColorImages=false\",\n            \"-dColorImageFilter=/FlateEncode\",\n            \"-dAutoFilterGrayImages=false\",\n            \"-dGrayImageFilter=/FlateEncode\",\n        ]\n    else:\n        compression_args = [\n            \"-dAutoFilterColorImages=true\",\n            \"-dAutoFilterGrayImages=true\",\n        ]\n\n    gs_version = version()\n    if gs_version == Version('9.56.0'):\n                                                          \n                                                             \n        compression_args.append('-dNEWPDF=false')\n\n    if os.name == 'nt':\n                                                              \n        stop_on_error = False\n\n                                                                          \n                  \n                                                         \n    args_gs = (\n        [\n            GS,\n            \"-dBATCH\",\n            \"-dNOPAUSE\",\n            \"-dSAFER\",\n            f\"-dCompatibilityLevel={str(pdf_version)}\",\n            \"-sDEVICE=pdfwrite\",\n            \"-dAutoRotatePages=/None\",\n            f\"-sColorConversionStrategy={color_conversion_strategy}\",\n        ]\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + compression_args\n        + [\n            \"-dJPEGQ=95\",\n            f\"-dPDFA={pdfa_part}\",\n            \"-dPDFACompatibilityPolicy=1\",\n            \"-o\",\n            fspath(output_file),\n            \"-sstdout=%stderr\",                                        \n        ]\n    )\n    args_gs.extend(fspath(s) for s in pdf_pages)                       \n    try:\n        with GhostscriptFollower(progressbar_class) as pbar:\n            p = run_polling_stderr(\n                args_gs,\n                stderr=PIPE,\n                check=True,\n                text=True,\n                encoding='utf-8',\n                errors='replace',\n                callback=pbar,\n            )\n    except CalledProcessError as e:\n                                                                         \n                                              \n        log.error(e.stderr)\n        raise SubprocessOutputError('Ghostscript PDF/A rendering failed') from e\n    else:\n        stderr = p.stderr\n                                                                            \n                     \n        if _gs_error_reported(stderr):\n                                                                           \n                                                                             \n                                                                           \n                                                              \n            for part in stderr.split('****'):\n                log.error(part)\n        if _gs_devicen_reported(stderr):\n            raise ColorConversionNeededError()", "func_code_string": "def generate_pdfa(\n    pdf_pages,\n    output_file: os.PathLike,\n    *,\n    compression: str,\n    color_conversion_strategy: str,\n    pdf_version: str = '1.5',\n    pdfa_part: str = '2',\n    progressbar_class=None,\n    stop_on_error: bool = False,\n):\n                                                                                 \n                                                                                 \n                                              \n    compression_args = []\n    if compression == 'jpeg':\n        compression_args = [\n            \"-dAutoFilterColorImages=false\",\n            \"-dColorImageFilter=/DCTEncode\",\n            \"-dAutoFilterGrayImages=false\",\n            \"-dGrayImageFilter=/DCTEncode\",\n        ]\n    elif compression == 'lossless':\n        compression_args = [\n            \"-dAutoFilterColorImages=false\",\n            \"-dColorImageFilter=/FlateEncode\",\n            \"-dAutoFilterGrayImages=false\",\n            \"-dGrayImageFilter=/FlateEncode\",\n        ]\n    else:\n        compression_args = [\n            \"-dAutoFilterColorImages=true\",\n            \"-dAutoFilterGrayImages=true\",\n        ]\n\n    gs_version = version()\n    if gs_version == Version('9.56.0'):\n                                                          \n                                                             \n        compression_args.append('-dNEWPDF=false')\n\n    if os.name == 'nt':\n                                                              \n        stop_on_error = False\n\n                                                                          \n                  \n                                                         \n    args_gs = (\n        [\n            GS,\n            \"-dBATCH\",\n            \"-dNOPAUSE\",\n            \"-dSAFER\",\n            f\"-dCompatibilityLevel={str(pdf_version)}\",\n            \"-sDEVICE=pdfwrite\",\n            \"-dAutoRotatePages=/None\",\n            f\"-sColorConversionStrategy={color_conversion_strategy}\",\n        ]\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + compression_args\n        + [\n            \"-dJPEGQ=95\",\n            f\"-dPDFA={pdfa_part}\",\n            \"-dPDFACompatibilityPolicy=1\",\n            \"-o\",\n            fspath(output_file),\n            \"-sstdout=%stderr\",                                        \n        ]\n    )\n    args_gs.extend(fspath(s) for s in pdf_pages)                       \n    try:\n        with GhostscriptFollower(progressbar_class) as pbar:\n            p = run_polling_stderr(\n                args_gs,\n                stderr=PIPE,\n                check=True,\n                text=True,\n                encoding='utf-8',\n                errors='replace',\n                callback=pbar,\n            )\n    except CalledProcessError as e:\n                                                                         \n                                              \n        log.error(e.stderr)\n        raise SubprocessOutputError('Ghostscript PDF/A rendering failed') from e\n    else:\n        stderr = p.stderr\n                                                                            \n                     \n        if _gs_error_reported(stderr):\n                                                                           \n                                                                             \n                                                                           \n                                                              \n            for part in stderr.split('****'):\n                log.error(part)\n        if _gs_devicen_reported(stderr):\n            raise ColorConversionNeededError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__init__", "whole_func_string": "def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0", "func_code_string": "def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "filter", "whole_func_string": "def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_code_string": "def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__init__", "whole_func_string": "def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None", "func_code_string": "def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__enter__", "whole_func_string": "def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self", "func_code_string": "def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__call__", "whole_func_string": "def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_code_string": "def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "train", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": ""}
