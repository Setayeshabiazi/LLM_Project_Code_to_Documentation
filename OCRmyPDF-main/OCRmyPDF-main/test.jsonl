{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "resources", "whole_func_string": "def resources() -> Path:\n    return Path(TESTS_ROOT) / 'resources'", "func_code_string": "def resources() -> Path:\n    return Path(TESTS_ROOT) / 'resources'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/conftest.py\\nFunction/Class: resources\\n```python\\ndef resources() -> Path:\\n    return Path(TESTS_ROOT) / 'resources'\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `resources` is designed to provide a standardized path to the 'resources' directory for test purposes. This ensures consistency and ease of access to shared resources across different tests.\n\n### Parameter Analysis\n\n- **None**: The function does not accept any parameters.\n\n### Behavior\n\nWhen called, the function returns a `Path` object pointing to the 'resources' subdirectory within the `TESTS_ROOT` directory. This is typically used in test environments where files such as configuration files, data files, or mock objects are stored.\n\n### Edge Cases\n\n- **No Environment Variable**: If the environment variable `TESTS_ROOT` is not set, this function will raise a `FileNotFoundError` when trying to access the path.\n- **Non-existent Directory**: If the 'resources' directory does not exist within `TESTS_ROOT`, accessing the returned `Path` object will raise a `FileNotFoundError`.\n\n### Python Docstring\n\n```python\ndef resources() -> Path:\n    \"\"\"\n    Returns the path to the 'resources' directory, which is typically used for test data and files.\n    \n    Raises:\n        FileNotFoundError: If the environment variable TESTS_ROOT is not set or the 'resources'\n                         directory does not exist within it.\n    \n    Returns:\n        Path: A `Path` object pointing to the 'resources' directory.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(\n    *,\n    input_file: Path,\n    output_pdf: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n           \n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    args_tesseract.extend(['-c', 'textonly_pdf=1'])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n    prefix = output_pdf.parent / Path(output_pdf.stem)\n\n                                                                               \n                                            \n\n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'pdf', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)\n    except TimeoutExpired:\n        page_timedout(timeout)\n        use_skip_page(output_pdf, output_text)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            use_skip_page(output_pdf, output_text)\n            return\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)", "func_code_string": "def generate_pdf(\n    *,\n    input_file: Path,\n    output_pdf: Path,\n    output_text: Path,\n    languages: list[str],\n    engine_mode: int,\n    tessconfig: list[str],\n    timeout: float,\n    pagesegmode: int,\n    thresholding: int,\n    user_words,\n    user_patterns,\n) -> None:\n           \n    args_tesseract = tess_base_args(languages, engine_mode)\n\n    if pagesegmode is not None:\n        args_tesseract.extend(['--psm', str(pagesegmode)])\n\n    args_tesseract.extend(['-c', 'textonly_pdf=1'])\n\n    if thresholding != 0 and has_thresholding():\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\n\n    if user_words:\n        args_tesseract.extend(['--user-words', user_words])\n\n    if user_patterns:\n        args_tesseract.extend(['--user-patterns', user_patterns])\n\n    prefix = output_pdf.parent / Path(output_pdf.stem)\n\n                                                                               \n                                            \n\n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'pdf', 'txt'])\n    args_tesseract.extend(tessconfig)\n    try:\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\n        stdout = p.stdout\n        with suppress(FileNotFoundError):\n            prefix.with_suffix('.txt').replace(output_text)\n    except TimeoutExpired:\n        page_timedout(timeout)\n        use_skip_page(output_pdf, output_text)\n    except CalledProcessError as e:\n        tesseract_log_output(e.output)\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\n            use_skip_page(output_pdf, output_text)\n            return\n        raise SubprocessOutputError() from e\n    else:\n        tesseract_log_output(stdout)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/tesseract.py\\nFunction/Class: generate_pdf\\n```python\\ndef generate_pdf(\\n    *,\\n    input_file: Path,\\n    output_pdf: Path,\\n    output_text: Path,\\n    languages: list[str],\\n    engine_mode: int,\\n    tessconfig: list[str],\\n    timeout: float,\\n    pagesegmode: int,\\n    thresholding: int,\\n    user_words,\\n    user_patterns,\\n) -> None:\\n           \\n    args_tesseract = tess_base_args(languages, engine_mode)\\n\\n    if pagesegmode is not None:\\n        args_tesseract.extend(['--psm', str(pagesegmode)])\\n\\n    args_tesseract.extend(['-c', 'textonly_pdf=1'])\\n\\n    if thresholding != 0 and has_thresholding():\\n        args_tesseract.extend(['-c', f'thresholding_method={thresholding}'])\\n\\n    if user_words:\\n        args_tesseract.extend(['--user-words', user_words])\\n\\n    if user_patterns:\\n        args_tesseract.extend(['--user-patterns', user_patterns])\\n\\n    prefix = output_pdf.parent / Path(output_pdf.stem)\\n\\n                                                                               \\n                                            \\n\\n    args_tesseract.extend([fspath(input_file), fspath(prefix), 'pdf', 'txt'])\\n    args_tesseract.extend(tessconfig)\\n    try:\\n        p = run(args_tesseract, stdout=PIPE, stderr=STDOUT, timeout=timeout, check=True)\\n        stdout = p.stdout\\n        with suppress(FileNotFoundError):\\n            prefix.with_suffix('.txt').replace(output_text)\\n    except TimeoutExpired:\\n        page_timedout(timeout)\\n        use_skip_page(output_pdf, output_text)\\n    except CalledProcessError as e:\\n        tesseract_log_output(e.output)\\n        if b'Image too large' in e.output or b'Empty page!!' in e.output:\\n            use_skip_page(output_pdf, output_text)\\n            return\\n        raise SubprocessOutputError() from e\\n    else:\\n        tesseract_log_output(stdout)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\nThe `generate_pdf` function is designed to convert an image file into a PDF using the Tesseract OCR engine. It handles various configurations and options to ensure accurate text extraction and output.\n\n### Parameters:\n- **input_file (Path)**: The path to the input image file.\n- **output_pdf (Path)**: The path where the generated PDF will be saved.\n- **output_text (Path)**: The path where the extracted text will be saved.\n- **languages (list[str])**: A list of language codes for OCR recognition.\n- **engine_mode (int)**: The Tesseract engine mode to use for OCR processing.\n- **tessconfig (list[str])**: Additional configuration options for Tesseract.\n- **timeout (float)**: Maximum time in seconds to allow the OCR process before timing out.\n- **pagesegmode (int, optional)**: Page segmentation mode for Tesseract. If not specified, a default value is used.\n- **thresholding (int, optional)**: Method for image thresholding. Ignored if `has_thresholding()` returns False.\n- **user_words (str, optional)**: Path to a file containing user-defined words.\n- **user_patterns (str, optional)**: Path to a file containing user-defined patterns.\n\n### Behavior:\n1. Constructs the Tesseract command arguments based on the provided parameters.\n2. Optionally includes additional configuration options from `tessconfig`.\n3. Executes the Tesseract OCR command with a timeout.\n4. Handles different outcomes of the command execution:\n   - **Success**: Logs the output and moves the extracted text to the specified location.\n   - **Timeout**: Logs the timeout and skips the page.\n   - **Error**: Logs the error and handles specific error messages like \"Image too large\" or \"Empty page!!\" by skipping the page.\n\n### Edge Cases:\n- If `pagesegmode` is provided, it adds the corresponding Tesseract argument.\n- Thresholding is only applied if `thresholding` is not zero and `has_thresholding()` returns True.\n- Handles user-defined words and patterns if provided.\n- Properly manages file paths for output PDF and text files.\n\n### Docstring:\n```python\ndef generate_pdf(\n    *, input_file: Path, output_pdf: Path, output_text: Path, languages: list[str], engine_mode: int,\n    tessconfig: list[str], timeout: float, pagesegmode: int = None, thresholding: int = 0,\n    user_words: str = None, user_patterns: str = None\n) -> None:\n    \"\"\"\n    Converts an image file into a PDF using Tesseract OCR.\n\n    Parameters:\n        input_file (Path): The path to the input image file.\n        output_pdf (Path): The path where the generated PDF will be saved.\n        output_text (Path): The path where the extracted text will be saved.\n        languages (list[str]): List of language codes for OCR recognition.\n        engine_mode (int): Tesseract engine mode for OCR processing.\n        tessconfig (list[str]): Additional configuration options for Tesseract.\n        timeout (float): Maximum time in seconds to allow the OCR process before timing out.\n        pagesegmode (int, optional): Page segmentation mode for Tesseract. Default is None.\n        thresholding (int, optional): Method for image thresholding. Ignored if not supported. Default is 0.\n        user_words (str, optional): Path to a file containing user-defined words.\n        user_patterns (str, optional): Path to a file containing user-defined patterns.\n\n    Raises:\n        SubprocessOutputError: If Tesseract encounters an unexpected error during processing.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_language_warning", "whole_func_string": "def test_language_warning(caplog):\n    opts = make_opts(language=None)\n    _plugin_manager = get_plugin_manager(opts.plugins)\n    caplog.set_level(logging.DEBUG)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('en_US', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert '' in caplog.text\n        mock.assert_called_once()\n\n    opts = make_opts(language=None)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('fr_FR', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert 'assuming --language' in caplog.text\n        mock.assert_called_once()", "func_code_string": "def test_language_warning(caplog):\n    opts = make_opts(language=None)\n    _plugin_manager = get_plugin_manager(opts.plugins)\n    caplog.set_level(logging.DEBUG)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('en_US', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert '' in caplog.text\n        mock.assert_called_once()\n\n    opts = make_opts(language=None)\n    with patch(\n        'ocrmypdf._validation.locale.getlocale', return_value=('fr_FR', 'UTF-8')\n    ) as mock:\n        vd.check_options_languages(opts, ['eng'])\n        assert opts.languages == ['eng']\n        assert 'assuming --language' in caplog.text\n        mock.assert_called_once()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_language_warning\\n```python\\ndef test_language_warning(caplog):\\n    opts = make_opts(language=None)\\n    _plugin_manager = get_plugin_manager(opts.plugins)\\n    caplog.set_level(logging.DEBUG)\\n    with patch(\\n        'ocrmypdf._validation.locale.getlocale', return_value=('en_US', 'UTF-8')\\n    ) as mock:\\n        vd.check_options_languages(opts, ['eng'])\\n        assert opts.languages == ['eng']\\n        assert '' in caplog.text\\n        mock.assert_called_once()\\n\\n    opts = make_opts(language=None)\\n    with patch(\\n        'ocrmypdf._validation.locale.getlocale', return_value=('fr_FR', 'UTF-8')\\n    ) as mock:\\n        vd.check_options_languages(opts, ['eng'])\\n        assert opts.languages == ['eng']\\n        assert 'assuming --language' in caplog.text\\n        mock.assert_called_once()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_language_warning` is designed to test the behavior of language validation and warning messages within a PDF processing tool, specifically when dealing with OCR (Optical Character Recognition) options. The function ensures that the tool correctly handles cases where an explicitly specified language is not recognized or mismatches the system's locale.\n\n### Analysis\n\n1. **Parameters**:\n   - `caplog`: A fixture used for capturing log messages during the test execution, which allows us to check if specific warning messages are logged.\n\n2. **Behavior**:\n   - The function creates an OCR options object (`opts`) with no language specified.\n   - It then uses a mock to simulate different system locales (e.g., `en_US` and `fr_FR`).\n   - For each locale, it calls the `check_options_languages` function with a list of languages to be processed (`['eng']`).\n   - The test checks if the options object is correctly updated with the specified language.\n   - It also verifies that appropriate warning messages are logged based on whether the system locale matches the specified language.\n\n3. **Edge Cases**:\n   - If the system locale does not match the specified language, a warning message should be logged indicating that the tool is assuming the specified language.\n   - The test ensures that the `getlocale` function from Python's `locale` module is called exactly once during each test case.\n\n### Docstring\n\n```python\ndef test_language_warning(caplog):\n    \"\"\"\n    Test the behavior of language validation and warning messages in OCR options.\n\n    This function ensures that the OCR tool correctly handles cases where an explicitly specified\n    language is not recognized or mismatches the system's locale. It checks if appropriate\n    warning messages are logged based on the locale settings.\n    \n    :param caplog: A fixture for capturing log messages during test execution.\n    \"\"\"\n    # ... (rest of the code remains unchanged)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "get_docinfo", "whole_func_string": "def get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\n                                                              \n    options = context.options\n\n    def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''\n\n    pdfmark = {\n        k: from_document_info(k)\n        for k in ('/Title', '/Author', '/Keywords', '/Subject', '/CreationDate')\n    }\n    if options.title:\n        pdfmark['/Title'] = options.title\n    if options.author:\n        pdfmark['/Author'] = options.author\n    if options.keywords:\n        pdfmark['/Keywords'] = options.keywords\n    if options.subject:\n        pdfmark['/Subject'] = options.subject\n\n    creator_tag = context.plugin_manager.hook.get_ocr_engine().creator_tag(options)\n\n    pdfmark['/Creator'] = f'{PROGRAM_NAME} {OCRMYPF_VERSION} / {creator_tag}'\n    pdfmark['/Producer'] = f'pikepdf {PIKEPDF_VERSION}'\n    pdfmark['/ModDate'] = encode_pdf_date(datetime.now(timezone.utc))\n    return pdfmark", "func_code_string": "def get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\n                                                              \n    options = context.options\n\n    def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''\n\n    pdfmark = {\n        k: from_document_info(k)\n        for k in ('/Title', '/Author', '/Keywords', '/Subject', '/CreationDate')\n    }\n    if options.title:\n        pdfmark['/Title'] = options.title\n    if options.author:\n        pdfmark['/Author'] = options.author\n    if options.keywords:\n        pdfmark['/Keywords'] = options.keywords\n    if options.subject:\n        pdfmark['/Subject'] = options.subject\n\n    creator_tag = context.plugin_manager.hook.get_ocr_engine().creator_tag(options)\n\n    pdfmark['/Creator'] = f'{PROGRAM_NAME} {OCRMYPF_VERSION} / {creator_tag}'\n    pdfmark['/Producer'] = f'pikepdf {PIKEPDF_VERSION}'\n    pdfmark['/ModDate'] = encode_pdf_date(datetime.now(timezone.utc))\n    return pdfmark", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_metadata.py\\nFunction/Class: get_docinfo\\n```python\\ndef get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\\n                                                              \\n    options = context.options\\n\\n    def from_document_info(key):\\n        try:\\n            s = base_pdf.docinfo[key]\\n            return str(s)\\n        except (KeyError, TypeError):\\n            return ''\\n\\n    pdfmark = {\\n        k: from_document_info(k)\\n        for k in ('/Title', '/Author', '/Keywords', '/Subject', '/CreationDate')\\n    }\\n    if options.title:\\n        pdfmark['/Title'] = options.title\\n    if options.author:\\n        pdfmark['/Author'] = options.author\\n    if options.keywords:\\n        pdfmark['/Keywords'] = options.keywords\\n    if options.subject:\\n        pdfmark['/Subject'] = options.subject\\n\\n    creator_tag = context.plugin_manager.hook.get_ocr_engine().creator_tag(options)\\n\\n    pdfmark['/Creator'] = f'{PROGRAM_NAME} {OCRMYPF_VERSION} / {creator_tag}'\\n    pdfmark['/Producer'] = f'pikepdf {PIKEPDF_VERSION}'\\n    pdfmark['/ModDate'] = encode_pdf_date(datetime.now(timezone.utc))\\n    return pdfmark\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `get_docinfo` function is designed to extract and update document metadata from a PDF file. It takes a `Pdf` object representing the base PDF and a `PdfContext` object containing additional context information, including user-provided options for overriding certain metadata fields.\n\n### Parameters\n\n- **base_pdf**: A `Pdf` object representing the base PDF whose metadata needs to be processed.\n- **context**: A `PdfContext` object containing context-specific information and user options.\n\n### Behavior\n\n1. **Extract Existing Metadata**:\n   - The function attempts to extract existing metadata from the `base_pdf.docinfo` dictionary for keys like `/Title`, `/Author`, `/Keywords`, `/Subject`, and `/CreationDate`.\n   - If any key is missing or raises a `KeyError` or `TypeError`, an empty string is returned for that key.\n\n2. **Update Metadata with User Options**:\n   - The function checks if user-provided options (`options.title`, `options.author`, `options.keywords`, `options.subject`) are set.\n   - If a user option is provided, it overrides the corresponding metadata field in the `pdfmark` dictionary.\n\n3. **Add Creator Information**:\n   - The function uses a hook from the `context.plugin_manager` to get the OCR engine's creator tag based on the provided options.\n   - It then constructs a `/Creator` entry in the `pdfmark` dictionary using the program name, version, and the creator tag.\n\n4. **Set Producer Information**:\n   - The function sets the `/Producer` entry in the `pdfmark` dictionary to indicate that the PDF was created using `pikepdf`.\n\n5. **Update Modification Date**:\n   - The function updates the `/ModDate` entry in the `pdfmark` dictionary with the current UTC date and time, encoded as a PDF date string.\n\n### Edge Cases\n\n- If any key specified in the metadata extraction fails (e.g., due to missing or invalid data), an empty string is used.\n- If user options are provided and override existing metadata fields, those values will be used in the final `pdfmark` dictionary.\n- The function ensures that all metadata entries required by PDF standards are included, even if they are not explicitly provided by the user.\n\n### Summary\n\n```python\ndef get_docinfo(base_pdf: Pdf, context: PdfContext) -> dict[str, str]:\n    \"\"\"\n    Extracts and updates document metadata from a PDF file.\n\n    Parameters:\n    - base_pdf (Pdf): The base PDF whose metadata needs to be processed.\n    - context (PdfContext): Context-specific information and user options.\n\n    Returns:\n    - dict[str, str]: A dictionary containing the updated document metadata entries.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_kodak_toc", "whole_func_string": "def test_kodak_toc(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'kcs.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outpdf) as p:\n        if pikepdf.Name.First in p.Root.Outlines:\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)", "func_code_string": "def test_kodak_toc(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'kcs.pdf',\n        outpdf,\n        '--output-type',\n        'pdf',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outpdf) as p:\n        if pikepdf.Name.First in p.Root.Outlines:\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_kodak_toc\\n```python\\ndef test_kodak_toc(resources, outpdf):\\n    check_ocrmypdf(\\n        resources / 'kcs.pdf',\\n        outpdf,\\n        '--output-type',\\n        'pdf',\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n\\n    with pikepdf.open(outpdf) as p:\\n        if pikepdf.Name.First in p.Root.Outlines:\\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose**: The function `test_kodak_toc` is designed to test the functionality of OCRMyPDF when processing a PDF file with specific output and plugin configurations. It specifically checks if the generated PDF maintains an existing table of contents (TOC).\n\n**Parameters**:\n- `resources`: A directory containing input resources, such as PDF files for testing.\n- `outpdf`: The path where the processed PDF will be saved.\n\n**Behavior**:\n1. The function calls `check_ocrmypdf` with the following parameters:\n   - Input PDF: A file named 'kcs.pdf' located in the `resources` directory.\n   - Output PDF: The specified `outpdf`.\n   - OCRMyPDF options: `--output-type pdf`, `--plugin tests/plugins/tesseract_noop.py`.\n\n2. After processing, it opens the output PDF using `pikepdf.open(outpdf)`.\n\n3. It checks if the 'First' key exists in the `Root.Outlines` dictionary of the PDF.\n\n4. If the 'First' key exists and is a dictionary, the assertion passes.\n\n**Edge Cases**:\n- The function assumes that there is an existing TOC ('First' key in `Outlines`) in the input PDF.\n- It does not handle scenarios where the TOC might be missing or corrupted.\n\n**Docstring**:\n```python\ndef test_kodak_toc(resources, outpdf):\n    \"\"\"\n    Test OCRMyPDF with a specific output type and plugin, ensuring the generated PDF maintains an existing table of contents (TOC).\n\n    Parameters:\n    resources (pathlib.Path): Directory containing input resources.\n    outpdf (pathlib.Path): Path where the processed PDF will be saved.\n\n    Edge Cases:\n    - Assumes the input PDF has an existing TOC.\n    \"\"\"\n    check_ocrmypdf(\n        resources / 'kcs.pdf',\n        outpdf,\n        '--output-type', 'pdf',\n        '--plugin', 'tests/plugins/tesseract_noop.py',\n    )\n\n    with pikepdf.open(outpdf) as p:\n        if pikepdf.Name.First in p.Root.Outlines:\n            assert isinstance(p.Root.Outlines.First, pikepdf.Dictionary)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "UnpaperImageTooLargeError", "whole_func_string": "class UnpaperImageTooLargeError(Exception):\n                                                                    \n\n    def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_code_string": "class UnpaperImageTooLargeError(Exception):\n                                                                    \n\n    def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/unpaper.py\\nFunction/Class: UnpaperImageTooLargeError\\n```python\\nclass UnpaperImageTooLargeError(Exception):\\n                                                                    \\n\\n    def __init__(\\n        self,\\n        w,\\n        h,\\n        message=\\\"Image with size {}x{} is too large for cleaning with 'unpaper'.\\\",\\n    ):\\n        self.w = w\\n        self.h = h\\n        self.message = message.format(w, h)\\n        super().__init__(self.message)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level purpose of the function or class**: The `UnpaperImageTooLargeError` is a custom exception designed to handle errors related to images being too large for processing with the `unpaper` tool.\n\n2. **Analysis of parameters, behavior, and edge cases**:\n   - **Parameters**:\n     - `w`: Width of the image (integer).\n     - `h`: Height of the image (integer).\n     - `message`: Optional error message format string. Defaults to \"Image with size {}x{} is too large for cleaning with 'unpaper'.\".\n   \n   - **Behavior**:\n     - The constructor initializes the width (`w`) and height (`h`) attributes.\n     - It formats the provided message using the image dimensions and sets it as the exception's message.\n     - It then calls the superclass constructor with the formatted message to ensure proper exception handling.\n\n   - **Edge cases**:\n     - If `w` or `h` are not integers, an error will occur during formatting. The default behavior of Python's string formatting methods should handle this gracefully by converting non-integer values to strings.\n     - Providing a custom `message` allows for flexibility in error handling and localization.\n\n3. **Concise Python docstring**:\n   ```python\n   class UnpaperImageTooLargeError(Exception):\n       \"\"\"\n       Raised when an image is too large for cleaning with 'unpaper'.\n       \n       Parameters:\n       w (int): Width of the image.\n       h (int): Height of the image.\n       message (str, optional): Custom error message format string. Defaults to \"Image with size {}x{} is too large for cleaning with 'unpaper'.\"\n       \"\"\"\n       \n       def __init__(self, w, h, message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\"):\n           self.w = w\n           self.h = h\n           self.message = message.format(w, h)\n           super().__init__(self.message)\n   ```\n\nThis documentation clearly explains the purpose of the `UnpaperImageTooLargeError`, its parameters, and how it is used within the code."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_blank_input_pdf", "whole_func_string": "def test_blank_input_pdf(resources, outpdf):\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\n    assert result == ExitCode.ok", "func_code_string": "def test_blank_input_pdf(resources, outpdf):\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\n    assert result == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_blank_input_pdf\\n```python\\ndef test_blank_input_pdf(resources, outpdf):\\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\\n    assert result == ExitCode.ok\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `test_blank_input_pdf` function is to verify that the OCRMyPDF API handles a blank PDF file correctly. The function specifically checks whether running OCRMyPDF on an empty PDF results in a successful exit code.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters:**\n  - `resources`: A path-like object pointing to a directory containing test resources.\n  - `outpdf`: A path-like object specifying the output file path for the processed PDF.\n\n- **Behavior:**\n  - The function calls the `run_ocrmypdf_api` function with the path to a blank PDF file located in the `resources` directory and specifies the output file path as `outpdf`.\n  - It then asserts that the result of `run_ocrmypdf_api` is equal to `ExitCode.ok`, indicating a successful execution.\n\n- **Edge Cases:**\n  - The function assumes that the input PDF (`blank.pdf`) is truly blank and contains no text or images.\n  - If the `run_ocrmypdf_api` function does not handle blank PDFs gracefully, this test might fail if it expects some processing even for an empty file.\n\n### Concise Python Docstring\n\n```python\ndef test_blank_input_pdf(resources, outpdf):\n    \"\"\"\n    Test that OCRMyPDF handles a blank input PDF correctly.\n\n    Parameters:\n    resources (path-like): Path to the directory containing test resources.\n    outpdf (path-like): Output file path for the processed PDF.\n\n    Returns:\n    None\n\n    Edge Cases:\n    - Assumes 'blank.pdf' is truly blank and contains no text or images.\n    \"\"\"\n    result = run_ocrmypdf_api(resources / 'blank.pdf', outpdf)\n    assert result == ExitCode.ok\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "shim_path", "whole_func_string": "def shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\n    if not env:\n        env = os.environ\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)", "func_code_string": "def shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\n    if not env:\n        env = os.environ\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/subprocess/_windows.py\\nFunction/Class: shim_path\\n```python\\ndef shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\\n    if not env:\\n        env = os.environ\\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function:**\nThe `shim_path` function is designed to modify the system's PATH environment variable by incorporating paths generated from a provided callable. This allows for dynamic alteration of the PATH, which can be useful in scenarios where temporary or custom paths need to be temporarily added or modified.\n\n**Analysis of parameters and behavior:**\n- **Parameters:**\n  - `new_paths`: A callable that takes an environment dictionary (`env`) as input and returns an iterator over `Path` objects representing the new paths to be included in the PATH.\n  - `env` (optional): An environment dictionary. If not provided, it defaults to the current process's environment.\n\n- **Behavior:**\n  The function processes each path returned by the `new_paths` callable. It filters out any `None` or empty values and joins them into a single string separated by the system's PATH separator (`os.pathsep`). This resulting string is then returned as the new PATH value.\n\n**Edge cases:**\n- If `env` is not provided, it defaults to `os.environ`, ensuring that no modifications are made to an external environment if not explicitly given.\n- If the `new_paths` callable returns any `None` or empty values, they are ignored during the join operation, preventing inclusion of invalid paths in the final PATH.\n\n**Docstring:**\n```python\ndef shim_path(new_paths: Callable[[Any], Iterator[Path]], env=None) -> str:\n    \"\"\"\n    Modifies the system's PATH environment variable by incorporating paths generated from a provided callable.\n    \n    Parameters:\n    new_paths (Callable[[Any], Iterator[Path]]): A callable that takes an environment dictionary as input and returns an iterator over Path objects representing the new paths to be included in the PATH.\n    env (dict, optional): An environment dictionary. If not provided, it defaults to the current process's environment.\n    \n    Returns:\n    str: The new PATH value with the dynamically generated paths included.\n    \"\"\"\n    if not env:\n        env = os.environ\n    return os.pathsep.join(str(p) for p in new_paths(env) if p)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_logging.py", "func_name": "PageNumberFilter", "whole_func_string": "class PageNumberFilter(logging.Filter):\n                                                                        \n\n    def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_code_string": "class PageNumberFilter(logging.Filter):\n                                                                        \n\n    def filter(self, record):\n        pageno = getattr(record, 'pageno', None)\n        if isinstance(pageno, int):\n            record.pageno = f'{pageno:5d} '\n        elif pageno is None:\n            record.pageno = ''\n        return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_logging.py\\nFunction/Class: PageNumberFilter\\n```python\\nclass PageNumberFilter(logging.Filter):\\n                                                                        \\n\\n    def filter(self, record):\\n        pageno = getattr(record, 'pageno', None)\\n        if isinstance(pageno, int):\\n            record.pageno = f'{pageno:5d} '\\n        elif pageno is None:\\n            record.pageno = ''\\n        return True\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level purpose of the function or class**:\n   - The `PageNumberFilter` class is a custom logging filter designed to format log records with page numbers, enhancing the traceability and readability of logs generated during OCR processing.\n\n2. **Analysis of parameters, behavior, and edge cases**:\n   - **Parameters**: \n     - This class does not accept any parameters in its constructor.\n   - **Behavior**:\n     - The `filter` method is called by the logging system for each log record it processes.\n     - It checks if the log record has a `pageno` attribute. If it does and is an integer, it formats the page number to a 5-digit string with leading spaces. If the `pageno` attribute is not present or is not an integer, it sets the `pageno` attribute to an empty string.\n   - **Edge cases**:\n     - If no `pageno` attribute exists in the log record, the method avoids adding any page number information.\n     - Non-integer values for `pageno` are treated as missing or invalid, leading to an empty string for the page number.\n\n3. **Python docstring or summary**:\n   ```python\n   class PageNumberFilter(logging.Filter):\n       \"\"\"\n       A custom logging filter that formats log records with a 5-digit page number.\n       \n       If the record has a `pageno` attribute and it is an integer, it formats it as a 5-digit string with leading spaces. \n       If no `pageno` attribute exists or if it is not an integer, it sets the `pageno` attribute to an empty string.\n       \"\"\"\n   \n       def filter(self, record):\n           pageno = getattr(record, 'pageno', None)\n           if isinstance(pageno, int):\n               record.pageno = f'{pageno:5d} '\n           elif pageno is None:\n               record.pageno = ''\n           return True\n   ```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "rasterize_pdf", "whole_func_string": "def rasterize_pdf(\n    input_file: os.PathLike,\n    output_file: os.PathLike,\n    *,\n    raster_device: str,\n    raster_dpi: Resolution,\n    pageno: int = 1,\n    page_dpi: Resolution | None = None,\n    rotation: int | None = None,\n    filter_vector: bool = False,\n    stop_on_error: bool = False,\n):\n                                                                               \n    raster_dpi = raster_dpi.round(6)\n    if not page_dpi:\n        page_dpi = raster_dpi\n\n    args_gs = (\n        [\n            GS,\n            '-dSAFER',\n            '-dBATCH',\n            '-dNOPAUSE',\n            '-dInterpolateControl=-1',\n            f'-sDEVICE={raster_device}',\n            f'-dFirstPage={pageno}',\n            f'-dLastPage={pageno}',\n            f'-r{raster_dpi.x:f}x{raster_dpi.y:f}',\n        ]\n        + (['-dFILTERVECTOR'] if filter_vector else [])\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + [\n            '-o',\n            fspath(output_file),\n            '-sstdout=%stderr',                                        \n            '-dAutoRotatePages=/None',                                    \n            '-f',\n            fspath(input_file),\n        ]\n    )\n\n    try:\n        p = run(args_gs, stdout=PIPE, stderr=PIPE, check=True)\n    except CalledProcessError as e:\n        log.error(e.stderr.decode(errors='replace'))\n        Path(output_file).unlink(missing_ok=True)\n        raise SubprocessOutputError(\"Ghostscript rasterizing failed\") from e\n\n    stderr = p.stderr.decode(errors='replace')\n    if _gs_error_reported(stderr):\n        log.error(stderr)\n        if stop_on_error and \"recoverable image error\" in stderr:\n            Path(output_file).unlink(missing_ok=True)\n            raise InputFileError(\n                \"Ghostscript rasterizing failed. The input file contains errors that \"\n                \"cause PDF viewers to interpret it differently and incorrectly. \"\n                \"Try using --continue-on-soft-render-error and manually inspect the \"\n                \"input and output files to check for visual differences or errors.\"\n            )\n\n    try:\n        with Image.open(output_file) as im:\n            if rotation is not None:\n                log.debug(\"Rotating output by %i\", rotation)\n                                                                     \n                                                                   \n                if rotation == 90:\n                    im = im.transpose(Image.Transpose.ROTATE_90)\n                elif rotation == 180:\n                    im = im.transpose(Image.Transpose.ROTATE_180)\n                elif rotation == 270:\n                    im = im.transpose(Image.Transpose.ROTATE_270)\n                if rotation % 180 == 90:\n                    page_dpi = page_dpi.flip_axis()\n            im.save(output_file, dpi=page_dpi)\n    except UnidentifiedImageError:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise\n    except OSError as e:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise UnidentifiedImageError() from e", "func_code_string": "def rasterize_pdf(\n    input_file: os.PathLike,\n    output_file: os.PathLike,\n    *,\n    raster_device: str,\n    raster_dpi: Resolution,\n    pageno: int = 1,\n    page_dpi: Resolution | None = None,\n    rotation: int | None = None,\n    filter_vector: bool = False,\n    stop_on_error: bool = False,\n):\n                                                                               \n    raster_dpi = raster_dpi.round(6)\n    if not page_dpi:\n        page_dpi = raster_dpi\n\n    args_gs = (\n        [\n            GS,\n            '-dSAFER',\n            '-dBATCH',\n            '-dNOPAUSE',\n            '-dInterpolateControl=-1',\n            f'-sDEVICE={raster_device}',\n            f'-dFirstPage={pageno}',\n            f'-dLastPage={pageno}',\n            f'-r{raster_dpi.x:f}x{raster_dpi.y:f}',\n        ]\n        + (['-dFILTERVECTOR'] if filter_vector else [])\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\n        + [\n            '-o',\n            fspath(output_file),\n            '-sstdout=%stderr',                                        \n            '-dAutoRotatePages=/None',                                    \n            '-f',\n            fspath(input_file),\n        ]\n    )\n\n    try:\n        p = run(args_gs, stdout=PIPE, stderr=PIPE, check=True)\n    except CalledProcessError as e:\n        log.error(e.stderr.decode(errors='replace'))\n        Path(output_file).unlink(missing_ok=True)\n        raise SubprocessOutputError(\"Ghostscript rasterizing failed\") from e\n\n    stderr = p.stderr.decode(errors='replace')\n    if _gs_error_reported(stderr):\n        log.error(stderr)\n        if stop_on_error and \"recoverable image error\" in stderr:\n            Path(output_file).unlink(missing_ok=True)\n            raise InputFileError(\n                \"Ghostscript rasterizing failed. The input file contains errors that \"\n                \"cause PDF viewers to interpret it differently and incorrectly. \"\n                \"Try using --continue-on-soft-render-error and manually inspect the \"\n                \"input and output files to check for visual differences or errors.\"\n            )\n\n    try:\n        with Image.open(output_file) as im:\n            if rotation is not None:\n                log.debug(\"Rotating output by %i\", rotation)\n                                                                     \n                                                                   \n                if rotation == 90:\n                    im = im.transpose(Image.Transpose.ROTATE_90)\n                elif rotation == 180:\n                    im = im.transpose(Image.Transpose.ROTATE_180)\n                elif rotation == 270:\n                    im = im.transpose(Image.Transpose.ROTATE_270)\n                if rotation % 180 == 90:\n                    page_dpi = page_dpi.flip_axis()\n            im.save(output_file, dpi=page_dpi)\n    except UnidentifiedImageError:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise\n    except OSError as e:\n        log.error(\n            f\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \"\n            \"an invalid page image file.\"\n        )\n        raise UnidentifiedImageError() from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/ghostscript.py\\nFunction/Class: rasterize_pdf\\n```python\\ndef rasterize_pdf(\\n    input_file: os.PathLike,\\n    output_file: os.PathLike,\\n    *,\\n    raster_device: str,\\n    raster_dpi: Resolution,\\n    pageno: int = 1,\\n    page_dpi: Resolution | None = None,\\n    rotation: int | None = None,\\n    filter_vector: bool = False,\\n    stop_on_error: bool = False,\\n):\\n                                                                               \\n    raster_dpi = raster_dpi.round(6)\\n    if not page_dpi:\\n        page_dpi = raster_dpi\\n\\n    args_gs = (\\n        [\\n            GS,\\n            '-dSAFER',\\n            '-dBATCH',\\n            '-dNOPAUSE',\\n            '-dInterpolateControl=-1',\\n            f'-sDEVICE={raster_device}',\\n            f'-dFirstPage={pageno}',\\n            f'-dLastPage={pageno}',\\n            f'-r{raster_dpi.x:f}x{raster_dpi.y:f}',\\n        ]\\n        + (['-dFILTERVECTOR'] if filter_vector else [])\\n        + (['-dPDFSTOPONERROR'] if stop_on_error else [])\\n        + [\\n            '-o',\\n            fspath(output_file),\\n            '-sstdout=%stderr',                                        \\n            '-dAutoRotatePages=/None',                                    \\n            '-f',\\n            fspath(input_file),\\n        ]\\n    )\\n\\n    try:\\n        p = run(args_gs, stdout=PIPE, stderr=PIPE, check=True)\\n    except CalledProcessError as e:\\n        log.error(e.stderr.decode(errors='replace'))\\n        Path(output_file).unlink(missing_ok=True)\\n        raise SubprocessOutputError(\\\"Ghostscript rasterizing failed\\\") from e\\n\\n    stderr = p.stderr.decode(errors='replace')\\n    if _gs_error_reported(stderr):\\n        log.error(stderr)\\n        if stop_on_error and \\\"recoverable image error\\\" in stderr:\\n            Path(output_file).unlink(missing_ok=True)\\n            raise InputFileError(\\n                \\\"Ghostscript rasterizing failed. The input file contains errors that \\\"\\n                \\\"cause PDF viewers to interpret it differently and incorrectly. \\\"\\n                \\\"Try using --continue-on-soft-render-error and manually inspect the \\\"\\n                \\\"input and output files to check for visual differences or errors.\\\"\\n            )\\n\\n    try:\\n        with Image.open(output_file) as im:\\n            if rotation is not None:\\n                log.debug(\\\"Rotating output by %i\\\", rotation)\\n                                                                     \\n                                                                   \\n                if rotation == 90:\\n                    im = im.transpose(Image.Transpose.ROTATE_90)\\n                elif rotation == 180:\\n                    im = im.transpose(Image.Transpose.ROTATE_180)\\n                elif rotation == 270:\\n                    im = im.transpose(Image.Transpose.ROTATE_270)\\n                if rotation % 180 == 90:\\n                    page_dpi = page_dpi.flip_axis()\\n            im.save(output_file, dpi=page_dpi)\\n    except UnidentifiedImageError:\\n        log.error(\\n            f\\\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \\\"\\n            \\\"an invalid page image file.\\\"\\n        )\\n        raise\\n    except OSError as e:\\n        log.error(\\n            f\\\"Ghostscript (using {raster_device} at {raster_dpi} dpi) produced \\\"\\n            \\\"an invalid page image file.\\\"\\n        )\\n        raise UnidentifiedImageError() from e\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose**: The `rasterize_pdf` function is designed to convert a specific page of a PDF document into a rasterized image using Ghostscript. It allows customization of the output format, DPI, rotation, and error handling.\n\n**Analysis of parameters and behavior**:\n- **Parameters**:\n  - `input_file`: Path-like object representing the input PDF file.\n  - `output_file`: Path-like object representing the output rasterized image file.\n  - `raster_device`: A string specifying the Ghostscript device to use for rasterization (e.g., 'png256').\n  - `raster_dpi`: A `Resolution` object specifying the DPI for the output image.\n  - `pageno`: An integer specifying which page of the PDF to convert (default is 1).\n  - `page_dpi`: An optional `Resolution` object overriding the raster DPI for the specific page. If not provided, it defaults to `raster_dpi`.\n  - `rotation`: An optional integer specifying the rotation angle in degrees (0, 90, 180, 270).\n  - `filter_vector`: A boolean indicating whether to filter vector graphics during rasterization.\n  - `stop_on_error`: A boolean indicating whether to stop processing if an error occurs.\n\n- **Behavior**:\n  The function constructs a command-line argument list for Ghostscript to perform the rasterization. It then runs the Ghostscript process with these arguments, capturing both standard output and standard error. If an error occurs, it logs the error and attempts to clean up the output file before re-raising an exception. After successful execution, it opens the generated image file and applies any specified rotation. The function ensures that the output image has the correct DPI settings.\n\n- **Edge cases**:\n  - If `page_dpi` is not provided, it defaults to `raster_dpi`.\n  - If `rotation` is specified, the image is rotated accordingly.\n  - If `filter_vector` is set to `True`, vector graphics are filtered during rasterization.\n  - If an error occurs during Ghostscript execution and `stop_on_error` is `True`, the output file is deleted, and a specific exception is raised if it contains recoverable image errors.\n\n**Summary**:\nThe `rasterize_pdf` function provides a robust mechanism to convert a specific page of a PDF into a rasterized image using Ghostscript. It supports various customization options and handles potential errors gracefully, ensuring the output is correctly formatted and rotated as specified."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "GhostscriptFollower", "whole_func_string": "class GhostscriptFollower:\n                                                                                  \n\n    re_process = re.compile(r\"Processing pages \\d+ through (\\d+).\")\n    re_page = re.compile(r\"Page (\\d+)\")\n\n    def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None\n\n    def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False\n\n    def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_code_string": "class GhostscriptFollower:\n                                                                                  \n\n    re_process = re.compile(r\"Processing pages \\d+ through (\\d+).\")\n    re_page = re.compile(r\"Page (\\d+)\")\n\n    def __init__(self, progressbar_class):\n        self.count = 0\n        self.progressbar_class = progressbar_class\n        self.progressbar = None\n\n    def __enter__(self):\n                                                                              \n                                                                            \n                              \n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False\n\n    def __call__(self, line):\n        if not self.progressbar_class:\n            return\n        if not self.progressbar:\n            m = self.re_process.match(line.strip())\n            if m:\n                self.count = int(m.group(1))\n                self.progressbar = self.progressbar_class(\n                    total=self.count, desc=\"PDF/A conversion\", unit='page'\n                )\n                                                                            \n                self.progressbar.__enter__()\n        else:\n            if self.re_page.match(line.strip()):\n                self.progressbar.update()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/ghostscript.py\\nFunction/Class: GhostscriptFollower\\n```python\\nclass GhostscriptFollower:\\n                                                                                  \\n\\n    re_process = re.compile(r\\\"Processing pages \\\\d+ through (\\\\d+).\\\")\\n    re_page = re.compile(r\\\"Page (\\\\d+)\\\")\\n\\n    def __init__(self, progressbar_class):\\n        self.count = 0\\n        self.progressbar_class = progressbar_class\\n        self.progressbar = None\\n\\n    def __enter__(self):\\n                                                                              \\n                                                                            \\n                              \\n        return self\\n\\n    def __exit__(self, exc_type, exc_value, traceback):\\n        if self.progressbar:\\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\\n        return False\\n\\n    def __call__(self, line):\\n        if not self.progressbar_class:\\n            return\\n        if not self.progressbar:\\n            m = self.re_process.match(line.strip())\\n            if m:\\n                self.count = int(m.group(1))\\n                self.progressbar = self.progressbar_class(\\n                    total=self.count, desc=\\\"PDF/A conversion\\\", unit='page'\\n                )\\n                                                                            \\n                self.progressbar.__enter__()\\n        else:\\n            if self.re_page.match(line.strip()):\\n                self.progressbar.update()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `GhostscriptFollower` class is designed to track and update a progress bar based on the output from Ghostscript, a popular software for creating, editing, printing, scanning, and manipulating PDF files. The primary purpose of this class is to provide visual feedback on the progress of PDF/A conversion tasks by updating a progress bar as each page of the document is processed.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**:\n  - `progressbar_class`: A callable that takes parameters `total`, `desc`, and `unit` and returns an instance of a progress bar class.\n\n- **Behavior**:\n  - The class initializes with a `progressbar_class` but does not create the actual progress bar until it encounters output indicating the start of a conversion process.\n  - When the first line containing page processing information is encountered, it extracts the total number of pages and creates an instance of the provided progress bar class.\n  - Subsequent lines that match the pattern indicating individual pages being processed trigger an update on the progress bar.\n\n- **Edge Cases**:\n  - If no `progressbar_class` is provided when creating an instance of `GhostscriptFollower`, no progress bar will be created or updated, and all input lines are ignored.\n  - If there are errors in parsing the output from Ghostscript (e.g., unexpected formats), the class handles these gracefully without raising exceptions.\n\n### Python Docstring\n\n```python\nclass GhostscriptFollower:\n    \"\"\"\n    A utility class to track and update a progress bar based on Ghostscript output during PDF/A conversion.\n    \n    Parameters:\n        progressbar_class (callable): A callable that takes parameters `total`, `desc`, and `unit` and returns an instance of a progress bar class.\n\n    Methods:\n        __init__(progressbar_class):\n            Initializes the GhostscriptFollower with the provided progressbar class.\n        \n        __enter__():\n            Returns self to allow use in a 'with' statement.\n        \n        __exit__(exc_type, exc_value, traceback):\n            Cleans up and exits the progress bar if it was created.\n        \n        __call__(line):\n            Updates the progress bar based on the output line from Ghostscript.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_jobcontext.py", "func_name": "get_path", "whole_func_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name", "func_code_string": "def get_path(self, name: str) -> Path:\n                   \n        return self.work_folder / name", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_jobcontext.py\\nFunction/Class: get_path\\n```python\\ndef get_path(self, name: str) -> Path:\\n                   \\n        return self.work_folder / name\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**Purpose**: The `get_path` function is designed to retrieve the absolute path to a file or directory within a specified work folder.\n\n**Analysis of Parameters, Behavior, and Edge Cases**:\n1. **Parameters**:\n   - `name`: A string representing the name of the file or directory relative to the work folder.\n   \n2. **Behavior**:\n   - The function constructs an absolute path by appending the given `name` to the `work_folder`.\n   - It returns a `Path` object representing this absolute path.\n\n3. **Edge Cases**:\n   - If `name` is an empty string, it will return the root of the `work_folder`.\n   - If `name` includes parent directory references (`../`) or multiple slashes (`//`), these will be preserved in the returned path.\n   - If `name` starts with a forward slash (`/`), it will treat this as absolute and ignore the `work_folder`.\n\n**Python Docstring**:\n```python\ndef get_path(self, name: str) -> Path:\n    \"\"\"\n    Constructs and returns the absolute path to a file or directory within the work folder.\n\n    Parameters:\n    - name (str): The relative name of the file or directory within the work folder.\n\n    Returns:\n    - Path: An absolute path object representing the specified file or directory.\n    \n    Edge Cases:\n    - If `name` is an empty string, returns the root of the work folder.\n    - Preserves any parent directory references (`../`) in the returned path.\n    - Treats an absolute path (starting with '/') as starting from the root of the work folder.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "transcode_pngs", "whole_func_string": "def transcode_pngs(\n    pdf: Pdf,\n    images: Sequence[Xref],\n    image_name_fn: Callable[[Path, Xref], Path],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n                                          \n    modified: MutableSet[Xref] = set()\n    if options.optimize >= 2:\n        png_quality = (\n            max(10, options.png_quality - 10),\n            min(100, options.png_quality + 10),\n        )\n\n        def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)\n\n        executor(\n            use_threads=True,\n            max_workers=options.jobs,\n            progress_kwargs=dict(\n                desc=\"PNGs\",\n                total=len(images),\n                unit='image',\n                disable=not options.progress_bar,\n            ),\n            task=pngquant.quantize,\n            task_arguments=pngquant_args(),\n        )\n\n    for xref in modified:\n        filename = png_name(root, xref)\n        _transcode_png(pdf, filename, xref)", "func_code_string": "def transcode_pngs(\n    pdf: Pdf,\n    images: Sequence[Xref],\n    image_name_fn: Callable[[Path, Xref], Path],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n                                          \n    modified: MutableSet[Xref] = set()\n    if options.optimize >= 2:\n        png_quality = (\n            max(10, options.png_quality - 10),\n            min(100, options.png_quality + 10),\n        )\n\n        def pngquant_args():\n            for xref in images:\n                log.debug(image_name_fn(root, xref))\n                yield (\n                    image_name_fn(root, xref),\n                    png_name(root, xref),\n                    png_quality[0],\n                    png_quality[1],\n                )\n                modified.add(xref)\n\n        executor(\n            use_threads=True,\n            max_workers=options.jobs,\n            progress_kwargs=dict(\n                desc=\"PNGs\",\n                total=len(images),\n                unit='image',\n                disable=not options.progress_bar,\n            ),\n            task=pngquant.quantize,\n            task_arguments=pngquant_args(),\n        )\n\n    for xref in modified:\n        filename = png_name(root, xref)\n        _transcode_png(pdf, filename, xref)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: transcode_pngs\\n```python\\ndef transcode_pngs(\\n    pdf: Pdf,\\n    images: Sequence[Xref],\\n    image_name_fn: Callable[[Path, Xref], Path],\\n    root: Path,\\n    options,\\n    executor: Executor,\\n) -> None:\\n                                          \\n    modified: MutableSet[Xref] = set()\\n    if options.optimize >= 2:\\n        png_quality = (\\n            max(10, options.png_quality - 10),\\n            min(100, options.png_quality + 10),\\n        )\\n\\n        def pngquant_args():\\n            for xref in images:\\n                log.debug(image_name_fn(root, xref))\\n                yield (\\n                    image_name_fn(root, xref),\\n                    png_name(root, xref),\\n                    png_quality[0],\\n                    png_quality[1],\\n                )\\n                modified.add(xref)\\n\\n        executor(\\n            use_threads=True,\\n            max_workers=options.jobs,\\n            progress_kwargs=dict(\\n                desc=\\\"PNGs\\\",\\n                total=len(images),\\n                unit='image',\\n                disable=not options.progress_bar,\\n            ),\\n            task=pngquant.quantize,\\n            task_arguments=pngquant_args(),\\n        )\\n\\n    for xref in modified:\\n        filename = png_name(root, xref)\\n        _transcode_png(pdf, filename, xref)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose**: The `transcode_pngs` function processes PNG images in a PDF file to optimize their quality and size. It uses multithreading for parallel processing to improve performance.\n\n**Parameter Analysis**:\n- `pdf`: The PDF document containing the PNG images.\n- `images`: A sequence of image Xrefs (cross-references) that need optimization.\n- `image_name_fn`: A function that generates the file path for an image based on its Xref and a root directory.\n- `root`: The root directory where temporary files will be stored.\n- `options`: An object containing various options, including `optimize` level and `png_quality`.\n- `executor`: An executor object used to manage parallel tasks.\n\n**Behavior**:\n1. If the optimization level is at least 2 (`options.optimize >= 2`), it calculates a new quality range for PNG images.\n2. It defines a generator function `pngquant_args()` that yields arguments for optimizing each PNG image, including input and output filenames and the specified quality range.\n3. It uses the provided executor to parallelize the optimization tasks using `pngquant.quantize`.\n4. After all images have been processed, it transcodes each modified PNG back into the PDF.\n\n**Edge Cases**:\n- If no images need optimization (`options.optimize < 2`), the function does nothing.\n- The quality range for PNG optimization is clamped between 10 and 100 to ensure valid values.\n- If there are errors during parallel execution, they will be handled by the executor's error handling mechanisms.\n\n**Docstring or Summary**:\n\n```python\ndef transcode_pngs(\n    pdf: Pdf,\n    images: Sequence[Xref],\n    image_name_fn: Callable[[Path, Xref], Path],\n    root: Path,\n    options,\n    executor: Executor,\n) -> None:\n    \"\"\"\n    Optimizes PNG images in a PDF document by reducing their quality and size using multithreading.\n\n    Parameters:\n    - pdf (Pdf): The PDF document containing the PNG images.\n    - images (Sequence[Xref]): A sequence of image Xrefs that need optimization.\n    - image_name_fn (Callable[[Path, Xref], Path]): Function to generate the file path for an image.\n    - root (Path): Root directory where temporary files will be stored.\n    - options: Object containing various options including `optimize` level and `png_quality`.\n    - executor (Executor): Executor object used to manage parallel tasks.\n\n    If the optimization level is 2 or higher, it uses PNGQuant to optimize each image in parallel. After optimization,\n    it transcodes each modified PNG back into the PDF.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_version_comparison", "whole_func_string": "def test_version_comparison():\n    vd.check_external_program(\n        program=\"dummy_basic\",\n        package=\"dummy\",\n        version_checker=make_version('9.0'),\n        need_version='8.0.2',\n    )\n    vd.check_external_program(\n        program=\"dummy_doubledigit\",\n        package=\"dummy\",\n        version_checker=make_version('10.0'),\n        need_version='8.0.2',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.0.0-beta.1'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v5.0.0-alpha.20200201'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('5.0.0-rc1.20211030'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v4.1.1.20181030'),                               \n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"gs\",\n        package=\"ghostscript\",\n        version_checker=make_version('10.0'),\n        need_version='9.50',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.1.1-rc2-25-g9707'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"dummy_fails\",\n            package=\"dummy\",\n            version_checker=make_version('1.0'),\n            need_version='2.0',\n        )", "func_code_string": "def test_version_comparison():\n    vd.check_external_program(\n        program=\"dummy_basic\",\n        package=\"dummy\",\n        version_checker=make_version('9.0'),\n        need_version='8.0.2',\n    )\n    vd.check_external_program(\n        program=\"dummy_doubledigit\",\n        package=\"dummy\",\n        version_checker=make_version('10.0'),\n        need_version='8.0.2',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.0.0-beta.1'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v5.0.0-alpha.20200201'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('5.0.0-rc1.20211030'),\n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"tesseract\",\n        package=\"tesseract\",\n        version_checker=make_version('v4.1.1.20181030'),                               \n        need_version='4.1.1',\n        version_parser=TesseractVersion,\n    )\n    vd.check_external_program(\n        program=\"gs\",\n        package=\"ghostscript\",\n        version_checker=make_version('10.0'),\n        need_version='9.50',\n    )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"tesseract\",\n            package=\"tesseract\",\n            version_checker=make_version('4.1.1-rc2-25-g9707'),\n            need_version='4.1.1',\n            version_parser=TesseractVersion,\n        )\n    with pytest.raises(MissingDependencyError):\n        vd.check_external_program(\n            program=\"dummy_fails\",\n            package=\"dummy\",\n            version_checker=make_version('1.0'),\n            need_version='2.0',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_version_comparison\\n```python\\ndef test_version_comparison():\\n    vd.check_external_program(\\n        program=\\\"dummy_basic\\\",\\n        package=\\\"dummy\\\",\\n        version_checker=make_version('9.0'),\\n        need_version='8.0.2',\\n    )\\n    vd.check_external_program(\\n        program=\\\"dummy_doubledigit\\\",\\n        package=\\\"dummy\\\",\\n        version_checker=make_version('10.0'),\\n        need_version='8.0.2',\\n    )\\n    with pytest.raises(MissingDependencyError):\\n        vd.check_external_program(\\n            program=\\\"tesseract\\\",\\n            package=\\\"tesseract\\\",\\n            version_checker=make_version('4.0.0-beta.1'),\\n            need_version='4.1.1',\\n            version_parser=TesseractVersion,\\n        )\\n    vd.check_external_program(\\n        program=\\\"tesseract\\\",\\n        package=\\\"tesseract\\\",\\n        version_checker=make_version('v5.0.0-alpha.20200201'),\\n        need_version='4.1.1',\\n        version_parser=TesseractVersion,\\n    )\\n    vd.check_external_program(\\n        program=\\\"tesseract\\\",\\n        package=\\\"tesseract\\\",\\n        version_checker=make_version('5.0.0-rc1.20211030'),\\n        need_version='4.1.1',\\n        version_parser=TesseractVersion,\\n    )\\n    vd.check_external_program(\\n        program=\\\"tesseract\\\",\\n        package=\\\"tesseract\\\",\\n        version_checker=make_version('v4.1.1.20181030'),                               \\n        need_version='4.1.1',\\n        version_parser=TesseractVersion,\\n    )\\n    vd.check_external_program(\\n        program=\\\"gs\\\",\\n        package=\\\"ghostscript\\\",\\n        version_checker=make_version('10.0'),\\n        need_version='9.50',\\n    )\\n    with pytest.raises(MissingDependencyError):\\n        vd.check_external_program(\\n            program=\\\"tesseract\\\",\\n            package=\\\"tesseract\\\",\\n            version_checker=make_version('4.1.1-rc2-25-g9707'),\\n            need_version='4.1.1',\\n            version_parser=TesseractVersion,\\n        )\\n    with pytest.raises(MissingDependencyError):\\n        vd.check_external_program(\\n            program=\\\"dummy_fails\\\",\\n            package=\\\"dummy\\\",\\n            version_checker=make_version('1.0'),\\n            need_version='2.0',\\n        )\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `test_version_comparison` function is designed to test the functionality of a version checker mechanism within a package named `vd`. This function ensures that external programs have the required versions and raises an error if they do not meet the specified requirements.\n\n### Parameters and Behavior\n\n- **Parameters**: The function does not accept any parameters.\n  \n- **Behavior**:\n  - It calls the `check_external_program` method from the `vd` module with different program names, package names, version checkers, and required versions.\n  - For some cases, it checks if the specified program meets the required version by calling `make_version` to create a version checker function.\n  - If a program's version does not meet the requirement, it raises a `MissingDependencyError`.\n  - It includes test cases that pass (where the version is sufficient) and fail (where the version is insufficient).\n\n- **Edge Cases**:\n  - The function handles different version formats including semantic versions, pre-release versions, and build metadata.\n  - It tests for missing dependencies by raising a `MissingDependencyError` when the required version is not met.\n\n### Python Docstring\n\n```python\ndef test_version_comparison():\n    \"\"\"\n    Test the functionality of the `check_external_program` method in the `vd` module to ensure that external programs meet the specified version requirements.\n    \n    This function includes multiple test cases that check various versions of different programs. It uses `make_version` to create version checker functions and raises a `MissingDependencyError` if any program's version does not meet the required version.\n    \n    Edge cases include handling different version formats, pre-release versions, build metadata, and missing dependencies.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n        if self.progressbar:\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\n        return False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/ghostscript.py\\nFunction/Class: __exit__\\n```python\\ndef __exit__(self, exc_type, exc_value, traceback):\\n        if self.progressbar:\\n            return self.progressbar.__exit__(exc_type, exc_value, traceback)\\n        return False\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `__exit__` method is a part of the context manager protocol in Python. It is called when an exception occurs within the block managed by the context manager or when the block is exited normally.\n\n### Parameters\n\n- `exc_type`: The type of the exception that occurred, or `None` if no exception was raised.\n- `exc_value`: The actual exception object, or `None` if no exception was raised.\n- `traceback`: A traceback object, or `None` if no exception was raised.\n\n### Behavior\n\nThe `__exit__` method is responsible for cleaning up resources and handling any exceptions that occurred within the context manager. In this case, it checks if a progress bar is associated with the instance. If a progress bar exists, it calls its `__exit__` method with the provided arguments. Otherwise, it returns `False`, indicating that no exception was raised.\n\n### Edge Cases\n\n- **No Progress Bar**: If no progress bar is set (`self.progressbar` is `None`), the method simply returns `False`.\n- **Exception Handling**: If an exception occurs within the context manager, this method will be called with the exception type, value, and traceback. The method will call the `__exit__` method of the associated progress bar (if it exists) or ignore the exception if no progress bar is present.\n\n### Summary\n\nThe `__exit__` method is used to clean up resources and handle exceptions when exiting a context manager block. If a progress bar is associated with the instance, its `__exit__` method is called; otherwise, it returns `False`."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "eight_by_eight_regular_image", "whole_func_string": "def eight_by_eight_regular_image(eight_by_eight, outpdf):\n    im = eight_by_eight\n    bio = BytesIO()\n    im.save(bio, format='PNG')\n    bio.seek(0)\n\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\n\n    with outpdf.open('wb') as f:\n        img2pdf.convert(\n            bio,\n            producer=\"img2pdf\",\n            layout_fun=layout_fun,\n            outputstream=f,\n            **IMG2PDF_KWARGS,\n        )\n    return outpdf", "func_code_string": "def eight_by_eight_regular_image(eight_by_eight, outpdf):\n    im = eight_by_eight\n    bio = BytesIO()\n    im.save(bio, format='PNG')\n    bio.seek(0)\n\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\n\n    with outpdf.open('wb') as f:\n        img2pdf.convert(\n            bio,\n            producer=\"img2pdf\",\n            layout_fun=layout_fun,\n            outputstream=f,\n            **IMG2PDF_KWARGS,\n        )\n    return outpdf", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: eight_by_eight_regular_image\\n```python\\ndef eight_by_eight_regular_image(eight_by_eight, outpdf):\\n    im = eight_by_eight\\n    bio = BytesIO()\\n    im.save(bio, format='PNG')\\n    bio.seek(0)\\n\\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\\n\\n    with outpdf.open('wb') as f:\\n        img2pdf.convert(\\n            bio,\\n            producer=\\\"img2pdf\\\",\\n            layout_fun=layout_fun,\\n            outputstream=f,\\n            **IMG2PDF_KWARGS,\\n        )\\n    return outpdf\\n```\", \"assistant\": \"\"}", "response": "### Function Purpose\n\nThe `eight_by_eight_regular_image` function is designed to create a PDF file containing an 8x8 pixel image using the img2pdf library. The function takes two parameters: an image object (`eight_by_eight`) and a file path or buffer for the output PDF (`outpdf`). It saves the input image as a PNG, converts it to a format suitable for PDF, and writes the result to the specified output location.\n\n### Parameters\n\n- **eight_by_eight (PIL.Image):** The input image object that should be an 8x8 pixel image.\n- **outpdf (str or file-like object):** The path to save the generated PDF file or a file-like object where the PDF content will be written.\n\n### Behavior\n\n1. **Image Conversion:** The function first converts the input image to PNG format using Python's PIL library and saves it in a BytesIO buffer.\n2. **PDF Layout Configuration:** It sets up the layout for the PDF, specifying that each page should contain an 8x8 pixel image at a resolution defined by `img2pdf.ImgSize.dpi`.\n3. **PDF Creation:** Using the img2pdf library, the function converts the PNG image in memory to a PDF and writes it to the provided output file.\n\n### Edge Cases\n\n- If the input image is not an 8x8 pixel image, the resulting PDF may not contain the intended pixels.\n- The function assumes that the PIL library can handle the conversion of the input image to PNG format. Any issues with PIL could prevent successful conversion.\n- If the `outpdf` parameter is a file-like object, it must support write operations in binary mode (`'wb'`). Writing to unsupported or improperly opened objects could lead to errors.\n\n### Python Docstring\n\n```python\ndef eight_by_eight_regular_image(eight_by_eight, outpdf):\n    \"\"\"\n    Create a PDF containing an 8x8 pixel image using the img2pdf library.\n\n    Parameters:\n    - eight_by_eight (PIL.Image): The input 8x8 pixel image.\n    - outpdf (str or file-like object): Path to save the generated PDF file or output file-like object.\n\n    Returns:\n    - PIL.PdfFileWriter: The output PDF file writer object if a file path is provided; None otherwise.\n\n    Raises:\n    - ValueError: If the input image is not an 8x8 pixel image.\n    \"\"\"\n    im = eight_by_eight\n    bio = BytesIO()\n    im.save(bio, format='PNG')\n    bio.seek(0)\n\n    imgsize = ((img2pdf.ImgSize.dpi, 8), (img2pdf.ImgSize.dpi, 8))\n    layout_fun = img2pdf.get_layout_fun(None, imgsize, None, None, None)\n\n    with outpdf.open('wb') as f:\n        img2pdf.convert(\n            bio,\n            producer=\"img2pdf\",\n            layout_fun=layout_fun,\n            outputstream=f,\n            **IMG2PDF_KWARGS,\n        )\n    return outpdf\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_preserve_docinfo", "whole_func_string": "def test_preserve_docinfo(output_type, resources, outpdf):\n    output = check_ocrmypdf(\n        resources / 'graph.pdf',\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with (\n        pikepdf.open(resources / 'graph.pdf') as pdf_before,\n        pikepdf.open(output) as pdf_after,\n    ):\n        for key in ('/Title', '/Author'):\n            assert pdf_before.docinfo[key] == pdf_after.docinfo[key]\n        pdfa_info = file_claims_pdfa(str(output))\n        assert pdfa_info['output'] == output_type", "func_code_string": "def test_preserve_docinfo(output_type, resources, outpdf):\n    output = check_ocrmypdf(\n        resources / 'graph.pdf',\n        outpdf,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    with (\n        pikepdf.open(resources / 'graph.pdf') as pdf_before,\n        pikepdf.open(output) as pdf_after,\n    ):\n        for key in ('/Title', '/Author'):\n            assert pdf_before.docinfo[key] == pdf_after.docinfo[key]\n        pdfa_info = file_claims_pdfa(str(output))\n        assert pdfa_info['output'] == output_type", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_preserve_docinfo\\n```python\\ndef test_preserve_docinfo(output_type, resources, outpdf):\\n    output = check_ocrmypdf(\\n        resources / 'graph.pdf',\\n        outpdf,\\n        '--output-type',\\n        output_type,\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n    with (\\n        pikepdf.open(resources / 'graph.pdf') as pdf_before,\\n        pikepdf.open(output) as pdf_after,\\n    ):\\n        for key in ('/Title', '/Author'):\\n            assert pdf_before.docinfo[key] == pdf_after.docinfo[key]\\n        pdfa_info = file_claims_pdfa(str(output))\\n        assert pdfa_info['output'] == output_type\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe function `test_preserve_docinfo` is designed to test that certain document metadata (such as the title and author) is preserved when processing a PDF file using OCRMyPDF with specific settings.\n\n### Analysis\n\n1. **Parameters**:\n   - `output_type`: A string specifying the desired output type, such as 'pdfa'.\n   - `resources`: A path object pointing to the directory containing test resources.\n   - `outpdf`: A path object where the processed PDF will be saved.\n\n2. **Behavior**:\n   - The function processes an input PDF file (`graph.pdf`) using OCRMyPDF with a custom plugin (`tests/plugins/tesseract_noop.py`) and a specified output type (`--output-type`).\n   - It then opens both the original and processed PDF files to compare their document metadata (title and author) using `pikepdf`.\n   - Additionally, it checks if the processed file adheres to the expected output type (PDF/A in this case).\n\n3. **Edge Cases**:\n   - If the input PDF does not contain a title or author, the assertion for these fields might fail.\n   - The function assumes that the custom plugin (`tesseract_noop.py`) does not alter the document content, which could lead to unexpected results if the plugin modifies metadata.\n\n### Python Docstring\n\n```python\ndef test_preserve_docinfo(output_type: str, resources: Path, outpdf: Path):\n    \"\"\"\n    Test that document metadata (title and author) is preserved when processing a PDF file using OCRMyPDF with specific settings.\n\n    Parameters:\n    output_type (str): The desired output type of the processed PDF.\n    resources (Path): Path to the directory containing test resources.\n    outpdf (Path): Path where the processed PDF will be saved.\n\n    Raises:\n    AssertionError: If any of the metadata assertions fail or if the output does not match the expected PDF/A format.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "_exec_page_sync", "whole_func_string": "def _exec_page_sync(page_context: PageContext) -> PageResult:\n                                                             \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return PageResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    ocr_out, text_out = _image_to_ocr_text(page_context, ocr_image_out)\n    return PageResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        ocr=ocr_out,\n        text=text_out,\n        orientation_correction=orientation_correction,\n    )", "func_code_string": "def _exec_page_sync(page_context: PageContext) -> PageResult:\n                                                             \n    set_thread_pageno(page_context.pageno + 1)\n\n    if not is_ocr_required(page_context):\n        return PageResult(pageno=page_context.pageno)\n\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\n        page_context\n    )\n    ocr_out, text_out = _image_to_ocr_text(page_context, ocr_image_out)\n    return PageResult(\n        pageno=page_context.pageno,\n        pdf_page_from_image=pdf_page_from_image_out,\n        ocr=ocr_out,\n        text=text_out,\n        orientation_correction=orientation_correction,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/ocr.py\\nFunction/Class: _exec_page_sync\\n```python\\ndef _exec_page_sync(page_context: PageContext) -> PageResult:\\n                                                             \\n    set_thread_pageno(page_context.pageno + 1)\\n\\n    if not is_ocr_required(page_context):\\n        return PageResult(pageno=page_context.pageno)\\n\\n    ocr_image_out, pdf_page_from_image_out, orientation_correction = process_page(\\n        page_context\\n    )\\n    ocr_out, text_out = _image_to_ocr_text(page_context, ocr_image_out)\\n    return PageResult(\\n        pageno=page_context.pageno,\\n        pdf_page_from_image=pdf_page_from_image_out,\\n        ocr=ocr_out,\\n        text=text_out,\\n        orientation_correction=orientation_correction,\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function `_exec_page_sync`:**\nThe function `_exec_page_sync` is designed to process a single page in an OCR (Optical Character Recognition) pipeline. It handles various steps such as checking if OCR is required, processing the page, converting images to OCR text, and returning the results.\n\n**Analysis of parameters, behavior, and edge cases:**\n\n- **Parameters:**\n  - `page_context`: An object containing contextual information about the current page, including its number and other relevant data.\n\n- **Behavior:**\n  - The function first increments the thread's page number.\n  - It checks if OCR is required for the given page context. If not, it returns a basic `PageResult` with only the page number.\n  - If OCR is required, it processes the page to extract an image and PDF page from the image.\n  - The function then converts the image to OCR text and extracts plain text.\n  - Finally, it constructs and returns a `PageResult` containing the processed data.\n\n- **Edge cases:**\n  - If no OCR is required, the function immediately returns without further processing.\n  - Any exceptions raised during the processing steps (e.g., image extraction, OCR conversion) would need to be handled appropriately by the caller.\n\n**Concise Python docstring or summary:**\n\n```python\ndef _exec_page_sync(page_context: PageContext) -> PageResult:\n    \"\"\"\n    Process a single page in an OCR pipeline. Handles checking if OCR is required,\n    processing the page, converting images to OCR text, and returning the results.\n    \n    Parameters:\n    - page_context (PageContext): Contextual information about the current page.\n    \n    Returns:\n    - PageResult: A result object containing processed data such as OCR text and PDF pages.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_safe_symlink_overwrite", "whole_func_string": "def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')", "func_code_string": "def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_helpers.py\\nFunction/Class: test_safe_symlink_overwrite\\n```python\\ndef test_safe_symlink_overwrite(self, tmp_path):\\n        (tmp_path / 'regular_file').touch()\\n        with pytest.raises(FileExistsError):\\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `test_safe_symlink_overwrite` function is designed to test the behavior of the `safe_symlink` function when attempting to create a symbolic link that would overwrite an existing file. The function aims to ensure that the `safe_symlink` function raises a `FileExistsError` in such cases, thus providing protection against unintended file overwrites.\n\n### Analysis\n\n#### Parameters\n- **self**: An instance of the test class.\n- **tmp_path**: A temporary directory provided by the `pytest` framework, which is used to create test files and directories.\n\n#### Behavior\n1. The function creates a regular file at the path `tmp_path / 'regular_file'`.\n2. It then attempts to create a symbolic link from `tmp_path / 'input'` to `tmp_path / 'regular_file'`.\n3. Since the target of the symbolic link (`tmp_path / 'regular_file'`) already exists as a regular file, the `safe_symlink` function is expected to raise a `FileExistsError`.\n\n#### Edge Cases\n- If `safe_symlink` does not handle the case where the target file already exists, it may silently overwrite the file without raising an error.\n- Ensuring that the `safe_symlink` function correctly raises a `FileExistsError` when attempting to overwrite a file is crucial for data integrity and preventing accidental data loss.\n\n### Docstring\n```python\ndef test_safe_symlink_overwrite(self, tmp_path):\n    \"\"\"\n    Test that safe_symlink raises FileExistsError when attempting to create a symbolic link that would overwrite an existing file.\n    \n    :param self: The test class instance.\n    :param tmp_path: A temporary directory provided by pytest for creating test files and directories.\n    \"\"\"\n    (tmp_path / 'regular_file').touch()\n    with pytest.raises(FileExistsError):\n        helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "valid_tess_config", "whole_func_string": "def valid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nload_system_dawg 0\nlanguage_model_penalty_non_dict_word 0\nlanguage_model_penalty_non_freq_dict_word 0\n'''\n        )\n    yield cfg_file", "func_code_string": "def valid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nload_system_dawg 0\nlanguage_model_penalty_non_dict_word 0\nlanguage_model_penalty_non_freq_dict_word 0\n'''\n        )\n    yield cfg_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: valid_tess_config\\n```python\\ndef valid_tess_config(outdir):\\n    cfg_file = outdir / 'test.cfg'\\n    with cfg_file.open('w') as f:\\n        f.write(\\n            '''\\\\\\nload_system_dawg 0\\nlanguage_model_penalty_non_dict_word 0\\nlanguage_model_penalty_non_freq_dict_word 0\\n'''\\n        )\\n    yield cfg_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `valid_tess_config` is designed to create a configuration file for the Tesseract OCR engine in a specified output directory. This function ensures that the configuration file contains specific settings related to dictionary and language model penalties, which are essential for fine-tuning OCR performance.\n\n### Parameters\n- **outdir (Path)**: The path to the output directory where the configuration file will be created.\n\n### Behavior\n1. Constructs the path to the configuration file (`test.cfg`) within the specified `outdir`.\n2. Opens the configuration file in write mode.\n3. Writes a specific set of configuration settings into the file:\n   - `load_system_dawg 0`: Disables loading of the system DAWG (Dictionary Access Word Graph).\n   - `language_model_penalty_non_dict_word 0`: Sets the penalty for non-dictionary words to zero, effectively treating them as valid.\n   - `language_model_penalty_non_freq_dict_word 0`: Sets the penalty for non-frequent dictionary words to zero, also treating them as valid.\n\n4. Yields the path to the created configuration file.\n\n### Edge Cases\n- If the specified `outdir` does not exist, a `FileNotFoundError` will be raised.\n- If the function encounters an error while writing to the file, it may raise an `IOError`.\n- The yielded file object can be used to further manipulate or verify the contents of the configuration file.\n\n### Docstring\n```python\ndef valid_tess_config(outdir):\n    \"\"\"\n    Creates a valid Tesseract OCR configuration file in the specified output directory.\n    \n    Parameters:\n    outdir (Path): The path to the output directory where the configuration file will be created.\n    \n    Yields:\n    Path: The path to the created configuration file.\n    \n    Raises:\n    FileNotFoundError: If the specified output directory does not exist.\n    IOError: If an error occurs while writing to the configuration file.\n    \"\"\"\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nload_system_dawg 0\nlanguage_model_penalty_non_dict_word 0\nlanguage_model_penalty_non_freq_dict_word 0\n'''\n        )\n    yield cfg_file\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_code_string": "def get_orientation(input_file, options):\n        return tesseract.get_orientation(\n            input_file,\n            engine_mode=options.tesseract_oem,\n            timeout=options.tesseract_non_ocr_timeout,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/builtin_plugins/tesseract_ocr.py\\nFunction/Class: get_orientation\\n```python\\ndef get_orientation(input_file, options):\\n        return tesseract.get_orientation(\\n            input_file,\\n            engine_mode=options.tesseract_oem,\\n            timeout=options.tesseract_non_ocr_timeout,\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `get_orientation` function is designed to determine the orientation of text in a PDF file using Tesseract OCR (Optical Character Recognition). This is useful for preprocessing steps where alignment and rotation of text content need to be corrected before further processing.\n\n### Parameters\n- **input_file**: A string representing the path to the input PDF file.\n- **options**: An object containing various configuration options, including:\n  - **tesseract_oem**: An integer specifying the OCR Engine Mode to use. This determines the behavior of Tesseract during the recognition process.\n  - **tesseract_non_ocr_timeout**: An integer specifying the maximum time (in seconds) that Tesseract should wait before timing out if no OCR is detected.\n\n### Behavior\nThe function uses Tesseract's `get_orientation` method to analyze the input PDF file and determine its orientation. It returns the orientation angle of the text in the PDF.\n\n### Edge Cases\n- **File Not Found**: If the specified `input_file` does not exist, an error will be raised.\n- **Invalid OCR Engine Mode**: If the value of `options.tesseract_oem` is not recognized by Tesseract, it may cause unexpected behavior or errors.\n- **Timeout**: If the text is not detected within the specified `timeout`, a timeout exception will be raised.\n\n### Python Docstring\n```python\ndef get_orientation(input_file, options):\n    \"\"\"\n    Determines the orientation of text in a PDF file using Tesseract OCR.\n\n    Parameters:\n        input_file (str): The path to the input PDF file.\n        options (object): Configuration options containing 'tesseract_oem' and 'tesseract_non_ocr_timeout'.\n\n    Returns:\n        int: The orientation angle of the text in the PDF.\n\n    Raises:\n        FileNotFoundError: If the input file does not exist.\n        ValueError: If an invalid OCR Engine Mode is specified.\n        TimeoutError: If text detection exceeds the specified timeout.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "report_output_file_size", "whole_func_string": "def report_output_file_size(\n    options: Namespace,\n    input_file: Path,\n    output_file: Path,\n    optimize_messages: Sequence[str] | None = None,\n    file_overhead: int = 4000,\n    page_overhead: int = 3000,\n) -> None:\n    if optimize_messages is None:\n        optimize_messages = []\n    try:\n        output_size = Path(output_file).stat().st_size\n        input_size = Path(input_file).stat().st_size\n    except FileNotFoundError:\n        return                                     \n    with pikepdf.open(output_file) as p:\n                                                                               \n                                                                                \n        reasonable_overhead = file_overhead + page_overhead * len(p.pages)\n    ratio = output_size / input_size\n    reasonable_ratio = output_size / (input_size + reasonable_overhead)\n    if reasonable_ratio < 1.35 or input_size < 25000:\n        return              \n\n    reasons = []\n    image_preproc = {\n        'deskew',\n        'clean_final',\n        'remove_background',\n        'oversample',\n        'force_ocr',\n    }\n    for arg in image_preproc:\n        if getattr(options, arg, False):\n            reasons.append(\n                f\"--{arg.replace('_', '-')} was issued, causing transcoding.\"\n            )\n\n    reasons.extend(optimize_messages)\n\n    if options.output_type.startswith('pdfa'):\n        reasons.append(\"PDF/A conversion was enabled. (Try `--output-type pdf`.)\")\n    if options.plugins:\n        reasons.append(\"Plugins were used.\")\n\n    if reasons:\n        explanation = \"Possible reasons for this include:\\n\" + '\\n'.join(reasons) + \"\\n\"\n    else:\n        explanation = \"No reason for this increase is known.  Please report this issue.\"\n\n    log.warning(\n        f\"The output file size is {ratio:.2f}\u00d7 larger than the input file.\\n\"\n        f\"{explanation}\"\n    )", "func_code_string": "def report_output_file_size(\n    options: Namespace,\n    input_file: Path,\n    output_file: Path,\n    optimize_messages: Sequence[str] | None = None,\n    file_overhead: int = 4000,\n    page_overhead: int = 3000,\n) -> None:\n    if optimize_messages is None:\n        optimize_messages = []\n    try:\n        output_size = Path(output_file).stat().st_size\n        input_size = Path(input_file).stat().st_size\n    except FileNotFoundError:\n        return                                     \n    with pikepdf.open(output_file) as p:\n                                                                               \n                                                                                \n        reasonable_overhead = file_overhead + page_overhead * len(p.pages)\n    ratio = output_size / input_size\n    reasonable_ratio = output_size / (input_size + reasonable_overhead)\n    if reasonable_ratio < 1.35 or input_size < 25000:\n        return              \n\n    reasons = []\n    image_preproc = {\n        'deskew',\n        'clean_final',\n        'remove_background',\n        'oversample',\n        'force_ocr',\n    }\n    for arg in image_preproc:\n        if getattr(options, arg, False):\n            reasons.append(\n                f\"--{arg.replace('_', '-')} was issued, causing transcoding.\"\n            )\n\n    reasons.extend(optimize_messages)\n\n    if options.output_type.startswith('pdfa'):\n        reasons.append(\"PDF/A conversion was enabled. (Try `--output-type pdf`.)\")\n    if options.plugins:\n        reasons.append(\"Plugins were used.\")\n\n    if reasons:\n        explanation = \"Possible reasons for this include:\\n\" + '\\n'.join(reasons) + \"\\n\"\n    else:\n        explanation = \"No reason for this increase is known.  Please report this issue.\"\n\n    log.warning(\n        f\"The output file size is {ratio:.2f}\u00d7 larger than the input file.\\n\"\n        f\"{explanation}\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_validation.py\\nFunction/Class: report_output_file_size\\n```python\\ndef report_output_file_size(\\n    options: Namespace,\\n    input_file: Path,\\n    output_file: Path,\\n    optimize_messages: Sequence[str] | None = None,\\n    file_overhead: int = 4000,\\n    page_overhead: int = 3000,\\n) -> None:\\n    if optimize_messages is None:\\n        optimize_messages = []\\n    try:\\n        output_size = Path(output_file).stat().st_size\\n        input_size = Path(input_file).stat().st_size\\n    except FileNotFoundError:\\n        return                                     \\n    with pikepdf.open(output_file) as p:\\n                                                                               \\n                                                                                \\n        reasonable_overhead = file_overhead + page_overhead * len(p.pages)\\n    ratio = output_size / input_size\\n    reasonable_ratio = output_size / (input_size + reasonable_overhead)\\n    if reasonable_ratio < 1.35 or input_size < 25000:\\n        return              \\n\\n    reasons = []\\n    image_preproc = {\\n        'deskew',\\n        'clean_final',\\n        'remove_background',\\n        'oversample',\\n        'force_ocr',\\n    }\\n    for arg in image_preproc:\\n        if getattr(options, arg, False):\\n            reasons.append(\\n                f\\\"--{arg.replace('_', '-')} was issued, causing transcoding.\\\"\\n            )\\n\\n    reasons.extend(optimize_messages)\\n\\n    if options.output_type.startswith('pdfa'):\\n        reasons.append(\\\"PDF/A conversion was enabled. (Try `--output-type pdf`.)\\\")\\n    if options.plugins:\\n        reasons.append(\\\"Plugins were used.\\\")\\n\\n    if reasons:\\n        explanation = \\\"Possible reasons for this include:\\\\n\\\" + '\\\\n'.join(reasons) + \\\"\\\\n\\\"\\n    else:\\n        explanation = \\\"No reason for this increase is known.  Please report this issue.\\\"\\n\\n    log.warning(\\n        f\\\"The output file size is {ratio:.2f}\\u00d7 larger than the input file.\\\\n\\\"\\n        f\\\"{explanation}\\\"\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level purpose of the function**:\n   The `report_output_file_size` function is designed to analyze the output file size generated by OCRMyPDF and provide a warning if the output file size is significantly larger than the input file size. This helps identify potential issues that might have caused the increase in size, such as image preprocessing or PDF/A conversion.\n\n2. **Analysis of parameters**:\n   - `options`: A namespace containing various options for OCRMyPDF.\n   - `input_file`: The path to the original input file.\n   - `output_file`: The path to the output file generated by OCRMyPDF.\n   - `optimize_messages`: An optional sequence of messages related to optimization processes.\n   - `file_overhead`: An integer representing the overhead added to the output file size due to file-related factors (default is 4000 bytes).\n   - `page_overhead`: An integer representing the overhead added to the output file size per page due to PDF structure (default is 3000 bytes).\n\n3. **Behavior and edge cases**:\n   - The function first checks if the `optimize_messages` parameter is provided; if not, it initializes it as an empty list.\n   - It attempts to get the sizes of the input and output files using `Path.stat().st_size`. If either file does not exist, the function returns immediately without logging anything.\n   - Using `pikepdf.open`, it calculates the reasonable overhead based on the number of pages in the PDF and predefined constants for file and page overhead.\n   - It computes ratios to determine if the output file size is significantly larger than expected.\n   - If the ratio exceeds a certain threshold (1.35 times the input size) or if the input file size is below a minimum threshold (25000 bytes), the function returns without logging a warning.\n   - The function identifies reasons for the increased size based on options that trigger image preprocessing and plugins.\n   - If any reasons are identified, it logs a warning with details about these reasons. If no specific reasons are found, it logs a generic message suggesting reporting the issue.\n\n4. **Python docstring**:\n```python\ndef report_output_file_size(\n    options: Namespace,\n    input_file: Path,\n    output_file: Path,\n    optimize_messages: Sequence[str] | None = None,\n    file_overhead: int = 4000,\n    page_overhead: int = 3000,\n) -> None:\n    \"\"\"\n    Analyzes the output file size generated by OCRMyPDF and logs a warning if the output\n    file size is significantly larger than expected. This helps identify potential issues that\n    might have caused the increase in size, such as image preprocessing or PDF/A conversion.\n\n    Parameters:\n    - options: A namespace containing various options for OCRMyPDF.\n    - input_file: The path to the original input file.\n    - output_file: The path to the output file generated by OCRMyPDF.\n    - optimize_messages: An optional sequence of messages related to optimization processes.\n    - file_overhead: An integer representing the overhead added to the output file size due to file-related factors (default is 4000 bytes).\n    - page_overhead: An integer representing the overhead added to the output file size per page due to PDF structure (default is 3000 bytes).\n\n    Returns:\n    None\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/optimize.py", "func_name": "check_options", "whole_func_string": "def check_options(options):\n    if options.optimize >= 2:\n        check_external_program(\n            program='pngquant',\n            package='pngquant',\n            version_checker=pngquant.version,\n            need_version='2.12.2',\n            required_for='--optimize {2,3}',\n        )\n\n    if options.optimize >= 2:\n                                                                             \n                                              \n        check_external_program(\n            program='jbig2',\n            package='jbig2enc',\n            version_checker=jbig2enc.version,\n            need_version='0.28',\n            required_for='--optimize {2,3} | --jbig2-lossy',\n            recommended=True if not options.jbig2_lossy else False,\n        )\n\n    if options.optimize == 0 and any(\n        [options.jbig2_lossy, options.png_quality, options.jpeg_quality]\n    ):\n        log.warning(\n            \"The arguments --jbig2-lossy, --png-quality, and --jpeg-quality \"\n            \"will be ignored because --optimize=0.\"\n        )", "func_code_string": "def check_options(options):\n    if options.optimize >= 2:\n        check_external_program(\n            program='pngquant',\n            package='pngquant',\n            version_checker=pngquant.version,\n            need_version='2.12.2',\n            required_for='--optimize {2,3}',\n        )\n\n    if options.optimize >= 2:\n                                                                             \n                                              \n        check_external_program(\n            program='jbig2',\n            package='jbig2enc',\n            version_checker=jbig2enc.version,\n            need_version='0.28',\n            required_for='--optimize {2,3} | --jbig2-lossy',\n            recommended=True if not options.jbig2_lossy else False,\n        )\n\n    if options.optimize == 0 and any(\n        [options.jbig2_lossy, options.png_quality, options.jpeg_quality]\n    ):\n        log.warning(\n            \"The arguments --jbig2-lossy, --png-quality, and --jpeg-quality \"\n            \"will be ignored because --optimize=0.\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/builtin_plugins/optimize.py\\nFunction/Class: check_options\\n```python\\ndef check_options(options):\\n    if options.optimize >= 2:\\n        check_external_program(\\n            program='pngquant',\\n            package='pngquant',\\n            version_checker=pngquant.version,\\n            need_version='2.12.2',\\n            required_for='--optimize {2,3}',\\n        )\\n\\n    if options.optimize >= 2:\\n                                                                             \\n                                              \\n        check_external_program(\\n            program='jbig2',\\n            package='jbig2enc',\\n            version_checker=jbig2enc.version,\\n            need_version='0.28',\\n            required_for='--optimize {2,3} | --jbig2-lossy',\\n            recommended=True if not options.jbig2_lossy else False,\\n        )\\n\\n    if options.optimize == 0 and any(\\n        [options.jbig2_lossy, options.png_quality, options.jpeg_quality]\\n    ):\\n        log.warning(\\n            \\\"The arguments --jbig2-lossy, --png-quality, and --jpeg-quality \\\"\\n            \\\"will be ignored because --optimize=0.\\\"\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `check_options` function is designed to validate and ensure that the provided options for PDF optimization are valid and meet the necessary requirements. It checks for the availability of required external programs and logs warnings if certain options are ignored based on other settings.\n\n### Parameters\n- **options**: An object containing various configuration options related to PDF optimization, such as `optimize`, `jbig2_lossy`, `png_quality`, and `jpeg_quality`.\n\n### Behavior\n1. **PNG Quantization Check**:\n   - If the `optimize` level is 2 or higher, the function checks if the `pngquant` program is installed.\n   - It uses the `check_external_program` function to verify that `pngquant` is available and at least version `2.12.2`.\n   - This check is required for options `--optimize {2,3}`.\n\n2. **JBIG2 Encoding Check**:\n   - Similar to the PNG check, it verifies the availability of the `jbig2enc` program.\n   - It ensures that `jbig2enc` is at least version `0.28`.\n   - This check applies for options `--optimize {2,3}` and `--jbig2-lossy`.\n   - If `options.jbig2_lossy` is not set, it is considered recommended.\n\n3. **Warning Log**:\n   - If the `optimize` level is 0 but any of the options `--jbig2-lossy`, `--png-quality`, or `--jpeg_quality` are provided, a warning is logged indicating that these arguments will be ignored.\n\n### Edge Cases\n- The function assumes that the `options` object has attributes for each parameter it checks.\n- If any of the required external programs are not found or do not meet the minimum version requirement, appropriate actions (like logging warnings) are taken based on the specific conditions.\n\n### Python Docstring Summary\n```python\ndef check_options(options):\n    \"\"\"\n    Validates and ensures that the provided options for PDF optimization are valid and meet the necessary requirements.\n    It checks for the availability of required external programs and logs warnings if certain options are ignored based on other settings.\n    \n    :param options: An object containing configuration options related to PDF optimization.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "LTStateAwareChar", "whole_func_string": "class LTStateAwareChar(LTChar):\n                                                                               \n\n    __slots__ = (\n        'rendermode',\n        '_text',\n        'matrix',\n        'fontname',\n        'adv',\n        'upright',\n        'size',\n        'width',\n        'height',\n        'bbox',\n        'x0',\n        'x1',\n        'y0',\n        'y1',\n    )\n\n    def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render\n\n    def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode\n\n    def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text\n\n    def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_code_string": "class LTStateAwareChar(LTChar):\n                                                                               \n\n    __slots__ = (\n        'rendermode',\n        '_text',\n        'matrix',\n        'fontname',\n        'adv',\n        'upright',\n        'size',\n        'width',\n        'height',\n        'bbox',\n        'x0',\n        'x1',\n        'y0',\n        'y1',\n    )\n\n    def __init__(\n        self,\n        matrix: Matrix,\n        font: PDFFont,\n        fontsize: float,\n        scaling: float,\n        rise: float,\n        text: str,\n        textwidth: float,\n        textdisp: float | tuple[float | None, float],\n        ncs: PDFColorSpace,\n        graphicstate: PDFGraphicState,\n        textstate: PDFTextState,\n    ) -> None:\n                         \n        super().__init__(\n            matrix,\n            font,\n            fontsize,\n            scaling,\n            rise,\n            text,\n            textwidth,\n            textdisp,\n            ncs,\n            graphicstate,\n        )\n        self.rendermode = textstate.render\n\n    def is_compatible(self, obj: object) -> bool:\n                   \n                                          \n        if not isinstance(obj, LTStateAwareChar):\n            return False\n        both_unicode_mapped = not _is_undefined_char(\n            self._text\n        ) and not _is_undefined_char(obj._text)\n        if both_unicode_mapped:\n            return self.rendermode == obj.rendermode\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode\n\n    def get_text(self) -> str:\n                                           \n        if _is_undefined_char(self._text):\n            return '\\ufffd'                             \n        return self._text\n\n    def __repr__(self) -> str:\n                                                            \n        return (\n            f\"<{self.__class__.__name__} \"\n            f\"{bbox2str(self.bbox)} \"\n            f\"matrix={matrix2str(self.matrix)} \"\n            f\"rendermode={self.rendermode!r} \"\n            f\"font={self.fontname!r} \"\n            f\"adv={self.adv} \"\n            f\"text={self.get_text()!r}>\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/pdfinfo/layout.py\\nFunction/Class: LTStateAwareChar\\n```python\\nclass LTStateAwareChar(LTChar):\\n                                                                               \\n\\n    __slots__ = (\\n        'rendermode',\\n        '_text',\\n        'matrix',\\n        'fontname',\\n        'adv',\\n        'upright',\\n        'size',\\n        'width',\\n        'height',\\n        'bbox',\\n        'x0',\\n        'x1',\\n        'y0',\\n        'y1',\\n    )\\n\\n    def __init__(\\n        self,\\n        matrix: Matrix,\\n        font: PDFFont,\\n        fontsize: float,\\n        scaling: float,\\n        rise: float,\\n        text: str,\\n        textwidth: float,\\n        textdisp: float | tuple[float | None, float],\\n        ncs: PDFColorSpace,\\n        graphicstate: PDFGraphicState,\\n        textstate: PDFTextState,\\n    ) -> None:\\n                         \\n        super().__init__(\\n            matrix,\\n            font,\\n            fontsize,\\n            scaling,\\n            rise,\\n            text,\\n            textwidth,\\n            textdisp,\\n            ncs,\\n            graphicstate,\\n        )\\n        self.rendermode = textstate.render\\n\\n    def is_compatible(self, obj: object) -> bool:\\n                   \\n                                          \\n        if not isinstance(obj, LTStateAwareChar):\\n            return False\\n        both_unicode_mapped = not _is_undefined_char(\\n            self._text\\n        ) and not _is_undefined_char(obj._text)\\n        if both_unicode_mapped:\\n            return self.rendermode == obj.rendermode\\n        return self.fontname == obj.fontname and self.rendermode == obj.rendermode\\n\\n    def get_text(self) -> str:\\n                                           \\n        if _is_undefined_char(self._text):\\n            return '\\\\ufffd'                             \\n        return self._text\\n\\n    def __repr__(self) -> str:\\n                                                            \\n        return (\\n            f\\\"<{self.__class__.__name__} \\\"\\n            f\\\"{bbox2str(self.bbox)} \\\"\\n            f\\\"matrix={matrix2str(self.matrix)} \\\"\\n            f\\\"rendermode={self.rendermode!r} \\\"\\n            f\\\"font={self.fontname!r} \\\"\\n            f\\\"adv={self.adv} \\\"\\n            f\\\"text={self.get_text()!r}>\\\"\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `LTStateAwareChar` class is an extension of the `LTChar` class, designed to include additional state-aware properties for characters in a PDF document. The primary purpose of this class is to provide enhanced functionality for character objects by keeping track of rendering modes and other relevant attributes that are crucial for layout analysis and OCR processing.\n\n### Parameter Analysis\n\n- **matrix**: A transformation matrix representing the position and orientation of the character.\n- **font**: The font object associated with the character.\n- **fontsize**: The size of the font in points.\n- **scaling**: Scaling factor applied to the character.\n- **rise**: Vertical displacement from the baseline.\n- **text**: The textual content of the character.\n- **textwidth**: Width of the text segment that includes the current character.\n- **textdisp**: Text display properties, which can be a float or a tuple containing alignment information and possibly undefined values.\n- **ncs**: The color space of the graphics state.\n- **graphicstate**: A PDF graphic state object containing various state parameters.\n- **textstate**: A PDF text state object containing rendering attributes.\n\n### Behavior\n\n1. **Initialization (`__init__`)**: This method initializes an `LTStateAwareChar` instance by calling its parent class constructor with necessary properties and then sets the `rendermode` attribute from the `PDFTextState` object.\n2. **Compatibility Check (`is_compatible`)**: Determines if two `LTStateAwareChar` instances are compatible based on their rendering modes or font names, ensuring they can be grouped together appropriately during layout analysis.\n3. **Text Retrieval (`get_text`)**: Returns the textual content of the character, substituting undefined characters with a Unicode replacement character (`\\\\ufffd`) for better display and processing.\n4. **String Representation (`__repr__`)**: Provides a string representation of the `LTStateAwareChar` instance, including its bounding box, matrix, rendering mode, font name, advance value, and text content.\n\n### Edge Cases\n\n- When the character's text is undefined, it returns a Unicode replacement character to avoid displaying corrupted data.\n- The compatibility check considers both the rendering mode and font name when determining if two characters can be grouped together, ensuring that characters with identical visual properties but different fonts are not merged unintentionally.\n\n### Python Docstring\n\n```python\nclass LTStateAwareChar(LTChar):\n    \"\"\"\n    A class representing a character in a PDF document with state-aware attributes for layout analysis and OCR processing.\n    \n    Parameters:\n    - matrix: Transformation matrix for the character.\n    - font: Font object associated with the character.\n    - fontsize: Size of the font in points.\n    - scaling: Scaling factor applied to the character.\n    - rise: Vertical displacement from the baseline.\n    - text: Textual content of the character.\n    - textwidth: Width of the text segment that includes the current character.\n    - textdisp: Text display properties (float or tuple).\n    - ncs: Color space of the graphics state.\n    - graphicstate: PDF graphic state object.\n    - textstate: PDF text state object containing rendering attributes.\n\n    Attributes:\n    - rendermode: The rendering mode of the character.\n    \n    Methods:\n    - is_compatible(obj): Checks compatibility with another LTStateAwareChar instance based on rendering mode or font name.\n    - get_text(): Returns the textual content, substituting undefined characters with a Unicode replacement character.\n    - __repr__(): Provides a string representation of the instance.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "OcrmypdfPluginManager", "whole_func_string": "class OcrmypdfPluginManager(pluggy.PluginManager):\n           \n\n    def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n\n    def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state\n\n    def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )\n\n    def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_code_string": "class OcrmypdfPluginManager(pluggy.PluginManager):\n           \n\n    def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n\n    def __getstate__(self):\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state\n\n    def __setstate__(self, state):\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )\n\n    def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_plugin_manager.py\\nFunction/Class: OcrmypdfPluginManager\\n```python\\nclass OcrmypdfPluginManager(pluggy.PluginManager):\\n           \\n\\n    def __init__(\\n        self,\\n        *args,\\n        plugins: Sequence[str | Path],\\n        builtins: bool = True,\\n        **kwargs,\\n    ):\\n        self.__init_args = args\\n        self.__init_kwargs = kwargs\\n        self.__plugins = plugins\\n        self.__builtins = builtins\\n        super().__init__(*args, **kwargs)\\n        self.setup_plugins()\\n\\n    def __getstate__(self):\\n        state = dict(\\n            init_args=self.__init_args,\\n            plugins=self.__plugins,\\n            builtins=self.__builtins,\\n            init_kwargs=self.__init_kwargs,\\n        )\\n        return state\\n\\n    def __setstate__(self, state):\\n        self.__init__(\\n            *state['init_args'],\\n            plugins=state['plugins'],\\n            builtins=state['builtins'],\\n            **state['init_kwargs'],\\n        )\\n\\n    def setup_plugins(self):\\n        self.add_hookspecs(pluginspec)\\n\\n                              \\n        if self.__builtins:\\n            for module in sorted(\\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\\n            ):\\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\\n                module = importlib.import_module(name)\\n                self.register(module)\\n\\n                                      \\n        try:\\n                                                     \\n            from multiprocessing.synchronize import SemLock\\n\\n            del SemLock\\n        except ImportError:\\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\\n\\n                                        \\n        self.load_setuptools_entrypoints('ocrmypdf')\\n\\n                                                       \\n        for name in self.__plugins:\\n            if isinstance(name, Path) or name.endswith('.py'):\\n                                    \\n                module_name = Path(name).stem\\n                spec = importlib.util.spec_from_file_location(module_name, name)\\n                module = importlib.util.module_from_spec(spec)\\n                sys.modules[module_name] = module\\n                spec.loader.exec_module(module)\\n            else:\\n                                              \\n                module = importlib.import_module(name)\\n            self.register(module)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function/class:**\nThe `OcrmypdfPluginManager` class is designed to manage and load plugins for the `ocrmypdf` library. It allows for flexible plugin registration, including built-in plugins, custom plugins from entry points, and plugins specified by file paths.\n\n**Parameters analysis:**\n- `plugins`: A sequence of strings or paths representing the plugins to be loaded.\n- `builtins`: A boolean indicating whether to include built-in plugins (default is True).\n- `*args` and `**kwargs`: Additional arguments and keyword arguments passed to the superclass constructor.\n\n**Behavior:**\n1. Initializes the `OcrmypdfPluginManager` with provided arguments and keyword arguments, storing them in instance variables.\n2. Calls the superclass constructor using stored arguments and keyword arguments.\n3. Sets up plugins by adding hook specifications.\n4. Registers built-in plugins if specified.\n5. Handles the absence of `multiprocessing.synchronize.SemLock` by registering a custom module to ensure compatibility with multiprocessing environments.\n6. Loads entry points for `ocrmypdf`.\n7. Registers additional plugins based on file paths or module names.\n\n**Edge cases:**\n- If `builtins` is False, no built-in plugins will be loaded.\n- If `multiprocessing.synchronize.SemLock` is not available, a custom module ensures compatibility with multiprocessing environments.\n- The function handles both module names and file paths for plugin registration.\n\n**Python docstring/summary:**\n```python\nclass OcrmypdfPluginManager(pluggy.PluginManager):\n    \"\"\"\n    Manages and loads plugins for the ocrmypdf library. This class allows for flexible plugin\n    registration, including built-in plugins, custom plugins from entry points, and plugins specified by file paths.\n    \"\"\"\n\n    def __init__(self, *args, plugins: Sequence[str | Path], builtins: bool = True, **kwargs):\n        \"\"\"\n        Initializes the OcrmypdfPluginManager with provided arguments and keyword arguments.\n\n        :param args: Additional positional arguments passed to the superclass constructor.\n        :param plugins: A sequence of strings or paths representing the plugins to be loaded.\n        :param builtins: A boolean indicating whether to include built-in plugins (default is True).\n        :param kwargs: Additional keyword arguments passed to the superclass constructor.\n        \"\"\"\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n\n    def __getstate__(self):\n        \"\"\"\n        Returns the state of the object for serialization.\n\n        :return: Dictionary containing the state of the object.\n        \"\"\"\n        state = dict(\n            init_args=self.__init_args,\n            plugins=self.__plugins,\n            builtins=self.__builtins,\n            init_kwargs=self.__init_kwargs,\n        )\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"\n        Restores the state of the object from a serialized state.\n\n        :param state: Dictionary containing the state of the object.\n        \"\"\"\n        self.__init__(\n            *state['init_args'],\n            plugins=state['plugins'],\n            builtins=state['builtins'],\n            **state['init_kwargs'],\n        )\n\n    def setup_plugins(self):\n        \"\"\"\n        Sets up plugins by adding hook specifications, registering built-in plugins if specified,\n        handling the absence of multiprocessing.synchronize.SemLock, and loading entry points for ocrmypdf.\n        \"\"\"\n        self.add_hookspecs(pluginspec)\n\n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n        try:\n            from multiprocessing.synchronize import SemLock\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n        self.load_setuptools_entrypoints('ocrmypdf')\n\n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                module = importlib.import_module(name)\n            self.register(module)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_resolution", "whole_func_string": "def test_resolution():\n    Resolution = helpers.Resolution\n    dpi_100 = Resolution(100, 100)\n    dpi_200 = Resolution(200, 200)\n    assert dpi_100.is_square\n    assert not Resolution(100, 200).is_square\n    assert dpi_100 == Resolution(100, 100)\n    assert str(dpi_100) != str(dpi_200)\n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400)", "func_code_string": "def test_resolution():\n    Resolution = helpers.Resolution\n    dpi_100 = Resolution(100, 100)\n    dpi_200 = Resolution(200, 200)\n    assert dpi_100.is_square\n    assert not Resolution(100, 200).is_square\n    assert dpi_100 == Resolution(100, 100)\n    assert str(dpi_100) != str(dpi_200)\n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_helpers.py\\nFunction/Class: test_resolution\\n```python\\ndef test_resolution():\\n    Resolution = helpers.Resolution\\n    dpi_100 = Resolution(100, 100)\\n    dpi_200 = Resolution(200, 200)\\n    assert dpi_100.is_square\\n    assert not Resolution(100, 200).is_square\\n    assert dpi_100 == Resolution(100, 100)\\n    assert str(dpi_100) != str(dpi_200)\\n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `test_resolution` function is designed to test the functionality of a class named `Resolution`. This class likely represents a resolution with properties such as dots per inch (DPI) in both the x and y dimensions. The test function ensures that instances of `Resolution` are correctly identified as square, compared for equality, represented as strings, and manipulated based on certain criteria.\n\n### Analysis\n\n1. **Parameters**: \n   - The function does not take any parameters directly. It uses instances of `Resolution` created within the function.\n\n2. **Behavior**:\n   - The test checks if a resolution is considered square (`is_square` method).\n   - It compares two resolutions for equality.\n   - It converts resolutions to strings and verifies that different resolutions have distinct string representations.\n   - It tests a method `take_max`, which likely returns the maximum value from each dimension of two resolutions.\n\n3. **Edge Cases**:\n   - The function does not explicitly handle edge cases, but implicit ones include invalid DPI values (e.g., negative numbers) and non-integer inputs. However, these cases are not covered in the provided test.\n\n### Python Docstring\n\n```python\ndef test_resolution():\n    \"\"\"\n    Test the Resolution class functionality.\n    \n    This test checks various methods of the Resolution class, including:\n    - Identifying square resolutions.\n    - Comparing resolution instances for equality.\n    - String representation and comparison.\n    - Manipulating resolutions based on maximum values.\n    \"\"\"\n    Resolution = helpers.Resolution\n    dpi_100 = Resolution(100, 100)\n    dpi_200 = Resolution(200, 200)\n    \n    assert dpi_100.is_square, \"dpi_100 should be considered square\"\n    assert not Resolution(100, 200).is_square, \"A non-square resolution should return False for is_square\"\n    \n    assert dpi_100 == Resolution(100, 100), \"Instances with the same DPI values should be equal\"\n    \n    assert str(dpi_100) != str(dpi_200), \"Different resolutions should have different string representations\"\n    \n    assert dpi_100.take_max([200, 300], [400]) == Resolution(300, 400), \"take_max should return the maximum resolution values\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_palette_image", "whole_func_string": "def test_palette_image(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"palette.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_palette_image(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"palette.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_unpaper.py\\nFunction/Class: test_palette_image\\n```python\\ndef test_palette_image(resources, outpdf):\\n    check_ocrmypdf(\\n        resources / \\\"palette.pdf\\\",\\n        outpdf,\\n        \\\"-c\\\",\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `test_palette_image` function is designed to test the OCR processing of a PDF file containing images with a limited color palette (typically palettized images). The goal is to ensure that the OCR tool (`ocrmypdf`) processes such images correctly, even when they do not contain text.\n\n### Parameters\n\n- **resources**: A path object pointing to a directory containing the test resources. This should include the PDF file `palette.pdf` which contains images with a limited color palette.\n  \n- **outpdf**: A path object where the output PDF file will be saved after processing by `ocrmypdf`. This file should be compared against expected results to verify that OCR has been applied correctly.\n\n### Behavior\n\nThe function uses the `check_ocrmypdf` utility to process the PDF file located at `resources / \"palette.pdf\"`. It applies the `--plugin` option with a no-operation Tesseract plugin (`tests/plugins/tesseract_noop.py`). The purpose of using this no-operation plugin is likely to isolate the behavior of `ocrmypdf` itself, rather than any specific OCR engine.\n\n### Edge Cases\n\n- **Empty or Missing Input File**: If `palette.pdf` does not exist at the specified path, the function will raise an error when attempting to read it.\n  \n- **Output Path Issues**: If there are issues writing to the output directory indicated by `outpdf`, the function may fail and raise exceptions related to file handling.\n\n### Docstring\n\n```python\ndef test_palette_image(resources, outpdf):\n    \"\"\"\n    Test OCR processing of a PDF containing images with a limited color palette.\n    \n    Parameters:\n    - resources: Path object to the directory containing the test resources.\n    - outpdf: Path object where the output PDF will be saved after processing.\n\n    This function uses ocrmypdf to process a palettized PDF image, applying a no-operation Tesseract plugin for isolation.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_metadata_fixup_warning", "whole_func_string": "def test_metadata_fixup_warning(resources, outdir, caplog):\n    _parser, options, _pm = get_parser_options_plugins(\n        ['--output-type', 'pdfa-2', 'graph.pdf', 'out.pdf']\n    )\n\n    copyfile(resources / 'graph.pdf', outdir / 'graph.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    for record in caplog.records:\n        assert record.levelname != 'WARNING', \"Unexpected warning\"\n\n                                                     \n    with pikepdf.open(outdir / 'graph.pdf') as graph:\n        with graph.open_metadata() as meta:\n            meta['prism2:publicationName'] = 'OCRmyPDF Test'\n        graph.save(outdir / 'graph_mod.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph_mod.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    assert any(record.levelname == 'WARNING' for record in caplog.records)", "func_code_string": "def test_metadata_fixup_warning(resources, outdir, caplog):\n    _parser, options, _pm = get_parser_options_plugins(\n        ['--output-type', 'pdfa-2', 'graph.pdf', 'out.pdf']\n    )\n\n    copyfile(resources / 'graph.pdf', outdir / 'graph.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    for record in caplog.records:\n        assert record.levelname != 'WARNING', \"Unexpected warning\"\n\n                                                     \n    with pikepdf.open(outdir / 'graph.pdf') as graph:\n        with graph.open_metadata() as meta:\n            meta['prism2:publicationName'] = 'OCRmyPDF Test'\n        graph.save(outdir / 'graph_mod.pdf')\n\n    context = PdfContext(\n        options, outdir, outdir / 'graph_mod.pdf', None, get_plugin_manager([])\n    )\n    metadata_fixup(\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\n    )\n    assert any(record.levelname == 'WARNING' for record in caplog.records)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_metadata_fixup_warning\\n```python\\ndef test_metadata_fixup_warning(resources, outdir, caplog):\\n    _parser, options, _pm = get_parser_options_plugins(\\n        ['--output-type', 'pdfa-2', 'graph.pdf', 'out.pdf']\\n    )\\n\\n    copyfile(resources / 'graph.pdf', outdir / 'graph.pdf')\\n\\n    context = PdfContext(\\n        options, outdir, outdir / 'graph.pdf', None, get_plugin_manager([])\\n    )\\n    metadata_fixup(\\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\\n    )\\n    for record in caplog.records:\\n        assert record.levelname != 'WARNING', \\\"Unexpected warning\\\"\\n\\n                                                     \\n    with pikepdf.open(outdir / 'graph.pdf') as graph:\\n        with graph.open_metadata() as meta:\\n            meta['prism2:publicationName'] = 'OCRmyPDF Test'\\n        graph.save(outdir / 'graph_mod.pdf')\\n\\n    context = PdfContext(\\n        options, outdir, outdir / 'graph_mod.pdf', None, get_plugin_manager([])\\n    )\\n    metadata_fixup(\\n        working_file=outdir / 'graph.pdf', context=context, pdf_save_settings={}\\n    )\\n    assert any(record.levelname == 'WARNING' for record in caplog.records)\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `test_metadata_fixup_warning` function tests the behavior of the `metadata_fixup` function when it encounters a PDF file with existing metadata. Specifically, it checks that the presence of certain metadata fields triggers warnings during the fix-up process.\n\n### Parameters\n\n- **resources (Path)**: The directory containing test resources.\n- **outdir (Path)**: The output directory where files will be created and modified.\n- **caplog (CaplogManager)**: A pytest fixture for capturing log messages.\n\n### Behavior\n\n1. **Initialization**:\n   - Parses command-line options to set up the `options` object.\n   - Copies a test PDF file (`graph.pdf`) from the `resources` directory to the `outdir`.\n\n2. **Initial Metadata Fixup**:\n   - Creates a `PdfContext` object with the provided options and directories.\n   - Calls the `metadata_fixup` function on the copied PDF file.\n   - Asserts that no warning messages are logged.\n\n3. **Metadata Modification**:\n   - Opens the modified PDF (`graph_mod.pdf`) using `pikepdf`.\n   - Updates a metadata field (`prism2:publicationName`) and saves the changes.\n\n4. **Repeating Metadata Fixup**:\n   - Reuses the same `PdfContext` object.\n   - Calls the `metadata_fixup` function again on the original PDF file (`graph.pdf`).\n   - Asserts that at least one warning message is logged.\n\n### Edge Cases\n\n- If no metadata fields are present or if the specified fields do not trigger a warning, the test will fail.\n- If the `metadata_fixup` function does not handle certain metadata changes correctly, it may not log expected warnings.\n\n### Summary\n\n```python\ndef test_metadata_fixup_warning(resources, outdir, caplog):\n    \"\"\"\n    Test that the metadata fix-up process logs a warning when updating specific metadata fields in a PDF.\n    \n    Parameters:\n    - resources (Path): Directory containing test resources.\n    - outdir (Path): Output directory for file operations.\n    - caplog (CaplogManager): Pytest fixture for capturing log messages.\n    \n    This function checks that the presence of certain metadata fields triggers warnings during the fix-up process.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_optional_program_recommended", "whole_func_string": "def test_optional_program_recommended(caplog):\n    caplog.clear()\n\n    def raiser():\n        raise FileNotFoundError('jbig2')\n\n    with caplog.at_level(logging.WARNING):\n        vd.check_external_program(\n            program=\"jbig2\",\n            package=\"jbig2enc\",\n            version_checker=raiser,\n            need_version='42',\n            required_for='this test case',\n            recommended=True,\n        )\n        assert any(\n            (loglevel == logging.WARNING and \"recommended\" in msg)\n            for _logger_name, loglevel, msg in caplog.record_tuples\n        )", "func_code_string": "def test_optional_program_recommended(caplog):\n    caplog.clear()\n\n    def raiser():\n        raise FileNotFoundError('jbig2')\n\n    with caplog.at_level(logging.WARNING):\n        vd.check_external_program(\n            program=\"jbig2\",\n            package=\"jbig2enc\",\n            version_checker=raiser,\n            need_version='42',\n            required_for='this test case',\n            recommended=True,\n        )\n        assert any(\n            (loglevel == logging.WARNING and \"recommended\" in msg)\n            for _logger_name, loglevel, msg in caplog.record_tuples\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_optional_program_recommended\\n```python\\ndef test_optional_program_recommended(caplog):\\n    caplog.clear()\\n\\n    def raiser():\\n        raise FileNotFoundError('jbig2')\\n\\n    with caplog.at_level(logging.WARNING):\\n        vd.check_external_program(\\n            program=\\\"jbig2\\\",\\n            package=\\\"jbig2enc\\\",\\n            version_checker=raiser,\\n            need_version='42',\\n            required_for='this test case',\\n            recommended=True,\\n        )\\n        assert any(\\n            (loglevel == logging.WARNING and \\\"recommended\\\" in msg)\\n            for _logger_name, loglevel, msg in caplog.record_tuples\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level purpose of the function or class**:\n   The `test_optional_program_recommended` function tests the behavior of the `vd.check_external_program` function when a recommended program is involved. Specifically, it checks that a warning is logged if the recommended program is not installed.\n\n2. **Parameters and their analysis**:\n   - `caplog`: This parameter is used for capturing log messages during the test execution.\n   - The nested `raiser()` function simulates raising a `FileNotFoundError` when checking the external program.\n\n3. **Behavior and edge cases**:\n   - The function asserts that when the recommended program (`jbig2enc`) is not installed (simulated by the `raiser` function), a warning message indicating the recommendation of the program is logged.\n   - The function checks for both the log level being `WARNING` and the presence of the word \"recommended\" in the log message.\n\n4. **Concise Python docstring**:\n```python\ndef test_optional_program_recommended(caplog):\n    \"\"\"\n    Test that a warning is logged when a recommended external program is not installed.\n    \n    This function simulates checking for the 'jbig2enc' program and asserts that\n    a warning message indicating its recommendation is logged if it is not found.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_false_action_store_true", "whole_func_string": "def test_false_action_store_true():\n    opts = make_opts(keep_temporary_files=True)\n    assert opts.keep_temporary_files\n    opts = make_opts(keep_temporary_files=False)\n    assert not opts.keep_temporary_files", "func_code_string": "def test_false_action_store_true():\n    opts = make_opts(keep_temporary_files=True)\n    assert opts.keep_temporary_files\n    opts = make_opts(keep_temporary_files=False)\n    assert not opts.keep_temporary_files", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_false_action_store_true\\n```python\\ndef test_false_action_store_true():\\n    opts = make_opts(keep_temporary_files=True)\\n    assert opts.keep_temporary_files\\n    opts = make_opts(keep_temporary_files=False)\\n    assert not opts.keep_temporary_files\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_false_action_store_true` is designed to test the behavior of a class method or function that handles options related to temporary file management. Specifically, it checks whether setting the option to `False` results in the expected behavior.\n\n### Analysis of Parameters and Behavior\n\n1. **Parameters**:\n   - None explicitly defined for this function. The parameters are implicitly passed through the `make_opts` function call.\n\n2. **Behavior**:\n   - The function creates two instances of an options class (`opts`) using the `make_opts` function with different values for the `keep_temporary_files` option.\n   - It then asserts that when `keep_temporary_files` is set to `True`, the option is correctly reflected in the `opts` object.\n   - Similarly, it asserts that when `keep_temporary_files` is set to `False`, the option is also correctly reflected.\n\n3. **Edge Cases**:\n   - The function does not explicitly handle edge cases such as invalid input types or out-of-range values for the `keep_temporary_files` option. It assumes that the `make_opts` function will handle these cases appropriately.\n   - However, it implicitly tests a common edge case: the transition from `True` to `False`.\n\n### Concise Python Docstring\n\n```python\ndef test_false_action_store_true():\n    \"\"\"\n    Tests the behavior of an options class when setting 'keep_temporary_files' to False.\n\n    Asserts that:\n    - Setting 'keep_temporary_files' to True correctly reflects in the options object.\n    - Setting 'keep_temporary_files' to False correctly reflects in the options object.\n    \"\"\"\n    opts = make_opts(keep_temporary_files=True)\n    assert opts.keep_temporary_files, \"Option should be True when set to True\"\n\n    opts = make_opts(keep_temporary_files=False)\n    assert not opts.keep_temporary_files, \"Option should be False when set to False\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_xml_metadata_preserved", "whole_func_string": "def test_xml_metadata_preserved(\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\n):\n    input_file = resources / test_file\n\n    before = libxmp_file_to_dict(str(input_file))\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after = libxmp_file_to_dict(str(outpdf))\n\n    equal_properties = [\n        'dc:contributor',\n        'dc:coverage',\n        'dc:creator',\n        'dc:description',\n        'dc:format',\n        'dc:identifier',\n        'dc:language',\n        'dc:publisher',\n        'dc:relation',\n        'dc:rights',\n        'dc:source',\n        'dc:subject',\n        'dc:title',\n        'dc:type',\n        'pdf:keywords',\n    ]\n    acquired_properties = ['dc:format']\n\n                                  \n                                                                           \n                                                \n    def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries\n\n                                                                         \n                                               \n    def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v\n\n    before = dict(keyval_from_tuple(unify_namespaces(before)))\n    after = dict(keyval_from_tuple(unify_namespaces(after)))\n\n    for prop in equal_properties:\n        if prop in before:\n            assert prop in after, f'{prop} dropped from xmp'\n            assert before[prop] == after[prop]\n\n                                                                 \n                                           \n                                                       \n                                                               \n        propidx = f'{prop}[1]'\n        if propidx in before:\n            assert (\n                after.get(propidx) == before[propidx]\n                or after.get(prop) == before[propidx]\n            )\n\n        if prop in after and prop not in before:\n            assert prop in acquired_properties, (\n                f\"acquired unexpected property {prop} with value \"\n                f\"{after.get(propidx) or after.get(prop)}\"\n            )", "func_code_string": "def test_xml_metadata_preserved(\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\n):\n    input_file = resources / test_file\n\n    before = libxmp_file_to_dict(str(input_file))\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        '--output-type',\n        output_type,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after = libxmp_file_to_dict(str(outpdf))\n\n    equal_properties = [\n        'dc:contributor',\n        'dc:coverage',\n        'dc:creator',\n        'dc:description',\n        'dc:format',\n        'dc:identifier',\n        'dc:language',\n        'dc:publisher',\n        'dc:relation',\n        'dc:rights',\n        'dc:source',\n        'dc:subject',\n        'dc:title',\n        'dc:type',\n        'pdf:keywords',\n    ]\n    acquired_properties = ['dc:format']\n\n                                  \n                                                                           \n                                                \n    def unify_namespaces(xmpdict):\n        for entries in xmpdict.values():\n            yield from entries\n\n                                                                         \n                                               \n    def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v\n\n    before = dict(keyval_from_tuple(unify_namespaces(before)))\n    after = dict(keyval_from_tuple(unify_namespaces(after)))\n\n    for prop in equal_properties:\n        if prop in before:\n            assert prop in after, f'{prop} dropped from xmp'\n            assert before[prop] == after[prop]\n\n                                                                 \n                                           \n                                                       \n                                                               \n        propidx = f'{prop}[1]'\n        if propidx in before:\n            assert (\n                after.get(propidx) == before[propidx]\n                or after.get(prop) == before[propidx]\n            )\n\n        if prop in after and prop not in before:\n            assert prop in acquired_properties, (\n                f\"acquired unexpected property {prop} with value \"\n                f\"{after.get(propidx) or after.get(prop)}\"\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_xml_metadata_preserved\\n```python\\ndef test_xml_metadata_preserved(\\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\\n):\\n    input_file = resources / test_file\\n\\n    before = libxmp_file_to_dict(str(input_file))\\n\\n    check_ocrmypdf(\\n        input_file,\\n        outpdf,\\n        '--output-type',\\n        output_type,\\n        '--skip-text',\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n\\n    after = libxmp_file_to_dict(str(outpdf))\\n\\n    equal_properties = [\\n        'dc:contributor',\\n        'dc:coverage',\\n        'dc:creator',\\n        'dc:description',\\n        'dc:format',\\n        'dc:identifier',\\n        'dc:language',\\n        'dc:publisher',\\n        'dc:relation',\\n        'dc:rights',\\n        'dc:source',\\n        'dc:subject',\\n        'dc:title',\\n        'dc:type',\\n        'pdf:keywords',\\n    ]\\n    acquired_properties = ['dc:format']\\n\\n                                  \\n                                                                           \\n                                                \\n    def unify_namespaces(xmpdict):\\n        for entries in xmpdict.values():\\n            yield from entries\\n\\n                                                                         \\n                                               \\n    def keyval_from_tuple(list_of_tuples):\\n        for k, v, *_ in list_of_tuples:\\n            yield k, v\\n\\n    before = dict(keyval_from_tuple(unify_namespaces(before)))\\n    after = dict(keyval_from_tuple(unify_namespaces(after)))\\n\\n    for prop in equal_properties:\\n        if prop in before:\\n            assert prop in after, f'{prop} dropped from xmp'\\n            assert before[prop] == after[prop]\\n\\n                                                                 \\n                                           \\n                                                       \\n                                                               \\n        propidx = f'{prop}[1]'\\n        if propidx in before:\\n            assert (\\n                after.get(propidx) == before[propidx]\\n                or after.get(prop) == before[propidx]\\n            )\\n\\n        if prop in after and prop not in before:\\n            assert prop in acquired_properties, (\\n                f\\\"acquired unexpected property {prop} with value \\\"\\n                f\\\"{after.get(propidx) or after.get(prop)}\\\"\\n            )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe function `test_xml_metadata_preserved` is designed to test whether XML metadata is preserved during the OCR processing of PDF files using a specified OCR tool (`ocrmypdf`). It ensures that specific properties are either maintained, updated, or acquired as expected after the OCR operation.\n\n### Parameters\n\n- **libxmp_file_to_dict**: A function that converts an XMP file (typically associated with a PDF) into a dictionary.\n- **test_file**: The name of the test PDF file to be processed.\n- **output_type**: The desired output type for the processed PDF file, which can affect metadata handling.\n- **resources**: A directory containing resource files used during testing.\n- **outpdf**: The output path where the processed PDF will be saved.\n\n### Behavior\n\n1. **Input Preparation**: The function reads the input PDF file from the `resources` directory using the provided `test_file` name.\n2. **Metadata Extraction**: It extracts metadata from both the original and processed PDF files using the `libxmp_file_to_dict` function.\n3. **Namespace Normalization**: Both sets of metadata are normalized to ensure consistent key-value pairs for comparison.\n4. **Property Comparison**:\n   - The function checks that specified properties (`equal_properties`) remain either unchanged or updated consistently between the original and processed PDFs.\n   - It also verifies that newly acquired properties (`acquired_properties`) adhere to expected values.\n5. **Error Handling**: Assertions are used to validate metadata integrity, and any discrepancies are reported as errors.\n\n### Edge Cases\n\n- If a specified property is missing in the processed PDF but was present in the original, it is considered an error unless the property is listed in `acquired_properties`.\n- The function does not account for properties that might be altered or removed by other OCR settings or plugins.\n\n### Summary\n\n```python\ndef test_xml_metadata_preserved(\n    libxmp_file_to_dict, test_file, output_type, resources, outpdf\n):\n    \"\"\"\n    Test whether XML metadata is preserved during OCR processing of PDF files.\n    \n    Parameters:\n    - libxmp_file_to_dict: Function to convert an XMP file to a dictionary.\n    - test_file: Name of the test PDF file.\n    - output_type: Desired output type for the processed PDF.\n    - resources: Directory containing resource files.\n    - outpdf: Output path for the processed PDF.\n\n    The function ensures that specific metadata properties are either maintained,\n    updated, or acquired as expected after OCR processing.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_no_progress_bar", "whole_func_string": "def test_no_progress_bar(progress_bar, resources):\n    opts, pm = make_opts_pm(\n        progress_bar=progress_bar, input_file=(resources / 'trivial.pdf')\n    )\n    vd.check_options(opts, pm)\n\n    pbar_disabled = None\n\n    class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)\n\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\n\n    assert pdfinfo is not None\n    assert pbar_disabled is not None and pbar_disabled != progress_bar", "func_code_string": "def test_no_progress_bar(progress_bar, resources):\n    opts, pm = make_opts_pm(\n        progress_bar=progress_bar, input_file=(resources / 'trivial.pdf')\n    )\n    vd.check_options(opts, pm)\n\n    pbar_disabled = None\n\n    class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)\n\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\n\n    assert pdfinfo is not None\n    assert pbar_disabled is not None and pbar_disabled != progress_bar", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_no_progress_bar\\n```python\\ndef test_no_progress_bar(progress_bar, resources):\\n    opts, pm = make_opts_pm(\\n        progress_bar=progress_bar, input_file=(resources / 'trivial.pdf')\\n    )\\n    vd.check_options(opts, pm)\\n\\n    pbar_disabled = None\\n\\n    class CheckProgressBar(NullProgressBar):\\n        def __init__(self, disable, **kwargs):\\n            nonlocal pbar_disabled\\n            pbar_disabled = disable\\n            super().__init__(disable=disable, **kwargs)\\n\\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\\n\\n    assert pdfinfo is not None\\n    assert pbar_disabled is not None and pbar_disabled != progress_bar\\n```\", \"assistant\": \"\"}", "response": "### Function Purpose\nThe `test_no_progress_bar` function is designed to test the behavior of a PDF processing tool when no progress bar is enabled. It ensures that the progress bar setting can be dynamically changed and verified, even if it differs from the initial configuration.\n\n### Parameters\n- **progress_bar**: A boolean indicating whether the progress bar should be enabled or not.\n- **resources**: A directory containing resource files used in the test.\n\n### Behavior\n1. The function initializes options (`opts`) and a progress manager (`pm`) using the `make_opts_pm` function, passing the provided `progress_bar` setting.\n2. It then calls the `vd.check_options(opts, pm)` function to validate the options and progress manager.\n3. A custom progress bar class `CheckProgressBar` is defined by inheriting from `NullProgressBar`. This class overrides the constructor to capture whether the progress bar was disabled during initialization.\n4. An executor (`executor`) is created using `SerialExecutor`, specifying `CheckProgressBar` as the progress bar class.\n5. The `PdfInfo` object is instantiated with the input file, initial progress bar setting, and the custom executor.\n6. Assertions are made to ensure that both the `PdfInfo` object and the `pbar_disabled` flag (which indicates whether the progress bar was disabled during execution) are not `None`.\n7. The function also verifies that the `pbar_disabled` value is different from the initial `progress_bar` setting, indicating that it has been dynamically changed.\n\n### Edge Cases\n- If `progress_bar` is `True`, the test ensures that the progress bar is indeed disabled during execution.\n- If `progress_bar` is `False`, the test ensures that the progress bar remains enabled or behaves as expected.\n- The function handles dynamic changes to the progress bar setting and verifies these changes.\n\n### Python Docstring\n```python\ndef test_no_progress_bar(progress_bar, resources):\n    \"\"\"\n    Test the behavior of PDF processing with no progress bar enabled.\n\n    Parameters:\n    - progress_bar (bool): Indicates whether the progress bar should be enabled.\n    - resources (Path): Directory containing resource files used in the test.\n\n    The function initializes options and a progress manager using the provided\n    progress bar setting, validates them, and then creates a custom progress\n    bar class to capture its disabled state. It instantiates a PDF info object with\n    dynamic progress bar settings and verifies that the progress bar behavior is as expected.\n    \"\"\"\n    opts, pm = make_opts_pm(progress_bar=progress_bar, input_file=(resources / 'trivial.pdf'))\n    vd.check_options(opts, pm)\n\n    pbar_disabled = None\n\n    class CheckProgressBar(NullProgressBar):\n        def __init__(self, disable, **kwargs):\n            nonlocal pbar_disabled\n            pbar_disabled = disable\n            super().__init__(disable=disable, **kwargs)\n\n    executor = SerialExecutor(pbar_class=CheckProgressBar)\n    pdfinfo = PdfInfo(opts.input_file, progbar=opts.progress_bar, executor=executor)\n\n    assert pdfinfo is not None\n    assert pbar_disabled is not None and pbar_disabled != progress_bar\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "make_intermediate_images", "whole_func_string": "def make_intermediate_images(\n    page_context: PageContext, orientation_correction: int\n) -> tuple[Path, Path | None]:\n                                                              \n    options = page_context.options\n\n    ocr_image = preprocess_out = None\n    rasterize_out = rasterize(\n        page_context.origin,\n        page_context,\n        correction=orientation_correction,\n        remove_vectors=False,\n    )\n\n    if not any([options.clean, options.clean_final, options.remove_vectors]):\n        ocr_image = preprocess_out = preprocess(\n            page_context,\n            rasterize_out,\n            options.remove_background,\n            options.deskew,\n            clean=False,\n        )\n    else:\n        if not options.lossless_reconstruction:\n            preprocess_out = preprocess(\n                page_context,\n                rasterize_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean_final,\n            )\n        if options.remove_vectors:\n            rasterize_ocr_out = rasterize(\n                page_context.origin,\n                page_context,\n                correction=orientation_correction,\n                remove_vectors=True,\n                output_tag='_ocr',\n            )\n        else:\n            rasterize_ocr_out = rasterize_out\n\n        if (\n            preprocess_out\n            and rasterize_ocr_out == rasterize_out\n            and options.clean == options.clean_final\n        ):\n                                                                            \n            ocr_image = preprocess_out\n        else:\n            ocr_image = preprocess(\n                page_context,\n                rasterize_ocr_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean,\n            )\n    return ocr_image, preprocess_out", "func_code_string": "def make_intermediate_images(\n    page_context: PageContext, orientation_correction: int\n) -> tuple[Path, Path | None]:\n                                                              \n    options = page_context.options\n\n    ocr_image = preprocess_out = None\n    rasterize_out = rasterize(\n        page_context.origin,\n        page_context,\n        correction=orientation_correction,\n        remove_vectors=False,\n    )\n\n    if not any([options.clean, options.clean_final, options.remove_vectors]):\n        ocr_image = preprocess_out = preprocess(\n            page_context,\n            rasterize_out,\n            options.remove_background,\n            options.deskew,\n            clean=False,\n        )\n    else:\n        if not options.lossless_reconstruction:\n            preprocess_out = preprocess(\n                page_context,\n                rasterize_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean_final,\n            )\n        if options.remove_vectors:\n            rasterize_ocr_out = rasterize(\n                page_context.origin,\n                page_context,\n                correction=orientation_correction,\n                remove_vectors=True,\n                output_tag='_ocr',\n            )\n        else:\n            rasterize_ocr_out = rasterize_out\n\n        if (\n            preprocess_out\n            and rasterize_ocr_out == rasterize_out\n            and options.clean == options.clean_final\n        ):\n                                                                            \n            ocr_image = preprocess_out\n        else:\n            ocr_image = preprocess(\n                page_context,\n                rasterize_ocr_out,\n                options.remove_background,\n                options.deskew,\n                clean=options.clean,\n            )\n    return ocr_image, preprocess_out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/_common.py\\nFunction/Class: make_intermediate_images\\n```python\\ndef make_intermediate_images(\\n    page_context: PageContext, orientation_correction: int\\n) -> tuple[Path, Path | None]:\\n                                                              \\n    options = page_context.options\\n\\n    ocr_image = preprocess_out = None\\n    rasterize_out = rasterize(\\n        page_context.origin,\\n        page_context,\\n        correction=orientation_correction,\\n        remove_vectors=False,\\n    )\\n\\n    if not any([options.clean, options.clean_final, options.remove_vectors]):\\n        ocr_image = preprocess_out = preprocess(\\n            page_context,\\n            rasterize_out,\\n            options.remove_background,\\n            options.deskew,\\n            clean=False,\\n        )\\n    else:\\n        if not options.lossless_reconstruction:\\n            preprocess_out = preprocess(\\n                page_context,\\n                rasterize_out,\\n                options.remove_background,\\n                options.deskew,\\n                clean=options.clean_final,\\n            )\\n        if options.remove_vectors:\\n            rasterize_ocr_out = rasterize(\\n                page_context.origin,\\n                page_context,\\n                correction=orientation_correction,\\n                remove_vectors=True,\\n                output_tag='_ocr',\\n            )\\n        else:\\n            rasterize_ocr_out = rasterize_out\\n\\n        if (\\n            preprocess_out\\n            and rasterize_ocr_out == rasterize_out\\n            and options.clean == options.clean_final\\n        ):\\n                                                                            \\n            ocr_image = preprocess_out\\n        else:\\n            ocr_image = preprocess(\\n                page_context,\\n                rasterize_ocr_out,\\n                options.remove_background,\\n                options.deskew,\\n                clean=options.clean,\\n            )\\n    return ocr_image, preprocess_out\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `make_intermediate_images` function processes a PDF page to create intermediate images that may be used for Optical Character Recognition (OCR). It handles different preprocessing steps based on the provided options and orientation correction.\n\n### Parameters\n\n- **page_context** (`PageContext`): An object containing context information about the current page, including its origin, options, etc.\n- **orientation_correction** (`int`): The angle by which the page needs to be rotated for correct orientation before processing.\n\n### Behavior\n\nThe function performs the following steps:\n\n1. **Rasterization**: It first rasterizes the page to a bitmap image using the `rasterize` function. This is done regardless of whether OCR will be performed later.\n2. **Preprocessing**: If no cleaning or vector removal options are enabled (`options.clean`, `options.clean_final`, or `options.remove_vectors`), it preprocesses the rasterized image. This includes removing the background and optionally deskewing.\n3. **Advanced Preprocessing**: If cleaning or vector removal is enabled, it performs more sophisticated preprocessing:\n   - It rasterizes the page again with additional options if vector removal is required.\n   - Depending on whether cleaning and cleaning settings are consistent, it preprocesses the original or modified image.\n\n### Edge Cases\n\n- **No Cleanup/Vector Removal**: If no cleanup or vector removal is specified (`options.clean`, `options.clean_final`, `options.remove_vectors`), the function preprocessed the image once with background removal and deskewing.\n- **Lossless Reconstruction**: If lossless reconstruction is enabled, it only applies cleaning if `clean_final` is set.\n- **Vector Removal**: When vector removal is required, a separate rasterization step is performed.\n\n### Return Value\n\nThe function returns a tuple containing two elements:\n- The final OCR image (`ocr_image`), which may be the original rasterized image or a preprocessed version based on the options.\n- The potentially preprocessed image (`preprocess_out`), which could be `None` if no preprocessing was applied.\n\n### Docstring\n\n```python\ndef make_intermediate_images(\n    page_context: PageContext, orientation_correction: int\n) -> tuple[Path, Path | None]:\n    \"\"\"\n    Process a PDF page to create intermediate images for OCR.\n\n    Args:\n        page_context (PageContext): The context object containing information about the current page.\n        orientation_correction (int): The angle by which the page needs to be rotated.\n\n    Returns:\n        tuple: A tuple containing the final OCR image and the preprocessed image, if any.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "__call__", "whole_func_string": "def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_code_string": "def __call__(self, parser, namespace, values, option_string=None):\n                                        \n        dest = getattr(namespace, self.dest)\n        if '+' in values:\n            [dest.append(lang) for lang in values.split('+')]\n        else:\n            dest.append(values)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/cli.py\\nFunction/Class: __call__\\n```python\\ndef __call__(self, parser, namespace, values, option_string=None):\\n                                        \\n        dest = getattr(namespace, self.dest)\\n        if '+' in values:\\n            [dest.append(lang) for lang in values.split('+')]\\n        else:\\n            dest.append(values)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `__call__` method is part of a class and serves as the entry point for command-line argument parsing. Its primary purpose is to handle the processing of language codes from command-line arguments and store them in the appropriate attribute of the namespace object.\n\n### Parameters\n\n- **parser**: The argument parser object that handles the parsing of command-line arguments.\n- **namespace**: The object that holds all the parsed command-line options and values.\n- **values**: The value(s) associated with the option being processed. This can be a single language code or multiple language codes separated by '+'.\n- **option_string**: A string representing the name of the option (e.g., `'-l'` for `--language`).\n\n### Behavior\n\n1. **Retrieve Destination Attribute**: The method retrieves the destination attribute from the namespace object using the `self.dest` attribute.\n2. **Check for Multiple Language Codes**:\n   - If the value contains a '+' character, it is split into individual language codes.\n   - Each language code is then appended to the destination list.\n3. **Append Single Language Code**: If no '+' character is present, the single language code is appended directly to the destination list.\n\n### Edge Cases\n\n- **Empty Input**: If `values` is an empty string or not provided, no action is taken.\n- **Invalid Language Code**: The method does not validate the format of the language codes. It assumes that any input passed as a valid language code.\n- **Handling '+' in Values**: The presence of a '+' character correctly splits and appends multiple language codes.\n\n### Python Docstring\n\n```python\ndef __call__(self, parser, namespace, values, option_string=None):\n    \"\"\"\n    Process language codes from command-line arguments and store them in the appropriate attribute of the namespace object.\n    \n    Args:\n        parser: The argument parser object.\n        namespace: The object holding parsed command-line options and values.\n        values: The value(s) associated with the option being processed.\n        option_string: A string representing the name of the option.\n\n    Returns:\n        None\n\n    Edge Cases:\n        - Empty input or invalid language codes are handled gracefully without errors.\n        - Multiple language codes can be provided separated by '+'.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "invalid_tess_config", "whole_func_string": "def invalid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nTHIS FILE IS INVALID\n'''\n        )\n    yield cfg_file", "func_code_string": "def invalid_tess_config(outdir):\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\nTHIS FILE IS INVALID\n'''\n        )\n    yield cfg_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: invalid_tess_config\\n```python\\ndef invalid_tess_config(outdir):\\n    cfg_file = outdir / 'test.cfg'\\n    with cfg_file.open('w') as f:\\n        f.write(\\n            '''\\\\\\nTHIS FILE IS INVALID\\n'''\\n        )\\n    yield cfg_file\\n```\", \"assistant\": \"\"}", "response": "### Function: `invalid_tess_config`\n\n**High-Level Purpose:**  \nThe function `invalid_tess_config` creates an invalid configuration file in a specified output directory and yields the path to this file.\n\n**Parameters:**\n- `outdir`: A path-like object representing the directory where the invalid configuration file will be created.\n\n**Behavior:**\n1. The function constructs the path to the configuration file (`test.cfg`) within the provided output directory.\n2. It opens the configuration file in write mode and writes an invalid content string into it:\n   ```python\n   '''\\\\\\nTHIS FILE IS INVALID\\n'''\n   ```\n3. The function yields the path to the newly created configuration file.\n\n**Edge Cases:**\n- If `outdir` does not exist, a `FileNotFoundError` will be raised when attempting to open the file.\n- If there are permissions issues with writing to `outdir`, an `OSError` will be raised.\n- The invalid content written to the file is a simple string that indicates the file's validity status.\n\n**Python Docstring:**\n```python\ndef invalid_tess_config(outdir):\n    \"\"\"\n    Creates an invalid configuration file in the specified output directory and yields its path.\n\n    Parameters:\n    outdir (path-like): The directory where the invalid configuration file will be created.\n\n    Yields:\n    Path: The path to the newly created invalid configuration file.\n    \"\"\"\n    cfg_file = outdir / 'test.cfg'\n    with cfg_file.open('w') as f:\n        f.write(\n            '''\\\\\\nTHIS FILE IS INVALID\\n'''\n        )\n    yield cfg_file\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_metadata.py\\nFunction/Class: __exit__\\n```python\\ndef __exit__(self, exc_type, exc_value, traceback):\\n        return self.progressbar.__exit__(exc_type, exc_value, traceback)\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `__exit__` method is designed to handle the cleanup and finalization of resources when an object's context manager block is exited. In this case, it specifically handles the termination of a progress bar associated with an OCR (Optical Character Recognition) process.\n\n### Parameters\n- **exc_type**: The type of exception that was raised, if any.\n- **exc_value**: The exception instance that was raised, if any.\n- **traceback**: A traceback object representing the stack trace at the point where the exception was raised, if any.\n\n### Behavior\nThe `__exit__` method is invoked when the context manager block is exited, whether normally or via an exception. It delegates the responsibility of closing or updating the progress bar to the `progressbar` attribute of the class instance. This ensures that the progress bar is properly terminated and any associated resources are cleaned up.\n\n### Edge Cases\n- **No Exception**: If the context manager block exits without raising an exception, `exc_type`, `exc_value`, and `traceback` will all be `None`. The method will still call `__exit__` on the progress bar, ensuring it is properly terminated.\n- **Exception Handling**: If an exception occurs within the context manager block, its type, value, and traceback are passed to `__exit__`. This allows the progress bar to handle any necessary cleanup or error reporting related to the exception.\n\n### Python Docstring\n```python\ndef __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"\n    Handles the cleanup of resources when the context manager block is exited.\n    \n    Parameters:\n        exc_type (type): The type of exception that was raised, if any.\n        exc_value (Exception): The exception instance that was raised, if any.\n        traceback (traceback): A traceback object representing the stack trace at\n                                the point where the exception was raised, if any.\n\n    Returns:\n        bool: Always returns `None`, indicating no further action is needed by the caller.\n    \n    Notes:\n        This method delegates the cleanup to the progress bar associated with this instance.\n        It ensures that the progress bar is properly terminated and any resources are cleaned up.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_failure.py", "func_name": "raise_gs_fail", "whole_func_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_raster_failure.py\"\n    )", "func_code_string": "def raise_gs_fail(*args, **kwargs):\n    raise CalledProcessError(\n        1, 'gs', output=b\"\", stderr=b\"TEST ERROR: gs_raster_failure.py\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/gs_raster_failure.py\\nFunction/Class: raise_gs_fail\\n```python\\ndef raise_gs_fail(*args, **kwargs):\\n    raise CalledProcessError(\\n        1, 'gs', output=b\\\"\\\", stderr=b\\\"TEST ERROR: gs_raster_failure.py\\\"\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose:** The `raise_gs_fail` function is designed to simulate the behavior of a failure in a system that typically uses the command-line utility `gs`. This simulation allows developers or automated tests to handle errors gracefully by raising an exception when expected.\n\n**Parameter Analysis:**\n- `*args`: Accepts any number of positional arguments.\n- `**kwargs`: Accepts any number of keyword arguments.\n\n**Behavior:**\nThe function raises a `CalledProcessError` with the following details:\n- Return code: 1\n- Command: 'gs'\n- Output: An empty byte string (`b\"\"`)\n- Standard Error: A byte string containing \"TEST ERROR: gs_raster_failure.py\"\n\n**Edge Cases:**\n- If any positional or keyword arguments are provided, they are ignored.\n- The function does not interact with external systems beyond raising the exception.\n\n**Summary:**\nThe `raise_gs_fail` function is used to simulate a failure when invoking the `gs` command. It raises a `CalledProcessError` with specific attributes to mimic a real-world error scenario in automated tests or simulations where such behavior is required."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "generate_hocr", "whole_func_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_code_string": "def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            Image.open(input_file) as im,\n            open(output_hocr, 'w', encoding='utf-8') as f,\n        ):\n            w, h = im.size\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n        with open(output_text, 'w') as f:\n            f.write('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_debug_rotate.py\\nFunction/Class: generate_hocr\\n```python\\ndef generate_hocr(input_file, output_hocr, output_text, options):\\n        with (\\n            Image.open(input_file) as im,\\n            open(output_hocr, 'w', encoding='utf-8') as f,\\n        ):\\n            w, h = im.size\\n            f.write(HOCR_TEMPLATE.format(str(w), str(h)))\\n        with open(output_text, 'w') as f:\\n            f.write('')\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `generate_hocr` is designed to create an HTML OCR (Optical Character Recognition) file and an empty text file based on the input image. The purpose of this function is to prepare the necessary output files for further processing or display.\n\n### Parameters\n\n1. **input_file** (`str`): The path to the input image file that will be processed.\n2. **output_hocr** (`str`): The path where the HTML OCR file will be saved.\n3. **output_text** (`str`): The path where an empty text file will be created.\n4. **options** (`dict`): A dictionary containing additional options for processing, though it is not used in this function.\n\n### Behavior\n\n1. **Image Processing**:\n   - The input image is opened using the `PIL.Image.open()` method.\n   - The dimensions (width and height) of the image are retrieved and stored in variables `w` and `h`.\n\n2. **HOCR File Creation**:\n   - An HTML OCR file is created and opened for writing with UTF-8 encoding.\n   - The function writes an HOCR template to the file using the retrieved width and height.\n\n3. **Text File Creation**:\n   - An empty text file is created and opened for writing.\n   - The file remains empty as instructed.\n\n### Edge Cases\n\n1. **Invalid Input File**: If the `input_file` does not exist or cannot be opened, a `PIL.UnidentifiedImageError` will be raised.\n2. **File Path Errors**: If any of the output paths (`output_hocr` or `output_text`) are invalid or inaccessible, a file I/O error (e.g., `IOError`, `OSError`) will occur.\n\n### Docstring\n\n```python\ndef generate_hocr(input_file, output_hocr, output_text, options):\n    \"\"\"\n    Generates an HTML OCR file and an empty text file based on the input image.\n\n    Parameters:\n    - input_file (str): The path to the input image file.\n    - output_hocr (str): The path where the HTML OCR file will be saved.\n    - output_text (str): The path where an empty text file will be created.\n    - options (dict): Additional processing options (currently not used).\n\n    Raises:\n    - PIL.UnidentifiedImageError: If the input image is invalid or cannot be opened.\n    - IOError, OSError: If any of the output paths are invalid or inaccessible.\n    \"\"\"\n    with (\n        Image.open(input_file) as im,\n        open(output_hocr, 'w', encoding='utf-8') as f,\n    ):\n        w, h = im.size\n        f.write(HOCR_TEMPLATE.format(str(w), str(h)))\n    with open(output_text, 'w') as f:\n        f.write('')\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "_run_pipeline", "whole_func_string": "def _run_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n    with (\n        manage_work_folder(\n            work_folder=Path(mkdtemp(prefix=\"ocrmypdf.io.\")),\n            retain=options.keep_temporary_files,\n            print_location=options.keep_temporary_files,\n        ) as work_folder,\n        manage_debug_log_handler(options=options, work_folder=work_folder),\n    ):\n        executor = setup_pipeline(options, plugin_manager)\n        check_requested_output_file(options)\n        start_input_file, original_filename = create_input_file(options, work_folder)\n\n                             \n        origin_pdf = triage(\n            original_filename, start_input_file, work_folder / 'origin.pdf', options\n        )\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n\n                                                \n        validate_pdfinfo_options(context)\n\n                              \n        optimize_messages = exec_concurrent(context, executor)\n\n        exitcode = report_output_pdf(options, start_input_file, optimize_messages)\n        return exitcode", "func_code_string": "def _run_pipeline(\n    options: argparse.Namespace,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n    with (\n        manage_work_folder(\n            work_folder=Path(mkdtemp(prefix=\"ocrmypdf.io.\")),\n            retain=options.keep_temporary_files,\n            print_location=options.keep_temporary_files,\n        ) as work_folder,\n        manage_debug_log_handler(options=options, work_folder=work_folder),\n    ):\n        executor = setup_pipeline(options, plugin_manager)\n        check_requested_output_file(options)\n        start_input_file, original_filename = create_input_file(options, work_folder)\n\n                             \n        origin_pdf = triage(\n            original_filename, start_input_file, work_folder / 'origin.pdf', options\n        )\n\n                                           \n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\n\n                                                \n        validate_pdfinfo_options(context)\n\n                              \n        optimize_messages = exec_concurrent(context, executor)\n\n        exitcode = report_output_pdf(options, start_input_file, optimize_messages)\n        return exitcode", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/ocr.py\\nFunction/Class: _run_pipeline\\n```python\\ndef _run_pipeline(\\n    options: argparse.Namespace,\\n    plugin_manager: OcrmypdfPluginManager,\\n) -> ExitCode:\\n    with (\\n        manage_work_folder(\\n            work_folder=Path(mkdtemp(prefix=\\\"ocrmypdf.io.\\\")),\\n            retain=options.keep_temporary_files,\\n            print_location=options.keep_temporary_files,\\n        ) as work_folder,\\n        manage_debug_log_handler(options=options, work_folder=work_folder),\\n    ):\\n        executor = setup_pipeline(options, plugin_manager)\\n        check_requested_output_file(options)\\n        start_input_file, original_filename = create_input_file(options, work_folder)\\n\\n                             \\n        origin_pdf = triage(\\n            original_filename, start_input_file, work_folder / 'origin.pdf', options\\n        )\\n\\n                                           \\n        pdfinfo = do_get_pdfinfo(origin_pdf, executor, options)\\n        context = PdfContext(options, work_folder, origin_pdf, pdfinfo, plugin_manager)\\n\\n                                                \\n        validate_pdfinfo_options(context)\\n\\n                              \\n        optimize_messages = exec_concurrent(context, executor)\\n\\n        exitcode = report_output_pdf(options, start_input_file, optimize_messages)\\n        return exitcode\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `_run_pipeline` function is the core of the OCR processing workflow in the `ocrmypdf` library. It orchestrates the entire OCR pipeline by managing temporary files, setting up a pipeline executor, and executing various stages of PDF processing.\n\n### Parameters\n- **options**: An instance of `argparse.Namespace` containing command-line arguments.\n- **plugin_manager**: An instance of `OcrmypdfPluginManager` for managing any plugins used during the OCR process.\n\n### Behavior\n1. **Temporary File Management**: It creates and manages a temporary work folder where all intermediate files are stored. The folder is retained if specified by the user, and its location is printed if debugging is enabled.\n2. **Debug Logging Setup**: Sets up a debug log handler based on the provided options.\n3. **Pipeline Executor Setup**: Initializes an executor for handling the OCR tasks.\n4. **Input File Handling**: Creates an input file from the original PDF and sets up the necessary variables.\n5. **PDF Triage**: Analyzes the original PDF to determine its state and create a triage file if needed.\n6. **PDF Information Retrieval**: Retrieves metadata about the PDF using `do_get_pdfinfo`.\n7. **Context Initialization**: Initializes a `PdfContext` object containing all relevant information for the OCR process.\n8. **Option Validation**: Validates any options that may affect the processing.\n9. **Concurrent Execution**: Executes concurrent tasks related to optimizing the PDF.\n10. **Output Report**: Generates and reports the final output PDF and returns an exit code based on the success or failure of the process.\n\n### Edge Cases\n- If temporary file retention is enabled, the work folder will persist even after the OCR process completes.\n- Debug logging can be enabled for troubleshooting purposes, which may affect performance but provides detailed logs about the processing steps.\n- The function handles any errors during PDF triage, information retrieval, and output reporting by returning an appropriate exit code.\n\n### Summary\n```python\ndef _run_pipeline(options: argparse.Namespace, plugin_manager: OcrmypdfPluginManager) -> ExitCode:\n    \"\"\"\n    Orchestrates the OCR pipeline for a given PDF file. Manages temporary files,\n    sets up pipeline executor, and executes various stages of PDF processing.\n\n    Parameters:\n        options (argparse.Namespace): Command-line arguments.\n        plugin_manager (OcrmypdfPluginManager): Plugin manager for handling OCR plugins.\n\n    Returns:\n        ExitCode: An integer indicating the success or failure of the OCR process.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "TestSafeSymlink", "whole_func_string": "class TestSafeSymlink:\n    def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING\n\n    def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n\n    @needs_symlink\n    def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_code_string": "class TestSafeSymlink:\n    def test_safe_symlink_link_self(self, tmp_path, caplog):\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING\n\n    def test_safe_symlink_overwrite(self, tmp_path):\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n\n    @needs_symlink\n    def test_safe_symlink_relink(self, tmp_path):\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_helpers.py\\nFunction/Class: TestSafeSymlink\\n```python\\nclass TestSafeSymlink:\\n    def test_safe_symlink_link_self(self, tmp_path, caplog):\\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\\n        assert caplog.record_tuples[0][1] == logging.WARNING\\n\\n    def test_safe_symlink_overwrite(self, tmp_path):\\n        (tmp_path / 'regular_file').touch()\\n        with pytest.raises(FileExistsError):\\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\\n\\n    @needs_symlink\\n    def test_safe_symlink_relink(self, tmp_path):\\n        (tmp_path / 'regular_file_a').touch()\\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\\n            tmp_path / 'link'\\n        ).read_bytes() == b'ABC'\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `TestSafeSymlink` class is designed to test the `safe_symlink` function from a module named `helpers`. This function is expected to create a symbolic link between two paths, handling cases where the target might already exist and potentially overriding it.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n1. **Parameters**:\n   - `tmp_path`: A temporary path provided by `pytest` for testing purposes.\n   - `caplog`: A fixture from `pytest` that captures log messages during test execution.\n   - `needs_symlink`: A custom decorator or fixture required for certain tests.\n\n2. **Behavior**:\n   - The class contains three methods to test different scenarios related to creating symbolic links using the `safe_symlink` function.\n   - Each method focuses on a specific edge case, such as linking a file to itself, attempting to link over an existing regular file, and relinking an existing symlink.\n\n3. **Edge Cases**:\n   - Linking a file to itself: This should trigger a warning but not raise an exception.\n   - Overwriting an existing regular file: This should raise a `FileExistsError`.\n   - Relinking an existing symlink: This should update the symlink to point to the new target.\n\n### Python Docstring/Summary\n\n```python\nclass TestSafeSymlink:\n    \"\"\"\n    Tests the safe_symlink function from the helpers module.\n    \n    The class includes methods to test different scenarios related to creating symbolic links,\n    handling cases where the target might already exist and potentially overriding it.\n    \"\"\"\n    \n    def test_safe_symlink_link_self(self, tmp_path, caplog):\n        \"\"\"\n        Test linking a file to itself. This should trigger a warning but not raise an exception.\n        \n        Parameters:\n            tmp_path (Path): A temporary path for testing.\n            caplog (CaplogFixture): Captures log messages during the test.\n        \"\"\"\n        helpers.safe_symlink(tmp_path / 'self', tmp_path / 'self')\n        assert caplog.record_tuples[0][1] == logging.WARNING\n    \n    def test_safe_symlink_overwrite(self, tmp_path):\n        \"\"\"\n        Test attempting to link over an existing regular file. This should raise a FileExistsError.\n        \n        Parameters:\n            tmp_path (Path): A temporary path for testing.\n        \"\"\"\n        (tmp_path / 'regular_file').touch()\n        with pytest.raises(FileExistsError):\n            helpers.safe_symlink(tmp_path / 'input', tmp_path / 'regular_file')\n    \n    @needs_symlink\n    def test_safe_symlink_relink(self, tmp_path):\n        \"\"\"\n        Test relinking an existing symlink. This should update the symlink to point to the new target.\n        \n        Parameters:\n            tmp_path (Path): A temporary path for testing.\n            \n        Notes:\n            The method assumes a custom decorator 'needs_symlink' is defined elsewhere in the codebase.\n        \"\"\"\n        (tmp_path / 'regular_file_a').touch()\n        (tmp_path / 'regular_file_b').write_bytes(b'ABC')\n        (tmp_path / 'link').symlink_to(tmp_path / 'regular_file_a')\n        helpers.safe_symlink(tmp_path / 'regular_file_b', tmp_path / 'link')\n        assert (tmp_path / 'link').samefile(tmp_path / 'regular_file_b') or (\n            tmp_path / 'link'\n        ).read_bytes() == b'ABC'\n```\n\nThis documentation provides a clear understanding of the purpose, parameters, behavior, and edge cases for each method in the `TestSafeSymlink` class."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "test_gs_install_locations", "whole_func_string": "def test_gs_install_locations():\n                                             \n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\n\n    assert _gs_version_in_path_key(Path(\"C:\\\\Program Files\\\\gs\\\\gs9.52\\\\bin\")) == (\n        'gs',\n        Version('9.52'),\n    )", "func_code_string": "def test_gs_install_locations():\n                                             \n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\n\n    assert _gs_version_in_path_key(Path(\"C:\\\\Program Files\\\\gs\\\\gs9.52\\\\bin\")) == (\n        'gs',\n        Version('9.52'),\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_helpers.py\\nFunction/Class: test_gs_install_locations\\n```python\\ndef test_gs_install_locations():\\n                                             \\n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\\n\\n    assert _gs_version_in_path_key(Path(\\\"C:\\\\\\\\Program Files\\\\\\\\gs\\\\\\\\gs9.52\\\\\\\\bin\\\")) == (\\n        'gs',\\n        Version('9.52'),\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_gs_install_locations` is designed to test the extraction of Ghostscript version information from a specified path. This ensures that the `_gs_version_in_path_key` function correctly identifies the Ghostscript executable and its version number.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**: The function takes no parameters.\n- **Behavior**:\n  - It imports the `_gs_version_in_path_key` function from `ocrmypdf.subprocess._windows`.\n  - It asserts that calling `_gs_version_in_path_key` with a specific path (`C:\\\\Program Files\\\\\\\\gs\\\\\\\\gs9.52\\\\\\\\bin`) returns a tuple containing 'gs' as the executable name and `Version('9.52')` as the version number.\n- **Edge Cases**:\n  - The function assumes that the Ghostscript installation path is in the format `C:\\\\Program Files\\\\\\\\gs\\\\\\\\gsX.XX\\\\\\\\bin`, where `XX` represents the version number.\n  - It does not handle paths with different formats or incorrect versions.\n\n### Python Docstring\n\n```python\ndef test_gs_install_locations():\n    \"\"\"\n    Test the extraction of Ghostscript version information from a specified path.\n\n    Asserts that `_gs_version_in_path_key` correctly identifies the Ghostscript executable and its version number.\n\n    Edge cases: Assumes the Ghostscript installation path is in the format C:\\\\Program Files\\\\\\\\gs\\\\\\\\gsX.XX\\\\\\\\bin.\n    \"\"\"\n    from ocrmypdf.subprocess._windows import _gs_version_in_path_key\n\n    assert _gs_version_in_path_key(Path(\"C:\\\\Program Files\\\\gs\\\\gs9.52\\\\bin\")) == (\n        'gs',\n        Version('9.52'),\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_quick", "whole_func_string": "def test_quick(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\n    )", "func_code_string": "def test_quick(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_quick\\n```python\\ndef test_quick(resources, outpdf):\\n    check_ocrmypdf(\\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**Purpose**: The `test_quick` function is designed to perform a quick OCR (Optical Character Recognition) test using the `ocrmypdf` tool. It specifically aims to verify that the OCR process can successfully handle a PDF file and output the result to a specified file.\n\n**Analysis of Parameters**:\n- **resources (Path)**: This parameter represents the directory containing the input PDF files for testing.\n- **outpdf (Path)**: This parameter specifies the path where the output PDF file, after OCR processing, should be saved.\n\n**Behavior**:\n- The function calls `check_ocrmypdf` with three arguments:\n  - The path to a specific PDF file (`resources / 'ccitt.pdf'`) which is known to contain CCITT Group 4 fax-encoded images.\n  - The output path for the processed PDF (`outpdf`).\n  - A plugin option that specifies the use of `tesseract_cache.py`, a custom OCR plugin designed for caching results.\n\n**Edge Cases**:\n- If the input file (`ccitt.pdf`) is not found in the specified `resources` directory, the function will raise an error.\n- If there is an issue with the OCR process or if the output PDF cannot be written to the specified path, the function may fail or generate an error.\n\n### Python Docstring\n\n```python\ndef test_quick(resources: Path, outpdf: Path) -> None:\n    \"\"\"\n    Perform a quick OCR test using ocrmypdf on a specific PDF file.\n\n    Parameters:\n    - resources (Path): Directory containing the input PDF files for testing.\n    - outpdf (Path): Path where the output PDF file, after OCR processing, should be saved.\n\n    Raises:\n    - FileNotFoundError: If the input PDF file is not found in the specified directory.\n    - Exception: If there are issues during the OCR process or writing the output file.\n    \"\"\"\n    check_ocrmypdf(\n        resources / 'ccitt.pdf', outpdf, '--plugin', 'tests/plugins/tesseract_cache.py'\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "ocr_engine_hocr", "whole_func_string": "def ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\n                                                      \n    hocr_out = page_context.get_path('ocr_hocr.hocr')\n    hocr_text_out = page_context.get_path('ocr_hocr.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_hocr(\n        input_file=input_file,\n        output_hocr=hocr_out,\n        output_text=hocr_text_out,\n        options=options,\n    )\n    return hocr_out, hocr_text_out", "func_code_string": "def ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\n                                                      \n    hocr_out = page_context.get_path('ocr_hocr.hocr')\n    hocr_text_out = page_context.get_path('ocr_hocr.txt')\n    options = page_context.options\n\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\n    ocr_engine.generate_hocr(\n        input_file=input_file,\n        output_hocr=hocr_out,\n        output_text=hocr_text_out,\n        options=options,\n    )\n    return hocr_out, hocr_text_out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: ocr_engine_hocr\\n```python\\ndef ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\\n                                                      \\n    hocr_out = page_context.get_path('ocr_hocr.hocr')\\n    hocr_text_out = page_context.get_path('ocr_hocr.txt')\\n    options = page_context.options\\n\\n    ocr_engine = page_context.plugin_manager.hook.get_ocr_engine()\\n    ocr_engine.generate_hocr(\\n        input_file=input_file,\\n        output_hocr=hocr_out,\\n        output_text=hocr_text_out,\\n        options=options,\\n    )\\n    return hocr_out, hocr_text_out\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `ocr_engine_hocr` function processes an input file to generate HTML Overlaid Character Recognition (HOCR) output along with plain text. It utilizes a configurable OCR engine to perform the recognition and saves the results in specified files.\n\n### Parameters\n- **input_file** (`Path`): The path to the input PDF or image file that needs to be processed.\n- **page_context** (`PageContext`): A context object containing various settings, options, and paths necessary for processing.\n\n### Behavior\n1. Extracts the paths for HOCR output (`ocr_hocr.hocr`) and plain text output (`ocr_hocr.txt`) from the `page_context`.\n2. Retrieves the OCR engine to be used from the `page_context.plugin_manager`.\n3. Calls the OCR engine's `generate_hocr` method, passing the input file, HOCR output path, text output path, and any additional options.\n4. Returns a tuple containing the paths to the generated HOCR and text files.\n\n### Edge Cases\n- If the OCR engine fails to process the file, it will raise an exception that needs to be handled by the caller.\n- Ensure that the `page_context` contains valid paths and settings for the OCR engine to function correctly.\n\n### Python Docstring\n```python\ndef ocr_engine_hocr(input_file: Path, page_context: PageContext) -> tuple[Path, Path]:\n    \"\"\"\n    Processes an input file using an OCR engine to generate HTML Overlaid Character Recognition (HOCR)\n    output and plain text.\n\n    Parameters:\n    - input_file (Path): The path to the input PDF or image file.\n    - page_context (PageContext): A context object containing processing settings, options, and paths.\n\n    Returns:\n    tuple[Path, Path]: Paths to the generated HOCR and text files.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "misc/watcher.py", "func_name": "get_output_path", "whole_func_string": "def get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\n    assert '/' not in basename, \"basename must not contain '/'\"\n    if output_dir_year_month:\n        today = datetime.today()\n        output_directory_year_month = root / str(today.year) / f'{today.month:02d}'\n        if not output_directory_year_month.exists():\n            output_directory_year_month.mkdir(parents=True, exist_ok=True)\n        output_path = Path(output_directory_year_month) / Path(basename).with_suffix(\n            '.pdf'\n        )\n    else:\n        output_path = root / Path(basename).with_suffix('.pdf')\n    return output_path", "func_code_string": "def get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\n    assert '/' not in basename, \"basename must not contain '/'\"\n    if output_dir_year_month:\n        today = datetime.today()\n        output_directory_year_month = root / str(today.year) / f'{today.month:02d}'\n        if not output_directory_year_month.exists():\n            output_directory_year_month.mkdir(parents=True, exist_ok=True)\n        output_path = Path(output_directory_year_month) / Path(basename).with_suffix(\n            '.pdf'\n        )\n    else:\n        output_path = root / Path(basename).with_suffix('.pdf')\n    return output_path", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: misc/watcher.py\\nFunction/Class: get_output_path\\n```python\\ndef get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\\n    assert '/' not in basename, \\\"basename must not contain '/'\\\"\\n    if output_dir_year_month:\\n        today = datetime.today()\\n        output_directory_year_month = root / str(today.year) / f'{today.month:02d}'\\n        if not output_directory_year_month.exists():\\n            output_directory_year_month.mkdir(parents=True, exist_ok=True)\\n        output_path = Path(output_directory_year_month) / Path(basename).with_suffix(\\n            '.pdf'\\n        )\\n    else:\\n        output_path = root / Path(basename).with_suffix('.pdf')\\n    return output_path\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `get_output_path` function is designed to determine the appropriate file path for saving a PDF file. This function takes into account whether the output directory should be structured by year and month, and ensures that the output file has a `.pdf` extension.\n\n### Parameters\n- **root (Path)**: The root directory where the output file will be saved.\n- **basename (str)**: The base name of the file without any extension. It must not contain a forward slash (`/`).\n- **output_dir_year_month (bool)**: A boolean flag indicating whether to structure the output directory by year and month.\n\n### Behavior\n1. **Validation**: The function first checks if `basename` contains a forward slash. If it does, an assertion error is raised because the basename should not contain a path separator.\n2. **Directory Structure**:\n   - If `output_dir_year_month` is `True`, the function retrieves today's date and creates a directory structure within the root directory that includes the current year and month (e.g., `root/2023/10`). If this directory does not exist, it will be created.\n   - The output file path is then constructed by appending the basename with a `.pdf` extension to the appropriate directory.\n   - If `output_dir_year_month` is `False`, the function constructs the output path directly under the root directory with the basename and `.pdf` extension.\n3. **Return**: The function returns the complete Path object representing the output file path.\n\n### Edge Cases\n- **Invalid Basename**: If `basename` contains a forward slash, an assertion error will be raised.\n- **Non-Existent Directory**: If `output_dir_year_month` is `True` and the directory structure does not exist, it will be created with `parents=True` and `exist_ok=True`, ensuring that intermediate directories are also created if they do not exist.\n\n### Docstring\n```python\ndef get_output_path(root: Path, basename: str, output_dir_year_month: bool) -> Path:\n    \"\"\"\n    Determine the appropriate file path for saving a PDF file.\n\n    Parameters:\n    root (Path): The root directory where the output file will be saved.\n    basename (str): The base name of the file without any extension. Must not contain '/'.\n    output_dir_year_month (bool): Flag to indicate whether to structure the output directory by year and month.\n\n    Returns:\n    Path: The complete Path object representing the output file path.\n\n    Raises:\n    AssertionError: If 'basename' contains a forward slash.\n\n    Edge Cases:\n    - Invalid Basename: Raises an assertion error if 'basename' contains '/'.\n    - Non-Existent Directory: Creates the directory structure if it does not exist.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_badutf8.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return BadUtf8OcrEngine()", "func_code_string": "def get_ocr_engine():\n    return BadUtf8OcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_badutf8.py\\nFunction/Class: get_ocr_engine\\n```python\\ndef get_ocr_engine():\\n    return BadUtf8OcrEngine()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `get_ocr_engine` function is to provide an instance of the OCR (Optical Character Recognition) engine that handles bad UTF-8 encoding.\n\n### Analysis\n\n1. **Parameters**: The function does not take any parameters.\n2. **Behavior**: The function returns an instance of `BadUtf8OcrEngine`.\n3. **Edge Cases**:\n   - If `BadUtf8OcrEngine` is not defined or importable, the function will raise a `NameError`.\n   - If there are issues with creating an instance of `BadUtf8OcrEngine`, such as missing dependencies or invalid initialization parameters, these should be handled appropriately within `BadUtf8OcrEngine`.\n\n### Python Docstring\n\n```python\ndef get_ocr_engine():\n    \"\"\"\n    Returns an instance of the OCR engine designed to handle bad UTF-8 encoding.\n\n    :return: An instance of BadUtf8OcrEngine.\n    :rtype: BadUtf8OcrEngine\n    \"\"\"\n    return BadUtf8OcrEngine()\n```\n\nThis docstring clearly states the purpose, return type, and the behavior of the `get_ocr_engine` function."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "keyval_from_tuple", "whole_func_string": "def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v", "func_code_string": "def keyval_from_tuple(list_of_tuples):\n        for k, v, *_ in list_of_tuples:\n            yield k, v", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: keyval_from_tuple\\n```python\\ndef keyval_from_tuple(list_of_tuples):\\n        for k, v, *_ in list_of_tuples:\\n            yield k, v\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose**: The `keyval_from_tuple` function is designed to extract key-value pairs from a list of tuples. Each tuple in the input list should contain at least two elements: the first as the key and the second as the value. This function yields each key-value pair as it iterates through the list.\n\n**Parameter Analysis**:\n- `list_of_tuples`: A list where each element is expected to be a tuple. The function assumes that each tuple contains at least two elements, with the first element serving as the key and the second as the value.\n\n**Behavior**:\n- The function iterates over each tuple in the provided list.\n- For each tuple, it extracts the first element as the key (`k`) and the second element as the value (`v`).\n- It yields a tuple containing the key-value pair `(k, v)` for each iteration.\n- Any additional elements in the tuple beyond the second are ignored.\n\n**Edge Cases**:\n- If the input list is empty, the function will yield nothing (i.e., it will not produce any output).\n- If a tuple contains fewer than two elements, this behavior is undefined because the function assumes each tuple has at least two elements.\n- The function does not handle cases where the input list or tuples contain non-tuple types.\n\n**Python Docstring/Summary**:\n```python\ndef keyval_from_tuple(list_of_tuples):\n    \"\"\"\n    Extracts and yields key-value pairs from a list of tuples.\n\n    Parameters:\n    - list_of_tuples (list of tuple): A list where each element is expected to be a tuple with at least two elements.\n\n    Yields:\n    - tuple: Key-value pairs extracted from the input list.\n    \"\"\"\n    for k, v, *_ in list_of_tuples:\n        yield k, v\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_crash.py", "func_name": "raise_crash", "whole_func_string": "def raise_crash(*args, **kwargs):\n    raise CalledProcessError(\n        128 + signal.SIGABRT,\n        'tesseract',\n        output=b\"\",\n        stderr=b\"libc++abi.dylib: terminating with uncaught exception of type \"\n        + b\"std::bad_alloc: std::bad_alloc\",\n    )", "func_code_string": "def raise_crash(*args, **kwargs):\n    raise CalledProcessError(\n        128 + signal.SIGABRT,\n        'tesseract',\n        output=b\"\",\n        stderr=b\"libc++abi.dylib: terminating with uncaught exception of type \"\n        + b\"std::bad_alloc: std::bad_alloc\",\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_crash.py\\nFunction/Class: raise_crash\\n```python\\ndef raise_crash(*args, **kwargs):\\n    raise CalledProcessError(\\n        128 + signal.SIGABRT,\\n        'tesseract',\\n        output=b\\\"\\\",\\n        stderr=b\\\"libc++abi.dylib: terminating with uncaught exception of type \\\"\\n        + b\\\"std::bad_alloc: std::bad_alloc\\\",\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `raise_crash` function is to simulate a crash in the Tesseract OCR engine by raising a `CalledProcessError`. This error mimics the behavior that would occur if Tesseract were to abort due to memory allocation issues.\n\n### Detailed Analysis\n\n- **Parameters**:\n  - The function accepts any number of positional (`*args`) and keyword (`**kwargs`) arguments. These are intended for flexibility in calling the function with varying parameters, although they do not affect the core behavior of raising the error.\n\n- **Behavior**:\n  - The function raises a `CalledProcessError` to simulate a crash.\n  - The exit code is set to `128 + signal.SIGABRT`, which corresponds to an abort signal in Unix-like systems.\n  - The command used to trigger the error is set to `'tesseract'`.\n  - The `output` and `stderr` fields are both set to empty bytes, but the `stderr` field includes a simulated message indicating that a `std::bad_alloc` exception occurred.\n\n- **Edge Cases**:\n  - There are no specific edge cases for this function. It always raises an error with predefined values, making it deterministic in its behavior.\n  - However, if additional arguments are passed through `*args` and `**kwargs`, they are ignored by the function.\n\n### Python Docstring\n\n```python\ndef raise_crash(*args, **kwargs):\n    \"\"\"\n    Simulate a crash in Tesseract OCR by raising a CalledProcessError with specific error details.\n    \n    This function is intended for testing purposes to simulate an abort due to memory allocation issues.\n    \n    Parameters:\n        *args: Variable length argument list (ignored).\n        **kwargs: Arbitrary keyword arguments (ignored).\n        \n    Raises:\n        CalledProcessError: Always raises this exception with a simulated crash message.\n    \"\"\"\n    raise CalledProcessError(\n        128 + signal.SIGABRT,\n        'tesseract',\n        output=b\"\",\n        stderr=b\"libc++abi.dylib: terminating with uncaught exception of type std::bad_alloc: std::bad_alloc\",\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "__str__", "whole_func_string": "def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"", "func_code_string": "def __str__(self):\n        return f\"NO-OP {NoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_noop.py\\nFunction/Class: __str__\\n```python\\ndef __str__(self):\\n        return f\\\"NO-OP {NoopOcrEngine.version()}\\\"\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `__str__` function is designed to provide a human-readable string representation of the `NoopOcrEngine` object. This is particularly useful for debugging and logging purposes, as it allows developers to quickly understand the state or identity of an instance of `NoopOcrEngine`.\n\n### Parameters\n- **None**: The function does not accept any parameters.\n\n### Behavior\nWhen called on an instance of `NoopOcrEngine`, the `__str__` method returns a string formatted as `\"NO-OP {version}\"`. Here, `{version}` is replaced by the version number returned by the `version()` method of the `NoopOcrEngine` class.\n\n### Edge Cases\n- **Instance State**: The function assumes that an instance of `NoopOcrEngine` has a valid `version()` method that returns a string representing its version.\n- **Version Method Availability**: If the `version()` method is not available or does not return a string, the output will include `{version}` as-is.\n\n### Python Docstring\n```python\ndef __str__(self):\n    \"\"\"\n    Returns a human-readable string representation of the NoopOcrEngine instance.\n\n    :return: A string formatted as \"NO-OP {version}\", where {version} is the version number.\n    :rtype: str\n    \"\"\"\n    return f\"NO-OP {NoopOcrEngine.version()}\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "rasterize", "whole_func_string": "def rasterize(\n    input_file: Path,\n    page_context: PageContext,\n    correction: int = 0,\n    output_tag: str = '',\n    remove_vectors: bool | None = None,\n) -> Path:\n           \n    colorspaces = ['pngmono', 'pnggray', 'png256', 'png16m']\n    device_idx = 0\n\n    if remove_vectors is None:\n        remove_vectors = page_context.options.remove_vectors\n\n    output_file = page_context.get_path(f'rasterize{output_tag}.png')\n    pageinfo = page_context.pageinfo\n\n    def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))\n\n    for image in pageinfo.images:\n        if image.type_ != 'image':\n            continue                \n        if image.bpc > 1:\n            if image.color == Colorspace.index:\n                device_idx = at_least('png256')\n            elif image.color == Colorspace.gray:\n                device_idx = at_least('pnggray')\n            else:\n                device_idx = at_least('png16m')\n\n    if pageinfo.has_vector:\n        log.debug(\"Page has vector content, using png16m\")\n        device_idx = at_least('png16m')\n\n    device = colorspaces[device_idx]\n\n    log.debug(f\"Rasterize with {device}, rotation {correction}\")\n\n    canvas_dpi, page_dpi = calculate_raster_dpi(page_context)\n\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device=device,\n        raster_dpi=canvas_dpi,\n        page_dpi=page_dpi,\n        pageno=pageinfo.pageno + 1,\n        rotation=correction,\n        filter_vector=remove_vectors,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_code_string": "def rasterize(\n    input_file: Path,\n    page_context: PageContext,\n    correction: int = 0,\n    output_tag: str = '',\n    remove_vectors: bool | None = None,\n) -> Path:\n           \n    colorspaces = ['pngmono', 'pnggray', 'png256', 'png16m']\n    device_idx = 0\n\n    if remove_vectors is None:\n        remove_vectors = page_context.options.remove_vectors\n\n    output_file = page_context.get_path(f'rasterize{output_tag}.png')\n    pageinfo = page_context.pageinfo\n\n    def at_least(colorspace):\n        return max(device_idx, colorspaces.index(colorspace))\n\n    for image in pageinfo.images:\n        if image.type_ != 'image':\n            continue                \n        if image.bpc > 1:\n            if image.color == Colorspace.index:\n                device_idx = at_least('png256')\n            elif image.color == Colorspace.gray:\n                device_idx = at_least('pnggray')\n            else:\n                device_idx = at_least('png16m')\n\n    if pageinfo.has_vector:\n        log.debug(\"Page has vector content, using png16m\")\n        device_idx = at_least('png16m')\n\n    device = colorspaces[device_idx]\n\n    log.debug(f\"Rasterize with {device}, rotation {correction}\")\n\n    canvas_dpi, page_dpi = calculate_raster_dpi(page_context)\n\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device=device,\n        raster_dpi=canvas_dpi,\n        page_dpi=page_dpi,\n        pageno=pageinfo.pageno + 1,\n        rotation=correction,\n        filter_vector=remove_vectors,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: rasterize\\n```python\\ndef rasterize(\\n    input_file: Path,\\n    page_context: PageContext,\\n    correction: int = 0,\\n    output_tag: str = '',\\n    remove_vectors: bool | None = None,\\n) -> Path:\\n           \\n    colorspaces = ['pngmono', 'pnggray', 'png256', 'png16m']\\n    device_idx = 0\\n\\n    if remove_vectors is None:\\n        remove_vectors = page_context.options.remove_vectors\\n\\n    output_file = page_context.get_path(f'rasterize{output_tag}.png')\\n    pageinfo = page_context.pageinfo\\n\\n    def at_least(colorspace):\\n        return max(device_idx, colorspaces.index(colorspace))\\n\\n    for image in pageinfo.images:\\n        if image.type_ != 'image':\\n            continue                \\n        if image.bpc > 1:\\n            if image.color == Colorspace.index:\\n                device_idx = at_least('png256')\\n            elif image.color == Colorspace.gray:\\n                device_idx = at_least('pnggray')\\n            else:\\n                device_idx = at_least('png16m')\\n\\n    if pageinfo.has_vector:\\n        log.debug(\\\"Page has vector content, using png16m\\\")\\n        device_idx = at_least('png16m')\\n\\n    device = colorspaces[device_idx]\\n\\n    log.debug(f\\\"Rasterize with {device}, rotation {correction}\\\")\\n\\n    canvas_dpi, page_dpi = calculate_raster_dpi(page_context)\\n\\n    page_context.plugin_manager.hook.rasterize_pdf_page(\\n        input_file=input_file,\\n        output_file=output_file,\\n        raster_device=device,\\n        raster_dpi=canvas_dpi,\\n        page_dpi=page_dpi,\\n        pageno=pageinfo.pageno + 1,\\n        rotation=correction,\\n        filter_vector=remove_vectors,\\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\\n    )\\n    return output_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `rasterize` function in the `ocrmypdf/_pipeline.py` module is designed to convert PDF pages into rasterized images. This conversion allows for easier manipulation and processing of PDF content, particularly when OCR (Optical Character Recognition) is required.\n\n### Function/Class Documentation\n\n```python\ndef rasterize(\n    input_file: Path,\n    page_context: PageContext,\n    correction: int = 0,\n    output_tag: str = '',\n    remove_vectors: bool | None = None,\n) -> Path:\n    \"\"\"\n    Convert a PDF page to a rasterized image.\n\n    Parameters:\n    - input_file (Path): The path to the input PDF file.\n    - page_context (PageContext): The context of the current page, containing metadata and configuration options.\n    - correction (int, optional): The rotation angle for the output image. Default is 0.\n    - output_tag (str, optional): A tag to append to the output file name. Default is an empty string.\n    - remove_vectors (bool | None, optional): Whether to remove vector content from the image. If `None`, uses the value from `page_context.options.remove_vectors`. Default is `None`.\n\n    Returns:\n    - Path: The path to the rasterized image file.\n\n    Notes:\n    - The function selects an appropriate colorspace based on the page's color depth and presence of vector content.\n    - It logs the chosen device and rotation angle for debugging purposes.\n    - A custom plugin hook (`rasterize_pdf_page`) is invoked to perform the actual rasterization, passing relevant details such as DPI, rotation, and vector removal options.\n\n    Edge Cases:\n    - If `remove_vectors` is `None`, it defaults to the value from `page_context.options.remove_vectors`.\n    - The function handles different color depths (1-bit, 8-bit grayscale, 24-bit RGB) by selecting appropriate colorspaces.\n    - If a vector content is detected, it ensures that a high-color-depth colorspace ('png16m') is used for rasterization.\n    \"\"\"\n```\n\n### Detailed Explanation\n\n- **Parameters**:\n  - `input_file`: The path to the input PDF file being processed.\n  - `page_context`: Contains contextual information about the page, such as metadata and configuration options.\n  - `correction`: Optional rotation angle for the output image. Default is 0 (no rotation).\n  - `output_tag`: An optional tag appended to the output file name to distinguish between different outputs. Default is an empty string.\n  - `remove_vectors`: A boolean indicating whether vector content should be removed from the rasterized image. If `None`, it defaults to the value specified in `page_context.options.remove_vectors`.\n\n- **Behavior**:\n  - The function determines the appropriate colorspace for rasterization based on the page's color depth and presence of vector content.\n  - It logs debug information about the chosen device and rotation angle.\n  - A custom plugin hook (`rasterize_pdf_page`) is invoked to perform the actual rasterization, passing details such as DPI, rotation, and vector removal options.\n\n- **Edge Cases**:\n  - If `remove_vectors` is `None`, it defaults to the value from `page_context.options.remove_vectors`.\n  - The function handles different color depths (1-bit, 8-bit grayscale, 24-bit RGB) by selecting appropriate colorspaces.\n  - If vector content is detected, it ensures that a high-color-depth colorspace ('png16m') is used for rasterization.\n\n- **Returns**:\n  - The path to the rasterized image file."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "pdftype3font__pscript5_get_height", "whole_func_string": "def pdftype3font__pscript5_get_height(self):\n           \n    h = self.bbox[3] - self.bbox[1]\n    if h == 0:\n        h = self.ascent - self.descent\n    return h * copysign(1.0, self.vscale)", "func_code_string": "def pdftype3font__pscript5_get_height(self):\n           \n    h = self.bbox[3] - self.bbox[1]\n    if h == 0:\n        h = self.ascent - self.descent\n    return h * copysign(1.0, self.vscale)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/pdfinfo/layout.py\\nFunction/Class: pdftype3font__pscript5_get_height\\n```python\\ndef pdftype3font__pscript5_get_height(self):\\n           \\n    h = self.bbox[3] - self.bbox[1]\\n    if h == 0:\\n        h = self.ascent - self.descent\\n    return h * copysign(1.0, self.vscale)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose:**\nThe function `pdftype3font__pscript5_get_height` is designed to calculate the height of a Type 3 font in PostScript 5 format. This function ensures that the height is correctly computed based on either the bounding box or the ascent and descent values, adjusted by the vertical scale factor.\n\n**Parameter Analysis:**\n- **No Parameters:** The function does not take any external parameters. It relies solely on attributes of the class instance it belongs to (`self`).\n\n**Behavior:**\n1. The function calculates the height `h` using the difference between the upper and lower bounds of the bounding box (`self.bbox[3] - self.bbox[1]`). If this calculation results in zero, it falls back to using the difference between the ascent and descent values.\n2. The height is then multiplied by the sign of the vertical scale factor (`copysign(1.0, self.vscale)`) to ensure the correct direction (positive or negative).\n\n**Edge Cases:**\n- If `self.bbox[3] - self.bbox[1]` equals zero, the function uses the ascent and descent values instead, which might be more reliable in certain scenarios.\n- The use of `copysign` ensures that the height retains the correct sign based on the vertical scale factor.\n\n**Docstring/Summary:**\n```python\ndef pdftype3font__pscript5_get_height(self):\n    \"\"\"\n    Calculate the height of a Type 3 font in PostScript 5 format.\n    \n    Returns:\n        float: The height of the font, adjusted by the vertical scale factor.\n        \n    Notes:\n        - Falls back to using ascent and descent if bounding box height is zero.\n        - Adjusts the height based on the sign of the vertical scale factor.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "set_lossless_reconstruction", "whole_func_string": "def set_lossless_reconstruction(options: Namespace) -> None:\n    lossless_reconstruction = False\n    if not any(\n        (\n            options.deskew,\n            options.clean_final,\n            options.force_ocr,\n            options.remove_background,\n        )\n    ):\n        lossless_reconstruction = True\n    options.lossless_reconstruction = lossless_reconstruction\n\n    if not options.lossless_reconstruction and options.redo_ocr:\n        raise BadArgsError(\n            \"--redo-ocr is not currently compatible with --deskew, \"\n            \"--clean-final, and --remove-background\"\n        )", "func_code_string": "def set_lossless_reconstruction(options: Namespace) -> None:\n    lossless_reconstruction = False\n    if not any(\n        (\n            options.deskew,\n            options.clean_final,\n            options.force_ocr,\n            options.remove_background,\n        )\n    ):\n        lossless_reconstruction = True\n    options.lossless_reconstruction = lossless_reconstruction\n\n    if not options.lossless_reconstruction and options.redo_ocr:\n        raise BadArgsError(\n            \"--redo-ocr is not currently compatible with --deskew, \"\n            \"--clean-final, and --remove-background\"\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_validation.py\\nFunction/Class: set_lossless_reconstruction\\n```python\\ndef set_lossless_reconstruction(options: Namespace) -> None:\\n    lossless_reconstruction = False\\n    if not any(\\n        (\\n            options.deskew,\\n            options.clean_final,\\n            options.force_ocr,\\n            options.remove_background,\\n        )\\n    ):\\n        lossless_reconstruction = True\\n    options.lossless_reconstruction = lossless_reconstruction\\n\\n    if not options.lossless_reconstruction and options.redo_ocr:\\n        raise BadArgsError(\\n            \\\"--redo-ocr is not currently compatible with --deskew, \\\"\\n            \\\"--clean-final, and --remove-background\\\"\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `set_lossless_reconstruction` function determines whether to enable lossless reconstruction based on the provided command-line options. Lossless reconstruction is enabled if none of the specified options (`--deskew`, `--clean-final`, `--force-ocr`, `--remove-background`) are set. If lossless reconstruction is not enabled and the user requests redoing OCR (`--redo-ocr`), the function raises a `BadArgsError`.\n\n### Parameters\n\n- **options (Namespace)**: A namespace object containing various command-line options.\n\n### Behavior\n\n1. The function initializes `lossless_reconstruction` to `False`.\n2. It checks if any of the specified options (`--deskew`, `--clean-final`, `--force-ocr`, `--remove-background`) are set using the `any()` function.\n3. If none of these options are set, it sets `lossless_reconstruction` to `True`.\n4. The function then assigns this value to `options.lossless_reconstruction`.\n5. If lossless reconstruction is not enabled and the user requests redoing OCR (`--redo-ocr`), a `BadArgsError` is raised with an appropriate error message.\n\n### Edge Cases\n\n1. **No Options Set**: If none of the options are set, lossless reconstruction is enabled.\n2. **Options Set**: Lossless reconstruction is disabled if any of the specified options are set.\n3. **Redo OCR with Lossless Reconstruction Disabled**: If `--redo-ocr` is used without enabling lossless reconstruction, a `BadArgsError` is raised.\n\n### Docstring\n\n```python\ndef set_lossless_reconstruction(options: Namespace) -> None:\n    \"\"\"\n    Determine whether to enable lossless reconstruction based on the provided command-line options.\n    \n    Lossless reconstruction is enabled if none of the specified options (`--deskew`, `--clean-final`,\n    `--force-ocr`, `--remove-background`) are set. If lossless reconstruction is not enabled and the\n    user requests redoing OCR (`--redo-ocr`), a `BadArgsError` is raised.\n    \n    Parameters:\n    - options (Namespace): A namespace object containing various command-line options.\n    \n    Raises:\n    - BadArgsError: If `--redo-ocr` is used without enabling lossless reconstruction.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py", "func_name": "_exec_hocrtransform_sync", "whole_func_string": "def _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\n                            \n    hocr_json = page_context.get_path('hocr.json')\n    if not hocr_json.exists():\n                                                             \n        return HOCRResult(pageno=page_context.pageno)\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\n    hocr_result.textpdf = render_hocr_page(\n        page_context.get_path('ocr_hocr.hocr'), page_context\n    )\n    return hocr_result", "func_code_string": "def _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\n                            \n    hocr_json = page_context.get_path('hocr.json')\n    if not hocr_json.exists():\n                                                             \n        return HOCRResult(pageno=page_context.pageno)\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\n    hocr_result.textpdf = render_hocr_page(\n        page_context.get_path('ocr_hocr.hocr'), page_context\n    )\n    return hocr_result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/hocr_to_ocr_pdf.py\\nFunction/Class: _exec_hocrtransform_sync\\n```python\\ndef _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\\n                            \\n    hocr_json = page_context.get_path('hocr.json')\\n    if not hocr_json.exists():\\n                                                             \\n        return HOCRResult(pageno=page_context.pageno)\\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\\n    hocr_result.textpdf = render_hocr_page(\\n        page_context.get_path('ocr_hocr.hocr'), page_context\\n    )\\n    return hocr_result\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `_exec_hocrtransform_sync` function is to execute a synchronous transformation from HOCR (HTML-based OCR) data into an OCR PDF. This involves reading HOCR JSON and rendering it into a PDF format, which can then be used for further processing or display.\n\n### Parameters\n- `page_context`: An instance of `PageContext`, containing contextual information about the page being processed, including paths to input files like HOCR JSON and OCR HOCR files.\n\n### Behavior\n1. **Check for HOCR JSON Existence**: The function first checks if the HOCR JSON file exists at the specified path.\n2. **Return Empty Result if HOCR JSON Does Not Exist**: If the HOCR JSON file does not exist, it returns an empty `HOCRResult` object with the page number set to the value from the `page_context`.\n3. **Read and Parse HOCR JSON**: If the HOCR JSON file exists, it reads and parses this file into an `HOCRResult` object.\n4. **Render OCR PDF**: It then renders the parsed HOCR data into an OCR PDF using the `render_hocr_page` function, which takes the path to the OCR HOCR file and the `page_context` as arguments.\n5. **Return Updated HOCR Result**: Finally, it returns the updated `HOCRResult` object with the rendered OCR PDF.\n\n### Edge Cases\n- If the HOCR JSON file does not exist, the function will simply return an empty result without any errors or additional processing.\n- The `render_hocr_page` function should handle potential rendering errors gracefully and ensure that the OCR PDF is still returned even if some elements fail to render properly.\n\n### Python Docstring\n\n```python\ndef _exec_hocrtransform_sync(page_context: PageContext) -> HOCRResult:\n    \"\"\"\n    Executes a synchronous transformation from HOCR data into an OCR PDF.\n\n    Parameters:\n    - page_context (PageContext): An object containing contextual information about the current page, including paths to input files.\n\n    Returns:\n    - HOCRResult: A result object containing the rendered OCR PDF.\n    \n    Notes:\n    - If the HOCR JSON file does not exist at the specified path, an empty result is returned.\n    \"\"\"\n    hocr_json = page_context.get_path('hocr.json')\n    if not hocr_json.exists():\n        return HOCRResult(pageno=page_context.pageno)\n    hocr_result = HOCRResult.from_json(hocr_json.read_text())\n    hocr_result.textpdf = render_hocr_page(\n        page_context.get_path('ocr_hocr.hocr'), page_context\n    )\n    return hocr_result\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "dummy_run", "whole_func_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_code_string": "def dummy_run(args, *, env=None, **kwargs):\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_tesseract.py\\nFunction/Class: dummy_run\\n```python\\ndef dummy_run(args, *, env=None, **kwargs):\\n        raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `dummy_run` function is designed to simulate a call to the Tesseract OCR engine with an artificial error condition. This function is typically used in testing scenarios where it's necessary to test the behavior of a system when Tesseract encounters an issue, such as an image being too large.\n\n### Analysis of Parameters and Behavior\n\n- **Parameters**:\n  - `args`: A list or tuple representing the command-line arguments to be passed to Tesseract.\n  - `env` (optional): An environment dictionary that can override the default environment variables for the subprocess call. If not provided, the function will use the default environment.\n  - `**kwargs`: Additional keyword arguments that are passed to `subprocess.run`. These can include options like `capture_output`, `text`, etc.\n\n- **Behavior**:\n  - The function raises a `subprocess.CalledProcessError` with an exit code of `1`.\n  - The error message is set to `'tesseract'`.\n  - The `output` attribute of the exception is set to `b'Image too large'`, simulating an error condition related to image size.\n\n- **Edge Cases**:\n  - If `env` is provided, it will override any environment variables that might affect Tesseract's execution.\n  - Any additional keyword arguments (`kwargs`) can be used to customize the behavior of the subprocess call, such as capturing output or setting text mode.\n\n### Python Docstring\n\n```python\ndef dummy_run(args, *, env=None, **kwargs):\n    \"\"\"\n    Simulate a call to Tesseract OCR with an artificial error condition.\n\n    Parameters:\n        args (list or tuple): Command-line arguments to be passed to Tesseract.\n        env (dict, optional): Environment variables to override for the subprocess call. Defaults to None.\n        **kwargs: Additional keyword arguments to pass to `subprocess.run`.\n\n    Raises:\n        subprocess.CalledProcessError: Always raises this exception with an exit code of 1 and output 'Image too large'.\n    \"\"\"\n    raise subprocess.CalledProcessError(1, 'tesseract', output=b'Image too large')\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()", "func_code_string": "def __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],\n        builtins: bool = True,\n        **kwargs,\n    ):\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_plugin_manager.py\\nFunction/Class: __init__\\n```python\\ndef __init__(\\n        self,\\n        *args,\\n        plugins: Sequence[str | Path],\\n        builtins: bool = True,\\n        **kwargs,\\n    ):\\n        self.__init_args = args\\n        self.__init_kwargs = kwargs\\n        self.__plugins = plugins\\n        self.__builtins = builtins\\n        super().__init__(*args, **kwargs)\\n        self.setup_plugins()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level purpose**: The `__init__` method of the `_PluginManager` class is responsible for initializing an instance with a list of plugins, deciding whether to include built-in plugins, and setting up these plugins upon initialization.\n\n2. **Analysis**:\n   - **Parameters**:\n     - `*args`: Positional arguments that are passed along to the parent class constructor.\n     - `plugins`: A sequence of strings or `Path` objects representing the paths to the plugin modules or directories.\n     - `builtins`: A boolean indicating whether to include built-in plugins (default is `True`).\n     - `**kwargs`: Keyword arguments that are passed along to the parent class constructor.\n\n   - **Behavior**:\n     - The method initializes instance variables with the provided parameters (`__init_args`, `__init_kwargs`, `__plugins`, and `__builtins`).\n     - It then calls the superclass's `__init__` method using these parameters.\n     - Finally, it sets up the plugins by calling the `setup_plugins` method.\n\n   - **Edge Cases**:\n     - If no plugins are provided (`plugins=None`), the instance will be initialized without any external plugins.\n     - The inclusion of built-in plugins can be toggled off by setting `builtins=False`.\n\n3. **Docstring**:\n\n```python\ndef __init__(\n        self,\n        *args,\n        plugins: Sequence[str | Path],  # List of plugin modules or directories\n        builtins: bool = True,       # Whether to include built-in plugins\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize the PluginManager with a list of plugins and optionally include built-in plugins.\n\n        Args:\n            *args: Positional arguments passed to the superclass constructor.\n            plugins: A sequence of strings or Path objects representing the paths to the plugin modules or directories.\n            builtins: Boolean indicating whether to include built-in plugins (default is True).\n            **kwargs: Keyword arguments passed to the superclass constructor.\n\n        Raises:\n            ValueError: If `plugins` contains non-string, non-Path elements.\n        \"\"\"\n        self.__init_args = args\n        self.__init_kwargs = kwargs\n        self.__plugins = plugins\n        self.__builtins = builtins\n        super().__init__(*args, **kwargs)\n        self.setup_plugins()\n```\n\nThis docstring clearly outlines the purpose of the `__init__` method, its parameters, and any potential exceptions that can be raised."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tagged.py", "func_name": "test_force_tagged_warns", "whole_func_string": "def test_force_tagged_warns(resources, outpdf, caplog):\n    caplog.set_level('WARNING')\n    ocrmypdf.ocr(\n        resources / 'tagged.pdf',\n        outpdf,\n        force_ocr=True,\n        plugins=['tests/plugins/tesseract_noop.py'],\n    )\n    assert 'marked as a Tagged PDF' in caplog.text", "func_code_string": "def test_force_tagged_warns(resources, outpdf, caplog):\n    caplog.set_level('WARNING')\n    ocrmypdf.ocr(\n        resources / 'tagged.pdf',\n        outpdf,\n        force_ocr=True,\n        plugins=['tests/plugins/tesseract_noop.py'],\n    )\n    assert 'marked as a Tagged PDF' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_tagged.py\\nFunction/Class: test_force_tagged_warns\\n```python\\ndef test_force_tagged_warns(resources, outpdf, caplog):\\n    caplog.set_level('WARNING')\\n    ocrmypdf.ocr(\\n        resources / 'tagged.pdf',\\n        outpdf,\\n        force_ocr=True,\\n        plugins=['tests/plugins/tesseract_noop.py'],\\n    )\\n    assert 'marked as a Tagged PDF' in caplog.text\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The function `test_force_tagged_warns` is designed to test the behavior of the OCRmypdf library when forced to process a tagged PDF file, ensuring that it logs an appropriate warning message.\n\n2. **Parameter Analysis**:\n   - `resources`: A directory containing test resources, specifically including a tagged PDF file.\n   - `outpdf`: The output file path where the processed PDF will be saved.\n   - `caplog`: A fixture from pytest used to capture log messages for assertion purposes.\n\n3. **Behavior**:\n   - The function sets the logging level to 'WARNING'.\n   - It calls the OCRmypdf library's `ocr` function with the specified parameters, forcing OCR on a tagged PDF and using a custom plugin that does nothing (a no-op).\n   - It asserts that the log message containing the string \"marked as a Tagged PDF\" is present in the captured logs.\n\n4. **Edge Cases**:\n   - The function assumes that the `resources` directory contains a valid tagged PDF file named 'tagged.pdf'.\n   - The behavior of the OCRmypdf library with tagged PDFs might vary depending on its version and configuration.\n\n### Concise Python Docstring\n\n```python\ndef test_force_tagged_warns(resources, outpdf, caplog):\n    \"\"\"\n    Test that forcing OCR on a tagged PDF logs an appropriate warning message.\n\n    Parameters:\n    resources (pathlib.Path): Directory containing the test resources.\n    outpdf (pathlib.Path): Output file path for the processed PDF.\n    caplog (pytest.LogCaptureFixture): Fixture to capture log messages for assertion.\n\n    Asserts that the log contains a message indicating the PDF is marked as tagged.\n    \"\"\"\n    caplog.set_level('WARNING')\n    ocrmypdf.ocr(\n        resources / 'tagged.pdf',\n        outpdf,\n        force_ocr=True,\n        plugins=['tests/plugins/tesseract_noop.py'],\n    )\n    assert 'marked as a Tagged PDF' in caplog.text\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "TestDuplicateFilter", "whole_func_string": "class TestDuplicateFilter:\n    @pytest.fixture(scope='function')\n    def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger\n\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"\n\n    def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"\n\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_code_string": "class TestDuplicateFilter:\n    @pytest.fixture(scope='function')\n    def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger\n\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"\n\n    def test_filter_does_not_affect_unique_messages(\n        self, duplicate_filter_logger, caplog\n    ):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"\n\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_ghostscript.py\\nFunction/Class: TestDuplicateFilter\\n```python\\nclass TestDuplicateFilter:\\n    @pytest.fixture(scope='function')\\n    def duplicate_filter_logger(self):\\n                                                                                  \\n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\\n        logger.setLevel(logging.DEBUG)\\n        logger.addFilter(DuplicateFilter(logger))\\n        return logger\\n\\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\\n        log = duplicate_filter_logger\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"yet another error message\\\")\\n\\n        assert len(caplog.records) == 5\\n        assert caplog.records[0].msg == \\\"test error message\\\"\\n        assert caplog.records[1].msg == \\\"(suppressed 2 repeated lines)\\\"\\n        assert caplog.records[2].msg == \\\"another error message\\\"\\n        assert caplog.records[3].msg == \\\"(suppressed 1 repeated lines)\\\"\\n        assert caplog.records[4].msg == \\\"yet another error message\\\"\\n\\n    def test_filter_does_not_affect_unique_messages(\\n        self, duplicate_filter_logger, caplog\\n    ):\\n        log = duplicate_filter_logger\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"yet another error message\\\")\\n\\n        assert len(caplog.records) == 3\\n        assert caplog.records[0].msg == \\\"test error message\\\"\\n        assert caplog.records[1].msg == \\\"another error message\\\"\\n        assert caplog.records[2].msg == \\\"yet another error message\\\"\\n\\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\\n        log = duplicate_filter_logger\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"test error message\\\")\\n        log.error(\\\"another error message\\\")\\n        log.error(\\\"yet another error message\\\")\\n\\n        assert len(caplog.records) == 4\\n        assert caplog.records[0].msg == \\\"test error message\\\"\\n        assert caplog.records[1].msg == \\\"another error message\\\"\\n        assert caplog.records[2].msg == \\\"(suppressed 5 repeated lines)\\\"\\n        assert caplog.records[3].msg == \\\"yet another error message\\\"\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `TestDuplicateFilter` class is designed to test a logging filter that suppresses duplicate log messages. This ensures that only unique or different messages are logged, reducing clutter and noise in logs.\n\n### Parameters\n\n- None explicitly defined for this class or its methods.\n\n### Behavior\n\n1. **Fixture (`duplicate_filter_logger`)**: Sets up a logger with the `DuplicateFilter` applied. The filter suppresses duplicate log messages.\n2. **Methods**:\n   - `test_filter_duplicate_messages`: Tests that duplicate messages are suppressed and only unique messages are logged.\n   - `test_filter_does_not_affect_unique_messages`: Ensures that unique messages are not affected by the filter.\n   - `test_filter_alt_messages`: Further tests suppression behavior with varying numbers of repeated messages.\n\n### Edge Cases\n\n- The filter should handle a variety of message counts and repetition patterns.\n- Unique messages should always be logged.\n- Duplicate messages should only appear once, followed by a suppressed count if applicable.\n\n### Python Docstring or Summary\n\n```python\nclass TestDuplicateFilter:\n    \"\"\"\n    Tests the functionality of the DuplicateFilter class, ensuring that duplicate log messages are suppressed\n    and unique messages are logged without alteration.\n    \"\"\"\n\n    @pytest.fixture(scope='function')\n    def duplicate_filter_logger(self):\n        \"\"\"\n        Sets up a logger with the DuplicateFilter applied to suppress duplicate messages.\n        \"\"\"\n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger\n\n    def test_filter_duplicate_messages(self, duplicate_filter_logger, caplog):\n        \"\"\"\n        Verifies that repeated log messages are suppressed and only unique messages are logged.\n        \"\"\"\n        # Log some messages\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 5\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"(suppressed 2 repeated lines)\"\n        assert caplog.records[2].msg == \"another error message\"\n        assert caplog.records[3].msg == \"(suppressed 1 repeated lines)\"\n        assert caplog.records[4].msg == \"yet another error message\"\n\n    def test_filter_does_not_affect_unique_messages(self, duplicate_filter_logger, caplog):\n        \"\"\"\n        Ensures that unique log messages are not affected by the DuplicateFilter.\n        \"\"\"\n        # Log some messages\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 3\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"yet another error message\"\n\n    def test_filter_alt_messages(self, duplicate_filter_logger, caplog):\n        \"\"\"\n        Tests the suppression behavior with varying numbers of repeated messages.\n        \"\"\"\n        # Log some messages\n        log = duplicate_filter_logger\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"test error message\")\n        log.error(\"test error message\")\n        log.error(\"another error message\")\n        log.error(\"yet another error message\")\n\n        assert len(caplog.records) == 4\n        assert caplog.records[0].msg == \"test error message\"\n        assert caplog.records[1].msg == \"another error message\"\n        assert caplog.records[2].msg == \"(suppressed 5 repeated lines)\"\n        assert caplog.records[3].msg == \"yet another error message\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_form_xobject", "whole_func_string": "def test_form_xobject(resources):\n    filename = resources / 'formxobject.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.width == 50", "func_code_string": "def test_form_xobject(resources):\n    filename = resources / 'formxobject.pdf'\n\n    pdf = pdfinfo.PdfInfo(filename)\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.width == 50", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: test_form_xobject\\n```python\\ndef test_form_xobject(resources):\\n    filename = resources / 'formxobject.pdf'\\n\\n    pdf = pdfinfo.PdfInfo(filename)\\n    pdfimage = pdf[0].images[0]\\n    assert pdfimage.width == 50\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `test_form_xobject` function is to verify that the dimensions of a form XObject in a PDF file are correctly retrieved and asserted.\n\n#### Analysis of Parameters, Behavior, and Edge Cases\n\n1. **Parameters**:\n   - `resources`: A directory path object containing test resources.\n\n2. **Behavior**:\n   - The function loads a PDF file named 'formxobject.pdf' from the provided `resources` directory.\n   - It creates an instance of `pdfinfo.PdfInfo` with the loaded PDF file.\n   - Accesses the first page of the PDF and then retrieves the first image on that page.\n   - Asserts that the width of this image is equal to 50.\n\n3. **Edge Cases**:\n   - The function does not handle cases where the PDF file might be missing or incorrectly formatted.\n   - It assumes that the first page of the PDF will always have an image, which could lead to an `IndexError` if no images are present.\n\n#### Python Docstring\n\n```python\ndef test_form_xobject(resources):\n    \"\"\"\n    Test the retrieval and assertion of form XObject dimensions from a PDF file.\n\n    Parameters:\n    resources (pathlib.Path): Directory containing test resources including 'formxobject.pdf'.\n\n    Raises:\n    AssertionError: If the width of the first image on the first page is not 50.\n    FileNotFoundError: If 'formxobject.pdf' does not exist in the provided resources directory.\n    IndexError: If there are no images on the first page of the PDF.\n\n    Returns:\n    None\n    \"\"\"\n    filename = resources / 'formxobject.pdf'\n    \n    pdf = pdfinfo.PdfInfo(filename)\n    pdfimage = pdf[0].images[0]\n    assert pdfimage.width == 50\n```\n\nThis docstring provides a clear description of the function's purpose, parameters, exceptions that can be raised, and what it returns."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_bookmarks_preserved", "whole_func_string": "def test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\n    fitz = pytest.importorskip('fitz')\n    input_file = resources / 'toc.pdf'\n    before_toc = fitz.Document(str(input_file)).get_toc()\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        ocr_option,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after_toc = fitz.Document(str(outpdf)).get_toc()\n    print(before_toc)\n    print(after_toc)\n    assert before_toc == after_toc", "func_code_string": "def test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\n    fitz = pytest.importorskip('fitz')\n    input_file = resources / 'toc.pdf'\n    before_toc = fitz.Document(str(input_file)).get_toc()\n\n    check_ocrmypdf(\n        input_file,\n        outpdf,\n        ocr_option,\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    after_toc = fitz.Document(str(outpdf)).get_toc()\n    print(before_toc)\n    print(after_toc)\n    assert before_toc == after_toc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_bookmarks_preserved\\n```python\\ndef test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\\n    fitz = pytest.importorskip('fitz')\\n    input_file = resources / 'toc.pdf'\\n    before_toc = fitz.Document(str(input_file)).get_toc()\\n\\n    check_ocrmypdf(\\n        input_file,\\n        outpdf,\\n        ocr_option,\\n        '--output-type',\\n        output_type,\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n\\n    after_toc = fitz.Document(str(outpdf)).get_toc()\\n    print(before_toc)\\n    print(after_toc)\\n    assert before_toc == after_toc\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function:**\nThe function `test_bookmarks_preserved` is designed to test whether bookmarks are preserved during the OCR process using the `ocrmypdf` tool. It ensures that the table of contents (TOC) in a PDF document remains intact after the OCR operation.\n\n**Analysis of parameters and behavior:**\n- **Parameters:**\n  - `output_type`: A string specifying the output type for the OCR processed PDF.\n  - `ocr_option`: A string representing additional options to be passed to the OCR tool.\n  - `resources`: A pathlib Path object pointing to the directory containing test resources.\n  - `outpdf`: A string or pathlib Path object indicating the path where the OCR processed PDF should be saved.\n\n- **Behavior:**\n  - The function imports the `fitz` library using `pytest.importorskip`, which is used for handling PDF documents.\n  - It reads the input PDF file (`toc.pdf`) and retrieves its table of contents before any OCR processing.\n  - It then calls a helper function `check_ocrmypdf` to perform the OCR operation with specified options, including a no-operation plugin that does not modify text but can still handle bookmarks.\n  - After OCR processing, it reads the TOC again from the output PDF and asserts that the TOC remains unchanged.\n\n**Edge cases:**\n- If the OCR process fails or encounters an error, the test will fail due to the assertion at the end of the function.\n- If there are any issues with importing `fitz` (e.g., it's not installed), the function will skip the tests using `pytest.importorskip`.\n\n**Concise Python docstring:**\n```python\ndef test_bookmarks_preserved(output_type, ocr_option, resources, outpdf):\n    \"\"\"\n    Test to ensure bookmarks are preserved during OCR processing.\n\n    Parameters:\n    output_type (str): The output type for the OCR processed PDF.\n    ocr_option (str): Additional options to be passed to the OCR tool.\n    resources (pathlib.Path): Path to the directory containing test resources.\n    outpdf (str/Path): Path where the OCR processed PDF should be saved.\n\n    Raises:\n    AssertionError: If the bookmarks are not preserved after OCR processing.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_outputtype_none_bad_setup", "whole_func_string": "def test_outputtype_none_bad_setup(resources, outpdf):\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--output-type=none',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == ExitCode.bad_args\n    assert 'Set the output file to' in p.stderr", "func_code_string": "def test_outputtype_none_bad_setup(resources, outpdf):\n    p = run_ocrmypdf(\n        resources / 'trivial.pdf',\n        outpdf,\n        '--output-type=none',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n    assert p.returncode == ExitCode.bad_args\n    assert 'Set the output file to' in p.stderr", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_outputtype_none_bad_setup\\n```python\\ndef test_outputtype_none_bad_setup(resources, outpdf):\\n    p = run_ocrmypdf(\\n        resources / 'trivial.pdf',\\n        outpdf,\\n        '--output-type=none',\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n    assert p.returncode == ExitCode.bad_args\\n    assert 'Set the output file to' in p.stderr\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `test_outputtype_none_bad_setup` function is designed to test the behavior of OCRmyPDF when a bad setup occurs due to an invalid or unsupported `--output-type=none` option. This ensures that the application handles such errors gracefully by returning a specific exit code and displaying an appropriate error message.\n\n### Parameters\n\n- **resources** (Path): A path object representing the directory containing the input PDF files for testing.\n- **outpdf** (Path): A path object representing the output file where the OCR'd PDF will be saved, but in this case, it's expected to fail because of the `--output-type=none` option.\n\n### Behavior\n\n1. The function calls `run_ocrmypdf` with a specific set of arguments:\n   - Input file: A trivial PDF located at `resources / 'trivial.pdf'`.\n   - Output file: Specified by the `outpdf` parameter, but this path is not used due to the `--output-type=none` option.\n   - OCRmyPDF options: `--output-type=none` and a custom plugin (`tests/plugins/tesseract_noop.py`) that does nothing.\n\n2. The function asserts that the return code of the `run_ocrmypdf` process is equal to `ExitCode.bad_args`, indicating that an invalid or unsupported argument was provided.\n\n3. The function also checks that the standard error output (`p.stderr`) contains the expected message \"Set the output file to\", which is a clear indication that the application recognized the invalid `--output-type=none` option and provided a relevant error message.\n\n### Edge Cases\n\n- **No Output File Specified**: Since the `--output-type=none` option is used, there should be no need for an output file. However, providing a path for `outpdf` still triggers the error, as the application checks for the presence of this parameter and its compatibility with the specified options.\n- **Custom Plugin**: The use of a custom plugin that does nothing (`tests/plugins/tesseract_noop.py`) ensures that any actual OCR processing is bypassed, focusing solely on validating the command-line options.\n\n### Summary\n\nThe `test_outputtype_none_bad_setup` function tests the error handling in OCRmyPDF when an invalid or unsupported `--output-type=none` option is provided. It verifies that the application returns the correct exit code and outputs an appropriate error message, ensuring robust error reporting for users."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_pillow_options", "whole_func_string": "def test_pillow_options():\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))", "func_code_string": "def test_pillow_options():\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_pillow_options\\n```python\\ndef test_pillow_options():\\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `test_pillow_options` function is designed to validate the options for the Pillow library, specifically focusing on image processing settings. It ensures that the maximum image megapixels (`max_image_mpixels`) is set correctly and that any invalid configurations are handled appropriately.\n\n### Parameters\n- None\n\n### Behavior\n1. The function calls `vd.check_options_pillow` with a dictionary containing options for the Pillow library.\n2. The `make_opts` function is used to generate the options dictionary, where `max_image_mpixels` is set to 0.\n\n### Edge Cases\n- The function assumes that setting `max_image_mpixels` to 0 will result in an error or exception due to invalid configuration.\n\n### Docstring/Summary\n```python\ndef test_pillow_options():\n    \"\"\"\n    Validates the options for the Pillow library by checking if setting max_image_mpixels to 0 raises an exception.\n    \n    This function assumes that any value other than a positive integer for `max_image_mpixels` should result in an error.\n    \"\"\"\n    vd.check_options_pillow(make_opts(max_image_mpixels=0))\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "TesseractConfigError", "whole_func_string": "class TesseractConfigError(ExitCodeException):\n                                           \n\n    exit_code = ExitCode.invalid_config\n    message = \"Error occurred while parsing a Tesseract configuration file\"", "func_code_string": "class TesseractConfigError(ExitCodeException):\n                                           \n\n    exit_code = ExitCode.invalid_config\n    message = \"Error occurred while parsing a Tesseract configuration file\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/exceptions.py\\nFunction/Class: TesseractConfigError\\n```python\\nclass TesseractConfigError(ExitCodeException):\\n                                           \\n\\n    exit_code = ExitCode.invalid_config\\n    message = \\\"Error occurred while parsing a Tesseract configuration file\\\"\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function/class:**  \nThe `TesseractConfigError` class is designed to handle errors related to the configuration of the Tesseract OCR engine. This error is specifically raised when there is an issue with parsing a configuration file used by Tesseract.\n\n**Analysis of parameters, behavior, and edge cases:**\n- **Parameters:** None\n  - The `TesseractConfigError` does not accept any parameters beyond those inherited from its base class.\n  \n- **Behavior:**  \n  - It inherits from the `ExitCodeException`, which is likely a custom exception class designed to handle exit codes in a specific way.\n  - It sets two attributes:\n    - `exit_code`: This attribute is assigned the value of `ExitCode.invalid_config`, indicating that the error occurred due to an invalid configuration file.\n    - `message`: This attribute is set to \"Error occurred while parsing a Tesseract configuration file\", providing a clear and specific error message.\n\n- **Edge cases:**  \n  - There are no parameters, so there are no edge cases related to input values. The main edge case is ensuring that the `ExitCode` enum has an appropriate value (`invalid_config`) for this type of error.\n  - The behavior should be robust in handling any errors related to Tesseract configuration parsing without causing a program crash.\n\n**Concise Python docstring or summary:**\n```python\nclass TesseractConfigError(ExitCodeException):\n    \"\"\"\n    Exception raised when there is an issue with parsing a Tesseract configuration file.\n\n    Attributes:\n        exit_code (int): The specific error code indicating the type of invalid configuration.\n        message (str): A clear and concise description of the error.\n    \"\"\"\n    exit_code = ExitCode.invalid_config\n    message = \"Error occurred while parsing a Tesseract configuration file\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_metadata.py", "func_name": "from_document_info", "whole_func_string": "def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''", "func_code_string": "def from_document_info(key):\n        try:\n            s = base_pdf.docinfo[key]\n            return str(s)\n        except (KeyError, TypeError):\n            return ''", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_metadata.py\\nFunction/Class: from_document_info\\n```python\\ndef from_document_info(key):\\n        try:\\n            s = base_pdf.docinfo[key]\\n            return str(s)\\n        except (KeyError, TypeError):\\n            return ''\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**Purpose:** The `from_document_info` function is designed to extract metadata from a PDF document's information dictionary. It takes a key as input and attempts to retrieve the corresponding value, converting it to a string if successful. If the key does not exist or an error occurs during retrieval, it returns an empty string.\n\n### Parameters\n- **key (str):** The key for which the metadata value is sought within the PDF document's information dictionary (`base_pdf.docinfo`).\n\n### Behavior\n1. It tries to access the value associated with the given `key` in the `base_pdf.docinfo` dictionary.\n2. If the key exists, it converts the retrieved value to a string and returns it.\n3. If the key does not exist or an exception occurs (e.g., due to a `KeyError` or `TypeError`), it catches these exceptions and returns an empty string.\n\n### Edge Cases\n- The function handles cases where the specified key is not present in the document's metadata dictionary by returning an empty string.\n- It gracefully handles type errors that might occur during the retrieval process, such as if the value associated with the key is not a string but another data type.\n\n### Summary\n```python\ndef from_document_info(key: str) -> str:\n    \"\"\"Retrieve and return the metadata value for a given key in a PDF document's info dictionary.\n    \n    Args:\n        key (str): The key whose corresponding metadata value is to be retrieved.\n        \n    Returns:\n        str: The string representation of the metadata value if found; otherwise, an empty string.\n    \n    Handles cases where the key does not exist or an error occurs during retrieval by returning an empty string.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/tesseract.py", "func_name": "TesseractVersion", "whole_func_string": "class TesseractVersion(Version):\n                                                                                      \n\n    _regex = re.compile(\n        r\"^\\s*\" + TESSERACT_VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE\n    )", "func_code_string": "class TesseractVersion(Version):\n                                                                                      \n\n    _regex = re.compile(\n        r\"^\\s*\" + TESSERACT_VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/tesseract.py\\nFunction/Class: TesseractVersion\\n```python\\nclass TesseractVersion(Version):\\n                                                                                      \\n\\n    _regex = re.compile(\\n        r\\\"^\\\\s*\\\" + TESSERACT_VERSION_PATTERN + r\\\"\\\\s*$\\\", re.VERBOSE | re.IGNORECASE\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `TesseractVersion` class is designed to extract and represent the version number of Tesseract OCR from a given string. This class inherits from a base `Version` class, indicating that it likely extends functionality related to version parsing or handling.\n\n### Parameters, Behavior, and Edge Cases\n\n- **Parameters**:\n  - The `_regex` attribute is a regular expression compiled with specific flags (`re.VERBOSE | re.IGNORECASE`). It uses the `TESSERACT_VERSION_PATTERN`, which suggests that this pattern matches Tesseract OCR version numbers.\n\n- **Behavior**:\n  - The class uses a regular expression to parse and extract version information from a string.\n  - The `_regex` pattern is designed to match strings that contain a version number in the format expected by Tesseract OCR, ignoring leading and trailing whitespace and case sensitivity.\n\n- **Edge Cases**:\n  - If the input string does not match the `_regex` pattern, the regular expression will not capture any groups, and further processing may result in `None`.\n  - The use of `re.VERBOSE` allows for more readable regex patterns by allowing comments and whitespace within the pattern, which is useful for maintaining complex patterns.\n  - The `re.IGNORECASE` flag ensures that the version number is matched without being case-sensitive, accommodating variations in how version numbers might be formatted.\n\n### Python Docstring or Summary\n\n```python\nclass TesseractVersion(Version):\n    \"\"\"\n    Extracts and represents the version number of Tesseract OCR from a given string.\n\n    Attributes:\n        _regex (re.Pattern): Regular expression pattern for matching Tesseract version numbers.\n\n    Notes:\n        - The regex is designed to handle leading/trailing whitespace and case-insensitivity.\n        - If the input string does not match the regex, no version information will be captured.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/quality.py", "func_name": "measure_words_matched", "whole_func_string": "def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_code_string": "def measure_words_matched(self, ocr_text: str) -> float:\n                   \n        text = re.sub(r\"[0-9_]+\", ' ', ocr_text)\n        text = re.sub(r'\\W+', ' ', text)\n        text_words_list = re.split(r'\\s+', text)\n        text_words = {w for w in text_words_list if len(w) >= 3}\n\n        matches = 0\n        for w in text_words:\n            if w in self.dictionary or (\n                w != w.lower() and w.lower() in self.dictionary\n            ):\n                matches += 1\n        if matches > 0:\n            hit_ratio = matches / len(text_words)\n        else:\n            hit_ratio = 0.0\n        return hit_ratio", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/quality.py\\nFunction/Class: measure_words_matched\\n```python\\ndef measure_words_matched(self, ocr_text: str) -> float:\\n                   \\n        text = re.sub(r\\\"[0-9_]+\\\", ' ', ocr_text)\\n        text = re.sub(r'\\\\W+', ' ', text)\\n        text_words_list = re.split(r'\\\\s+', text)\\n        text_words = {w for w in text_words_list if len(w) >= 3}\\n\\n        matches = 0\\n        for w in text_words:\\n            if w in self.dictionary or (\\n                w != w.lower() and w.lower() in self.dictionary\\n            ):\\n                matches += 1\\n        if matches > 0:\\n            hit_ratio = matches / len(text_words)\\n        else:\\n            hit_ratio = 0.0\\n        return hit_ratio\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `measure_words_matched` function is designed to evaluate the quality of OCR (Optical Character Recognition) output by measuring how many words in the OCR text match a predefined dictionary.\n\n1. **High-level purpose**: The function takes an OCR-generated text and compares it against a dictionary to determine the percentage of words that are recognized correctly.\n2. **Parameters**:\n   - `ocr_text` (str): The OCR-generated text to be evaluated.\n3. **Behavior**:\n   - The function preprocesses the OCR text by removing digits, non-word characters, and splitting the text into individual words.\n   - It filters out short words that are less than 3 characters long.\n   - It checks each word against a dictionary (either directly or as a lowercase version) to count how many words match.\n   - The function calculates the hit ratio by dividing the number of matches by the total number of words in the text and returns this value.\n4. **Edge Cases**:\n   - If there are no words in the OCR text, the function returns 0.0.\n   - Words with mixed case (e.g., \"Word\") can match as either lowercase or uppercase versions.\n\n### Python Docstring\n\n```python\ndef measure_words_matched(self, ocr_text: str) -> float:\n    \"\"\"\n    Measures the quality of OCR output by calculating the percentage of words that match a predefined dictionary.\n\n    Parameters:\n    ocr_text (str): The OCR-generated text to be evaluated.\n\n    Returns:\n    float: The hit ratio representing the percentage of correctly recognized words.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "unique_everseen", "whole_func_string": "def unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\n                                                 \n                                                    \n                                                       \n    seen: set[Tkey] = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k not in seen:\n            seen_add(k)\n            yield element", "func_code_string": "def unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\n                                                 \n                                                    \n                                                       \n    seen: set[Tkey] = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k not in seen:\n            seen_add(k)\n            yield element", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/subprocess/_windows.py\\nFunction/Class: unique_everseen\\n```python\\ndef unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\\n                                                 \\n                                                    \\n                                                       \\n    seen: set[Tkey] = set()\\n    seen_add = seen.add\\n    for element in iterable:\\n        k = key(element)\\n        if k not in seen:\\n            seen_add(k)\\n            yield element\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `unique_everseen` is designed to filter an iterable, returning only the first occurrence of each unique key produced by a given key function. This can be particularly useful when you need to ensure that all elements in a sequence are unique according to some criterion, such as their hash value or a specific attribute.\n\n### Parameters\n- `iterable`: The input iterable from which unique elements will be yielded.\n- `key`: A callable that takes an element of the iterable and returns a key by which uniqueness is determined. If not provided, the identity function is used (i.e., each element itself is considered as the key).\n\n### Behavior\nThe function iterates over the input `iterable` and uses a set called `seen` to track keys that have already been encountered. For each element in the iterable, it computes the key using the provided `key` function. If this key has not been seen before, the element is added to the `seen` set and yielded.\n\n### Edge Cases\n1. **Empty Iterable**: If the input iterable is empty, the function will also return an empty iterator.\n2. **Duplicate Keys**: Multiple elements in the iterable can have the same key, but only the first occurrence of each key will be yielded.\n3. **Key Function**: If a custom `key` function is provided, it must be able to handle every element in the iterable without causing errors.\n\n### Python Docstring\n```python\ndef unique_everseen(iterable: Iterable[T], key: Callable[[T], Tkey]) -> Iterator[T]:\n    \"\"\"\n    Yields elements from the given iterable in order, skipping duplicates based on the provided key function.\n    \n    Parameters:\n    - iterable: The iterable to process.\n    - key: A callable that takes an element and returns a key for uniqueness comparison. Defaults to identity.\n    \n    Returns:\n    An iterator yielding only the first occurrence of each unique key in the input iterable.\n    \n    Examples:\n    >>> list(unique_everseen(['a', 'B', 'c', 'b']))\n    ['a', 'B', 'c']\n    >>> list(unique_everseen([1, 2, 3, 2], key=lambda x: x % 2))\n    [1, 2]\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_single_page_image", "whole_func_string": "def test_single_page_image(eight_by_eight_regular_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert not page.has_text\n    assert len(page.images) == 1\n\n    pdfimage = page.images[0]\n    assert pdfimage.width == 8\n    assert pdfimage.color == Colorspace.gray\n\n                                       \n    assert isclose(pdfimage.dpi.x, 8)\n    assert isclose(pdfimage.dpi.y, 8)", "func_code_string": "def test_single_page_image(eight_by_eight_regular_image):\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\n\n    assert len(info) == 1\n    page = info[0]\n\n    assert not page.has_text\n    assert len(page.images) == 1\n\n    pdfimage = page.images[0]\n    assert pdfimage.width == 8\n    assert pdfimage.color == Colorspace.gray\n\n                                       \n    assert isclose(pdfimage.dpi.x, 8)\n    assert isclose(pdfimage.dpi.y, 8)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: test_single_page_image\\n```python\\ndef test_single_page_image(eight_by_eight_regular_image):\\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\\n\\n    assert len(info) == 1\\n    page = info[0]\\n\\n    assert not page.has_text\\n    assert len(page.images) == 1\\n\\n    pdfimage = page.images[0]\\n    assert pdfimage.width == 8\\n    assert pdfimage.color == Colorspace.gray\\n\\n                                       \\n    assert isclose(pdfimage.dpi.x, 8)\\n    assert isclose(pdfimage.dpi.y, 8)\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `test_single_page_image` function tests the extraction of information from a PDF document that contains a single page with an image. Specifically, it verifies that the image's properties are correctly identified and extracted.\n\n### Parameters and Behavior\n\n- **Parameters**:\n  - `eight_by_eight_regular_image`: A fixture providing a PDF file containing a single page with a regular (non-compressed) image of size 8x8 pixels in grayscale.\n\n- **Behavior**:\n  - The function creates an instance of `PdfInfo` using the provided PDF file.\n  - It asserts that the PDF contains exactly one page.\n  - For this single page, it checks that there is no text content and that there is exactly one image present.\n  - It then validates several properties of the extracted image:\n    - The width of the image is 8 pixels.\n    - The colorspace of the image is grayscale.\n    - The DPI (dots per inch) in both x and y directions is approximately 8.\n\n### Edge Cases\n\n- The function assumes that the PDF contains exactly one page with a single image. If the PDF has more than one page or no images, the assertions will fail.\n- The function relies on the `isclose` function from Python's `math` module to compare floating-point numbers representing DPI values, allowing for minor differences due to potential precision issues.\n\n### Summary\n\n```python\ndef test_single_page_image(eight_by_eight_regular_image):\n    \"\"\"\n    Tests extracting information from a PDF with a single page containing a regular image.\n    \n    This function asserts:\n    - The PDF contains exactly one page.\n    - There is no text on the page.\n    - The page contains exactly one image.\n    - The image has a width of 8 pixels, a grayscale colorspace, and an approximate DPI of 8x8.\n    \"\"\"\n    info = pdfinfo.PdfInfo(eight_by_eight_regular_image)\n    \n    assert len(info) == 1\n    page = info[0]\n    \n    assert not page.has_text\n    assert len(page.images) == 1\n    \n    pdfimage = page.images[0]\n    assert pdfimage.width == 8\n    assert pdfimage.color == Colorspace.gray\n    \n    assert isclose(pdfimage.dpi.x, 8)\n    assert isclose(pdfimage.dpi.y, 8)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_args_invalid_filename", "whole_func_string": "def test_unpaper_args_invalid_filename(resources, outpdf, caplog):\n    with pytest.raises(BadArgsError):\n        run_ocrmypdf_api(\n            resources / \"skew.pdf\",\n            outpdf,\n            \"-c\",\n            \"--unpaper-args\",\n            \"/etc/passwd\",\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_code_string": "def test_unpaper_args_invalid_filename(resources, outpdf, caplog):\n    with pytest.raises(BadArgsError):\n        run_ocrmypdf_api(\n            resources / \"skew.pdf\",\n            outpdf,\n            \"-c\",\n            \"--unpaper-args\",\n            \"/etc/passwd\",\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_unpaper.py\\nFunction/Class: test_unpaper_args_invalid_filename\\n```python\\ndef test_unpaper_args_invalid_filename(resources, outpdf, caplog):\\n    with pytest.raises(BadArgsError):\\n        run_ocrmypdf_api(\\n            resources / \\\"skew.pdf\\\",\\n            outpdf,\\n            \\\"-c\\\",\\n            \\\"--unpaper-args\\\",\\n            \\\"/etc/passwd\\\",\\n            '--plugin',\\n            'tests/plugins/tesseract_noop.py',\\n        )\\n```\", \"assistant\": \"\"}", "response": "### High-level Purpose of the Function\n\nThe `test_unpaper_args_invalid_filename` function is designed to test the behavior of an OCRmypdf API when provided with invalid arguments for unpaper. Specifically, it checks that the API raises a `BadArgsError` when an invalid filename is passed as part of the `--unpaper-args` parameter.\n\n### Analysis of Parameters\n\n1. **resources**: A fixture or object providing access to test resources.\n2. **outpdf**: A fixture or object representing the output PDF file path.\n3. **caplog**: A fixture from the `pytest` library used for capturing log messages.\n\n### Behavior and Edge Cases\n\nThe function invokes the `run_ocrmypdf_api` function with a set of arguments, including an invalid filename (`\"/etc/passwd\"`) passed as part of the `--unpaper-args`. The expectation is that this will trigger a `BadArgsError` because `/etc/passwd` is not a valid unpaper configuration file.\n\n### Python Docstring\n\n```python\ndef test_unpaper_args_invalid_filename(resources, outpdf, caplog):\n    \"\"\"\n    Test that running OCRmypdf with an invalid filename in --unpaper-args raises BadArgsError.\n    \n    Parameters:\n    resources (fixture): Provides access to test resources.\n    outpdf (fixture): Represents the output PDF file path.\n    caplog (fixture): Captures log messages for testing purposes.\n\n    Raises:\n    AssertionError: If the expected BadArgsError is not raised.\n    \"\"\"\n    with pytest.raises(BadArgsError):\n        run_ocrmypdf_api(\n            resources / \"skew.pdf\",\n            outpdf,\n            \"-c\",\n            \"--unpaper-args\",\n            \"/etc/passwd\",\n            '--plugin',\n            'tests/plugins/tesseract_noop.py',\n        )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_tesseract_not_installed", "whole_func_string": "def test_tesseract_not_installed(caplog):\n    with patch('ocrmypdf.subprocess.run') as not_found:\n        not_found.side_effect = FileNotFoundError('tesseract')\n        with pytest.raises(MissingDependencyError, match=\"Could not find program\"):\n            vd.check_options(*make_opts_pm())\n            assert (\n                \"'tesseract' could not be executed\" in caplog.text\n            ), \"Error message not printed\"\n            assert 'install' in caplog.text, \"Install advice not printed\"\n        not_found.assert_called()", "func_code_string": "def test_tesseract_not_installed(caplog):\n    with patch('ocrmypdf.subprocess.run') as not_found:\n        not_found.side_effect = FileNotFoundError('tesseract')\n        with pytest.raises(MissingDependencyError, match=\"Could not find program\"):\n            vd.check_options(*make_opts_pm())\n            assert (\n                \"'tesseract' could not be executed\" in caplog.text\n            ), \"Error message not printed\"\n            assert 'install' in caplog.text, \"Install advice not printed\"\n        not_found.assert_called()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_tesseract_not_installed\\n```python\\ndef test_tesseract_not_installed(caplog):\\n    with patch('ocrmypdf.subprocess.run') as not_found:\\n        not_found.side_effect = FileNotFoundError('tesseract')\\n        with pytest.raises(MissingDependencyError, match=\\\"Could not find program\\\"):\\n            vd.check_options(*make_opts_pm())\\n            assert (\\n                \\\"'tesseract' could not be executed\\\" in caplog.text\\n            ), \\\"Error message not printed\\\"\\n            assert 'install' in caplog.text, \\\"Install advice not printed\\\"\\n        not_found.assert_called()\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\nThe function `test_tesseract_not_installed` is designed to test the behavior of a validation function (`vd.check_options`) when Tesseract OCR software is not installed on the system. It ensures that appropriate error messages and advice are logged.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n1. **Parameters**:\n   - `caplog`: A fixture provided by `pytest` to capture log messages during test execution.\n\n2. **Behavior**:\n   - The function uses a mock (`patch`) to simulate the absence of Tesseract OCR software.\n   - It calls the validation function (`vd.check_options`) with options generated by `make_opts_pm()`.\n   - The function asserts that the expected error message (\"'tesseract' could not be executed\") is logged.\n   - It also verifies that advice to install Tesseract is included in the log messages.\n   - Finally, it checks that the mock was called.\n\n3. **Edge Cases**:\n   - The edge case here is ensuring that the validation function correctly identifies and handles the absence of Tesseract OCR software without crashing.\n   - Additionally, it verifies that appropriate log messages are generated to guide users on how to resolve the issue.\n\n### Python Docstring\n```python\ndef test_tesseract_not_installed(caplog):\n    \"\"\"\n    Test the behavior of the validation function when Tesseract OCR is not installed.\n\n    This test mocks the absence of Tesseract OCR and ensures that the validation\n    function raises a `MissingDependencyError` with the correct error message.\n    It also checks that appropriate log messages are generated to advise the user\n    on how to install Tesseract.\n    \"\"\"\n    # Implementation details as provided in the code snippet\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_overlay", "whole_func_string": "def test_overlay(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'overlay.pdf',\n        outpdf,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_overlay(resources, outpdf):\n    check_ocrmypdf(\n        resources / 'overlay.pdf',\n        outpdf,\n        '--skip-text',\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_overlay\\n```python\\ndef test_overlay(resources, outpdf):\\n    check_ocrmypdf(\\n        resources / 'overlay.pdf',\\n        outpdf,\\n        '--skip-text',\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose**: The `test_overlay` function is designed to test the functionality of overlaying PDFs using OCRmyPDF. It ensures that the overlay operation can be performed without skipping text and with a custom plugin.\n\n**Parameters Analysis**:\n1. **resources (Path)**: A path object pointing to the directory containing the resource files used in the test, specifically 'overlay.pdf'.\n2. **outpdf (str)**: The path where the output PDF file will be saved after overlaying.\n\n**Behavior**:\n- The function calls `check_ocrmypdf` with specific arguments.\n- It overlays 'overlay.pdf' from the `resources` directory onto a new output file specified by `outpdf`.\n- The overlay operation uses the `--skip-text` option to exclude text detection, and the custom plugin `tests/plugins/tesseract_noop.py`.\n\n**Edge Cases**:\n- If 'overlay.pdf' is not found in the `resources` directory, an exception will be raised.\n- If there is an issue with writing the output file specified by `outpdf`, an error will occur.\n\n### Python Docstring\n\n```python\ndef test_overlay(resources, outpdf):\n    \"\"\"\n    Test the overlay functionality of OCRmyPDF.\n\n    Parameters:\n    resources (Path): Path to the directory containing the resource files.\n    outpdf (str): The path where the output PDF file will be saved after overlaying.\n\n    This function overlays 'overlay.pdf' from the provided resources onto a new PDF file specified by `outpdf`.\n    It skips text detection and uses a custom plugin for processing.\n    \"\"\"\n    check_ocrmypdf(\n        resources / 'overlay.pdf',\n        outpdf,\n        '--skip-text',\n        '--plugin', 'tests/plugins/tesseract_noop.py',\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "languages", "whole_func_string": "def languages(options):\n        return tesseract.get_languages()", "func_code_string": "def languages(options):\n        return tesseract.get_languages()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/builtin_plugins/tesseract_ocr.py\\nFunction/Class: languages\\n```python\\ndef languages(options):\\n        return tesseract.get_languages()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**:\n   The `languages` function in the `tesseract_ocr.py` module is designed to retrieve a list of supported languages for OCR (Optical Character Recognition) using Tesseract, a popular open-source OCR engine.\n\n2. **Parameters and Behavior**:\n   - **Function**: `languages`\n   - **Parameters**: \n     - `options`: This parameter is not used within the function and appears to be passed through but ignored.\n   - **Behavior**:\n     The function calls `tesseract.get_languages()` to obtain a list of supported OCR languages provided by Tesseract.\n\n3. **Edge Cases**:\n   - If `tesseract.get_languages()` fails or returns an unexpected value, the function will return that value directly without any error handling.\n   - There are no explicit edge cases handled within this function; it relies on the correctness and robustness of `tesseract.get_languages()`.\n\n4. **Python Docstring**:\n   ```python\n   def languages(options):\n       \"\"\"\n       Retrieve a list of supported OCR languages for Tesseract.\n\n       Parameters:\n       options (any): Ignored parameter that is passed through but not used.\n\n       Returns:\n       list: A list of strings representing the supported OCR languages.\n       \"\"\"\n       return tesseract.get_languages()\n   ```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "SubprocessOutputError", "whole_func_string": "class SubprocessOutputError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.child_process_error", "func_code_string": "class SubprocessOutputError(ExitCodeException):\n                                                    \n\n    exit_code = ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/exceptions.py\\nFunction/Class: SubprocessOutputError\\n```python\\nclass SubprocessOutputError(ExitCodeException):\\n                                                    \\n\\n    exit_code = ExitCode.child_process_error\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `SubprocessOutputError` class is a custom exception designed to handle errors that occur when subprocesses produce unexpected output. This exception extends the base `ExitCodeException`, indicating that it is related to issues encountered during the execution of external processes.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**: The class does not have any parameters other than those inherited from its parent class.\n- **Behavior**: When raised, this exception indicates that a subprocess has generated output that deviates from expected norms. This could be due to various reasons such as invalid input, unexpected data formats, or runtime errors within the subprocess.\n- **Edge Cases**:\n  - **Normal Operation**: The exception is not raised during typical operation where the subprocess behaves as expected.\n  - **Error in Output Handling**: The exception is raised when the application fails to handle the output of a subprocess correctly.\n  - **Misconfigured Subprocess**: The exception could be raised if there are issues with how the subprocess is configured or invoked.\n\n### Concise Python Docstring\n\n```python\nclass SubprocessOutputError(ExitCodeException):\n    \"\"\"\n    Raised when a subprocess generates unexpected output, indicating an issue with the output handling.\n    \"\"\"\n    exit_code = ExitCode.child_process_error\n```\n\nThis docstring succinctly captures the purpose and behavior of the `SubprocessOutputError` class, highlighting its role in managing errors related to subprocess output."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/jbig2enc.py", "func_name": "convert_group", "whole_func_string": "def convert_group(cwd, infiles, out_prefix, threshold):\n    args = [\n        'jbig2',\n        '-b',\n        out_prefix,\n        '--symbol-mode',                       \n        '-t',\n        str(threshold),             \n                                                                              \n                \n        '--pdf',\n    ]\n    args.extend(infiles)\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_code_string": "def convert_group(cwd, infiles, out_prefix, threshold):\n    args = [\n        'jbig2',\n        '-b',\n        out_prefix,\n        '--symbol-mode',                       \n        '-t',\n        str(threshold),             \n                                                                              \n                \n        '--pdf',\n    ]\n    args.extend(infiles)\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\n    proc.check_returncode()\n    return proc", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/jbig2enc.py\\nFunction/Class: convert_group\\n```python\\ndef convert_group(cwd, infiles, out_prefix, threshold):\\n    args = [\\n        'jbig2',\\n        '-b',\\n        out_prefix,\\n        '--symbol-mode',                       \\n        '-t',\\n        str(threshold),             \\n                                                                              \\n                \\n        '--pdf',\\n    ]\\n    args.extend(infiles)\\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\\n    proc.check_returncode()\\n    return proc\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `convert_group` function is designed to invoke the JBIG2 encoding tool (`jbig2`) on a group of input files. It converts each input file into a JBIG2-compressed format, using specified options such as an output prefix and threshold for compression quality.\n\n### Parameters\n- **cwd (str)**: The working directory where the `jbig2` command will be executed.\n- **infiles (list[str])**: A list of input files that need to be converted to JBIG2 format.\n- **out_prefix (str)**: The prefix for the output JBIG2 files. Each input file will produce a corresponding JBIG2 file with this prefix appended to its base name.\n- **threshold (int)**: An integer representing the threshold value used for compression quality. Higher values generally result in better compression but lower image quality.\n\n### Behavior\n1. The function constructs a command line (`args`) to run the `jbig2` tool, including parameters such as the output prefix and threshold.\n2. It appends all input files to the command line.\n3. The `run` function is called with the constructed command line in the specified working directory (`cwd`). The standard output and error are captured.\n4. If the return code of the process is non-zero (indicating an error), it raises an exception.\n5. Finally, the function returns the subprocess object.\n\n### Edge Cases\n- **Empty `infiles` list**: This will cause the command to be run without any input files, which might result in an error depending on the `jbig2` tool's behavior.\n- **Nonexistent or inaccessible files**: If any file in `infiles` does not exist or cannot be accessed, it may lead to a failure of the subprocess.\n- **Invalid `threshold` value**: If the threshold is outside the valid range supported by `jbig2`, it could cause an error when running the command.\n\n### Python Docstring\n```python\ndef convert_group(cwd, infiles, out_prefix, threshold):\n    \"\"\"\n    Convert a group of input files to JBIG2 format using the jbig2 tool.\n    \n    Parameters:\n    - cwd (str): Working directory for executing the jbig2 command.\n    - infiles (list[str]): List of input files to be converted.\n    - out_prefix (str): Prefix for output JBIG2 files.\n    - threshold (int): Compression quality threshold.\n    \n    Returns:\n    subprocess.CompletedProcess: Process object containing the result of the jbig2 command.\n    \n    Raises:\n    subprocess.CalledProcessError: If the jbig2 command returns a non-zero exit code.\n    \"\"\"\n    args = [\n        'jbig2',\n        '-b', out_prefix,\n        '--symbol-mode',\n        '-t', str(threshold),\n        '--pdf'\n    ]\n    args.extend(infiles)\n    proc = run(args, cwd=cwd, stdout=PIPE, stderr=PIPE)\n    proc.check_returncode()\n    return proc\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/pngquant.py", "func_name": "quantize", "whole_func_string": "def quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\n           \n    with open(input_file, 'rb') as input_stream:\n        args = [\n            'pngquant',\n            '--force',\n            '--skip-if-larger',\n            '--quality',\n            f'{quality_min}-{quality_max}',\n            '--',                                       \n            '-',                                     \n        ]\n        result = run(args, stdin=input_stream, stdout=PIPE, stderr=PIPE, check=False)\n\n    if result.returncode == 0:\n                                                                            \n        output_file.write_bytes(result.stdout)", "func_code_string": "def quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\n           \n    with open(input_file, 'rb') as input_stream:\n        args = [\n            'pngquant',\n            '--force',\n            '--skip-if-larger',\n            '--quality',\n            f'{quality_min}-{quality_max}',\n            '--',                                       \n            '-',                                     \n        ]\n        result = run(args, stdin=input_stream, stdout=PIPE, stderr=PIPE, check=False)\n\n    if result.returncode == 0:\n                                                                            \n        output_file.write_bytes(result.stdout)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/pngquant.py\\nFunction/Class: quantize\\n```python\\ndef quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\\n           \\n    with open(input_file, 'rb') as input_stream:\\n        args = [\\n            'pngquant',\\n            '--force',\\n            '--skip-if-larger',\\n            '--quality',\\n            f'{quality_min}-{quality_max}',\\n            '--',                                       \\n            '-',                                     \\n        ]\\n        result = run(args, stdin=input_stream, stdout=PIPE, stderr=PIPE, check=False)\\n\\n    if result.returncode == 0:\\n                                                                            \\n        output_file.write_bytes(result.stdout)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose:**\nThe `quantize` function is designed to reduce the color depth of a PNG image using the `pngquant` command-line tool. This process compresses the image while maintaining visual quality by reducing the number of colors used.\n\n**Parameter Analysis:**\n- **input_file (Path):** The path to the input PNG file that needs to be quantized.\n- **output_file (Path):** The path where the quantized PNG file will be saved.\n- **quality_min (int):** The minimum quality setting for pngquant, ranging from 0 to 100. Lower values result in higher compression but lower image quality.\n- **quality_max (int):** The maximum quality setting for pngquant. This parameter ensures that the output is within a specified quality range.\n\n**Behavior:**\nThe function reads the input PNG file and uses `pngquant` with specified quality settings to reduce its color depth. If successful, it writes the quantized image to the output file.\n\n**Edge Cases:**\n- **Invalid Input File:** If the input file does not exist or is not a valid PNG file, an error will occur when trying to open the file.\n- **Quality Range:** If `quality_min` is greater than `quality_max`, it may lead to unexpected behavior. The function should handle this case gracefully, possibly by raising a ValueError.\n- **pngquant Command Failure:** If `pngquant` returns a non-zero exit code, indicating an error occurred during processing, the function should handle this appropriately.\n\n**Docstring:**\n```python\ndef quantize(input_file: Path, output_file: Path, quality_min: int, quality_max: int):\n    \"\"\"\n    Quantizes the color depth of a PNG image using pngquant and saves it to the specified output file.\n\n    Parameters:\n    input_file (Path): The path to the input PNG file.\n    output_file (Path): The path where the quantized PNG file will be saved.\n    quality_min (int): The minimum quality setting for pngquant (0-100).\n    quality_max (int): The maximum quality setting for pngquant (0-100).\n\n    Raises:\n    ValueError: If quality_min is greater than quality_max.\n    FileNotFoundError: If the input file does not exist or is not a valid PNG file.\n\n    Returns:\n    None\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_cache.py", "func_name": "CacheOcrEngine", "whole_func_string": "class CacheOcrEngine(TesseractOcrEngine):\n                                                                              \n                                                                         \n                                                                                    \n                                                   \n    lock = threading.Lock()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_code_string": "class CacheOcrEngine(TesseractOcrEngine):\n                                                                              \n                                                                         \n                                                                                    \n                                                   \n    lock = threading.Lock()\n\n    @staticmethod\n    def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)\n\n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)\n\n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n\n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_cache.py\\nFunction/Class: CacheOcrEngine\\n```python\\nclass CacheOcrEngine(TesseractOcrEngine):\\n                                                                              \\n                                                                         \\n                                                                                    \\n                                                   \\n    lock = threading.Lock()\\n\\n    @staticmethod\\n    def get_orientation(input_file, options):\\n        with (\\n            CacheOcrEngine.lock,\\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\\n        ):\\n            return TesseractOcrEngine.get_orientation(input_file, options)\\n\\n    @staticmethod\\n    def get_deskew(input_file, options) -> float:\\n        with (\\n            CacheOcrEngine.lock,\\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\\n        ):\\n            return TesseractOcrEngine.get_deskew(input_file, options)\\n\\n    @staticmethod\\n    def generate_hocr(input_file, output_hocr, output_text, options):\\n        with (\\n            CacheOcrEngine.lock,\\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\\n        ):\\n            TesseractOcrEngine.generate_hocr(\\n                input_file, output_hocr, output_text, options\\n            )\\n\\n    @staticmethod\\n    def generate_pdf(input_file, output_pdf, output_text, options):\\n        with (\\n            CacheOcrEngine.lock,\\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\\n        ):\\n            TesseractOcrEngine.generate_pdf(\\n                input_file, output_pdf, output_text, options\\n            )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `CacheOcrEngine` class is designed to enhance the functionality of an OCR (Optical Character Recognition) engine by caching results. This allows for faster processing and reduced load times when performing OCR operations on files that have already been processed.\n\n### Analysis\n\n#### Parameters\n- **input_file**: The file path to the image or document that needs to be processed.\n- **options**: Additional options that can be passed to the OCR engine to customize the behavior of the OCR process, such as language settings, resolution, and more.\n\n#### Behavior\nThe `CacheOcrEngine` class inherits from a base class `TesseractOcrEngine`. It overrides several static methods (`get_orientation`, `get_deskew`, `generate_hocr`, `generate_pdf`) to add caching functionality. The caching is achieved by using a lock (`lock`) to ensure thread safety and by patching the OCR engine's run method to use a cached version of the function (`cached_run`).\n\n#### Edge Cases\n- **Concurrent Access**: The use of a lock ensures that multiple threads can safely access the OCR engine without causing race conditions.\n- **Caching Mechanism**: The caching mechanism should handle cases where the same file is processed multiple times, ensuring that the results are retrieved from cache rather than being recomputed.\n\n### Python Docstring\n\n```python\nclass CacheOcrEngine(TesseractOcrEngine):\n    \"\"\"\n    Caches OCR engine results to enhance performance for repeated processing of the same files.\n    \n    Methods overridden:\n    - get_orientation(input_file, options): Retrieves the orientation of a document with caching.\n    - get_deskew(input_file, options): Deskews a document with caching.\n    - generate_hocr(input_file, output_hocr, output_text, options): Generates HOCR file with caching.\n    - generate_pdf(input_file, output_pdf, output_text, options): Generates PDF with caching.\n    \n    Parameters:\n    input_file (str): The path to the image or document to be processed.\n    options (dict): Additional options for the OCR engine.\n    \n    Returns:\n    Various: Depending on the method, returns orientation, deskew angle, HOCR file, or generated PDF.\n    \"\"\"\n    \n    lock = threading.Lock()\n    \n    @staticmethod\n    def get_orientation(input_file, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_orientation(input_file, options)\n    \n    @staticmethod\n    def get_deskew(input_file, options) -> float:\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            return TesseractOcrEngine.get_deskew(input_file, options)\n    \n    @staticmethod\n    def generate_hocr(input_file, output_hocr, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_hocr(\n                input_file, output_hocr, output_text, options\n            )\n    \n    @staticmethod\n    def generate_pdf(input_file, output_pdf, output_text, options):\n        with (\n            CacheOcrEngine.lock,\n            patch('ocrmypdf._exec.tesseract.run', new=partial(cached_run, options)),\n        ):\n            TesseractOcrEngine.generate_pdf(\n                input_file, output_pdf, output_text, options\n            )\n```\n\nThis docstring provides a clear description of the purpose and functionality of the `CacheOcrEngine` class, including its methods and parameters. It also mentions the caching mechanism used to improve performance for repeated file processing."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/api.py", "func_name": "create_options", "whole_func_string": "def create_options(\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\n) -> Namespace:\n           \n    cmdline, deferred = _kwargs_to_cmdline(\n        defer_kwargs={'progress_bar', 'plugins', 'parser', 'input_file', 'output_file'},\n        **kwargs,\n    )\n    if isinstance(input_file, BinaryIO | IOBase):\n        cmdline.append('stream://input_file')\n    else:\n        cmdline.append(os.fspath(input_file))\n    if isinstance(output_file, BinaryIO | IOBase):\n        cmdline.append('stream://output_file')\n    else:\n        cmdline.append(os.fspath(output_file))\n    if 'sidecar' in kwargs and isinstance(kwargs['sidecar'], BinaryIO | IOBase):\n        cmdline.append('--sidecar')\n        cmdline.append('stream://sidecar')\n\n    parser.enable_api_mode()\n    options = parser.parse_args(cmdline)\n    for keyword, val in deferred.items():\n        setattr(options, keyword, val)\n\n    if options.input_file == 'stream://input_file':\n        options.input_file = input_file\n    if options.output_file == 'stream://output_file':\n        options.output_file = output_file\n    if options.sidecar == 'stream://sidecar':\n        options.sidecar = kwargs['sidecar']\n\n    return options", "func_code_string": "def create_options(\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\n) -> Namespace:\n           \n    cmdline, deferred = _kwargs_to_cmdline(\n        defer_kwargs={'progress_bar', 'plugins', 'parser', 'input_file', 'output_file'},\n        **kwargs,\n    )\n    if isinstance(input_file, BinaryIO | IOBase):\n        cmdline.append('stream://input_file')\n    else:\n        cmdline.append(os.fspath(input_file))\n    if isinstance(output_file, BinaryIO | IOBase):\n        cmdline.append('stream://output_file')\n    else:\n        cmdline.append(os.fspath(output_file))\n    if 'sidecar' in kwargs and isinstance(kwargs['sidecar'], BinaryIO | IOBase):\n        cmdline.append('--sidecar')\n        cmdline.append('stream://sidecar')\n\n    parser.enable_api_mode()\n    options = parser.parse_args(cmdline)\n    for keyword, val in deferred.items():\n        setattr(options, keyword, val)\n\n    if options.input_file == 'stream://input_file':\n        options.input_file = input_file\n    if options.output_file == 'stream://output_file':\n        options.output_file = output_file\n    if options.sidecar == 'stream://sidecar':\n        options.sidecar = kwargs['sidecar']\n\n    return options", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/api.py\\nFunction/Class: create_options\\n```python\\ndef create_options(\\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\\n) -> Namespace:\\n           \\n    cmdline, deferred = _kwargs_to_cmdline(\\n        defer_kwargs={'progress_bar', 'plugins', 'parser', 'input_file', 'output_file'},\\n        **kwargs,\\n    )\\n    if isinstance(input_file, BinaryIO | IOBase):\\n        cmdline.append('stream://input_file')\\n    else:\\n        cmdline.append(os.fspath(input_file))\\n    if isinstance(output_file, BinaryIO | IOBase):\\n        cmdline.append('stream://output_file')\\n    else:\\n        cmdline.append(os.fspath(output_file))\\n    if 'sidecar' in kwargs and isinstance(kwargs['sidecar'], BinaryIO | IOBase):\\n        cmdline.append('--sidecar')\\n        cmdline.append('stream://sidecar')\\n\\n    parser.enable_api_mode()\\n    options = parser.parse_args(cmdline)\\n    for keyword, val in deferred.items():\\n        setattr(options, keyword, val)\\n\\n    if options.input_file == 'stream://input_file':\\n        options.input_file = input_file\\n    if options.output_file == 'stream://output_file':\\n        options.output_file = output_file\\n    if options.sidecar == 'stream://sidecar':\\n        options.sidecar = kwargs['sidecar']\\n\\n    return options\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-level Purpose**:\n   The `create_options` function is designed to create and configure command-line options for OCRMyPDF using an `ArgumentParser`. This function processes input and output file paths, handles deferred keyword arguments, and ensures that the `options` object accurately reflects these settings.\n\n2. **Parameter Analysis**:\n   - `input_file`: The path or stream of the input PDF file.\n   - `output_file`: The path or stream where the processed PDF will be saved.\n   - `parser`: An instance of `ArgumentParser` configured with OCRMyPDF options.\n   - `kwargs`: Additional keyword arguments that may include deferred options like progress bar, plugins, and sidecar files.\n\n3. **Behavior**:\n   - Converts input and output file paths to strings unless they are streams, in which case it appends 'stream://input_file' or 'stream://output_file'.\n   - Handles the `sidecar` file similarly if provided.\n   - Enables API mode in the parser and parses the command line arguments into a `Namespace`.\n   - Defers setting certain options that need to be applied after parsing, such as input/output files which may have been replaced by stream placeholders.\n\n4. **Edge Cases**:\n   - If the input or output file is provided as a stream, it handles these cases gracefully.\n   - The function ensures that any deferred options (like `sidecar`) are correctly set on the `options` object.\n\n### Python Docstring\n\n```python\ndef create_options(\n    *, input_file: PathOrIO, output_file: PathOrIO, parser: ArgumentParser, **kwargs\n) -> Namespace:\n    \"\"\"\n    Create and configure OCRMyPDF options using an ArgumentParser.\n\n    Parameters:\n    - input_file (PathOrIO): The path or stream of the input PDF file.\n    - output_file (PathOrIO): The path or stream where the processed PDF will be saved.\n    - parser (ArgumentParser): An instance of ArgumentParser configured with OCRMyPDF options.\n    - **kwargs: Additional keyword arguments that may include deferred options like progress bar, plugins, and sidecar files.\n\n    Returns:\n    - Namespace: A namespace object containing the parsed options.\n\n    Notes:\n    - Handles input and output file paths as either file paths or streams.\n    - Defers setting certain options (like sidecar) after parsing to ensure correct values.\n    - Enables API mode in the parser before parsing command line arguments.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_pickle", "whole_func_string": "def test_pickle(resources):\n                                                                        \n                                                                         \n                                \n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    pickle.dumps(pdf)", "func_code_string": "def test_pickle(resources):\n                                                                        \n                                                                         \n                                \n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    pickle.dumps(pdf)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: test_pickle\\n```python\\ndef test_pickle(resources):\\n                                                                        \\n                                                                         \\n                                \\n    filename = resources / 'graph_ocred.pdf'\\n    pdf = pdfinfo.PdfInfo(filename)\\n    pickle.dumps(pdf)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function:**\nThe `test_pickle` function is designed to test the serialization of a PDF document using Python's `pickle` module. This ensures that the `PdfInfo` object, which encapsulates information about a PDF file, can be serialized and deserialized without losing its state.\n\n**Analysis of parameters:**\n- `resources`: A parameter representing a directory containing various resource files, including the PDF to be tested.\n\n**Behavior:**\n1. The function locates a PDF file named `graph_ocred.pdf` within the provided `resources` directory.\n2. It creates an instance of `pdfinfo.PdfInfo`, passing the path to the PDF file as an argument.\n3. The `pickle.dumps(pdf)` method is called to serialize the `PdfInfo` object.\n\n**Edge cases:**\n- If the specified PDF file does not exist in the `resources` directory, a `FileNotFoundError` will be raised.\n- If there are issues with pickling the `PdfInfo` object (e.g., due to custom objects or non-serializable attributes), a `pickle.PicklingError` may occur.\n\n**Concise Python docstring:**\n```python\ndef test_pickle(resources):\n    \"\"\"\n    Test the serialization of a PDFInfo object using pickle.\n    \n    Parameters:\n    resources (pathlib.Path): The directory containing the PDF file to be tested.\n    \n    Raises:\n    FileNotFoundError: If the specified PDF file does not exist.\n    pickle.PicklingError: If there are issues with pickling the PdfInfo object.\n    \"\"\"\n    filename = resources / 'graph_ocred.pdf'\n    pdf = pdfinfo.PdfInfo(filename)\n    pickle.dumps(pdf)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "get_canvas_square_dpi", "whole_func_string": "def get_canvas_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    units = float(\n        max(\n            image_dpi.x or VECTOR_PAGE_DPI,\n            image_dpi.y or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_code_string": "def get_canvas_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n           \n    pageinfo = page_context.pageinfo\n    options = page_context.options\n    if not image_dpi:\n        image_dpi = pageinfo.dpi\n    units = float(\n        max(\n            image_dpi.x or VECTOR_PAGE_DPI,\n            image_dpi.y or VECTOR_PAGE_DPI,\n            _vector_page_dpi(pageinfo),\n            options.oversample or 0.0,\n        )\n    )\n    return Resolution(units, units)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: get_canvas_square_dpi\\n```python\\ndef get_canvas_square_dpi(\\n    page_context: PageContext, image_dpi: Resolution | None = None\\n) -> Resolution:\\n           \\n    pageinfo = page_context.pageinfo\\n    options = page_context.options\\n    if not image_dpi:\\n        image_dpi = pageinfo.dpi\\n    units = float(\\n        max(\\n            image_dpi.x or VECTOR_PAGE_DPI,\\n            image_dpi.y or VECTOR_PAGE_DPI,\\n            _vector_page_dpi(pageinfo),\\n            options.oversample or 0.0,\\n        )\\n    )\\n    return Resolution(units, units)\\n```\", \"assistant\": \"\"}", "response": "### Function: `get_canvas_square_dpi`\n\n**Purpose:**  \nThis function calculates the square DPI (dots per inch) for a canvas based on various sources such as image DPI, page information, and options. The goal is to determine a consistent and high-enough DPI value for rendering or processing operations.\n\n**Parameters:**\n- `page_context` (`PageContext`): A context object containing page information and options relevant for the operation.\n- `image_dpi` (`Resolution | None`, optional): An optional dpi resolution for an image. If not provided, it defaults to the page DPI from `pageinfo`.\n\n**Behavior:**\n1. The function retrieves the page information (`pageinfo`) and options (`options`) from the `page_context`.\n2. If `image_dpi` is not provided, it defaults to the DPI value from the page information.\n3. It calculates a square DPI by determining the maximum value among:\n   - The x-axis dpi of `image_dpi` or a default vector DPI if not specified.\n   - The y-axis dpi of `image_dpi` or a default vector DPI if not specified.\n   - A vector-based dpi calculated from `pageinfo`.\n   - An oversample factor provided in the options, which is treated as a multiplier for the DPI.\n4. If any of the dpi values are not explicitly set (i.e., they are `None`), the function uses default values (`VECTOR_PAGE_DPI`).\n5. The function returns a new `Resolution` object with the calculated square DPI value.\n\n**Edge Cases:**\n- If both `image_dpi` and its components (`x` and `y`) are `None`, the function will use the default vector DPI.\n- If an oversample factor is provided in the options, it will be used to adjust the DPI calculation by multiplying it with the maximum dpi value.\n\n**Docstring:**\n```python\ndef get_canvas_square_dpi(\n    page_context: PageContext, image_dpi: Resolution | None = None\n) -> Resolution:\n    \"\"\"\n    Calculate and return the square DPI for a canvas based on various sources such as image DPI,\n    page information, and options. The goal is to determine a consistent and high-enough DPI value\n    for rendering or processing operations.\n\n    Parameters:\n    - page_context (PageContext): A context object containing page information and options.\n    - image_dpi (Resolution | None, optional): An optional dpi resolution for an image. If not provided,\n      it defaults to the page DPI from `pageinfo`.\n\n    Returns:\n    - Resolution: A new Resolution object with the calculated square DPI value.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "optimize", "whole_func_string": "def optimize(\n    input_file: Path,\n    output_file: Path,\n    context: PdfContext,\n    save_settings: dict[str, Any],\n    executor: Executor = DEFAULT_EXECUTOR,\n) -> Path:\n                                        \n    options = context.options\n    if options.optimize == 0:\n        safe_symlink(input_file, output_file)\n        return output_file\n\n    if options.jpeg_quality == 0:\n        options.jpeg_quality = DEFAULT_JPEG_QUALITY if options.optimize < 3 else 40\n    if options.png_quality == 0:\n        options.png_quality = DEFAULT_PNG_QUALITY if options.optimize < 3 else 30\n    if options.jbig2_page_group_size == 0:\n        options.jbig2_page_group_size = 10 if options.jbig2_lossy else 1\n\n    with Pdf.open(input_file) as pdf:\n        root = output_file.parent / 'images'\n        root.mkdir(exist_ok=True)\n\n        jpegs, pngs = extract_images_generic(pdf, root, options)\n        transcode_jpegs(pdf, jpegs, root, options, executor)\n        deflate_jpegs(pdf, root, options, executor)\n                                   \n                                 \n                                                                \n        transcode_pngs(pdf, pngs, png_name, root, options, executor)\n\n        jbig2_groups = extract_images_jbig2(pdf, root, options)\n        convert_to_jbig2(pdf, jbig2_groups, root, options, executor)\n\n        target_file = output_file.with_suffix('.opt.pdf')\n        pdf.remove_unreferenced_resources()\n        pdf.save(target_file, **save_settings)\n\n    input_size = input_file.stat().st_size\n    output_size = target_file.stat().st_size\n    if output_size == 0:\n        raise OutputFileAccessError(\n            f\"Output file not created after optimizing. We probably ran \"\n            f\"out of disk space in the temporary folder: {tempfile.gettempdir()}.\"\n        )\n    savings = 1 - output_size / input_size\n\n    if savings < 0:\n        log.info(\n            \"Image optimization did not improve the file - \"\n            \"optimizations will not be used\"\n        )\n                                        \n        with Pdf.open(input_file) as pdf:\n            pdf.remove_unreferenced_resources()\n            pdf.save(output_file, **save_settings)\n    else:\n        safe_symlink(target_file, output_file)\n\n    return output_file", "func_code_string": "def optimize(\n    input_file: Path,\n    output_file: Path,\n    context: PdfContext,\n    save_settings: dict[str, Any],\n    executor: Executor = DEFAULT_EXECUTOR,\n) -> Path:\n                                        \n    options = context.options\n    if options.optimize == 0:\n        safe_symlink(input_file, output_file)\n        return output_file\n\n    if options.jpeg_quality == 0:\n        options.jpeg_quality = DEFAULT_JPEG_QUALITY if options.optimize < 3 else 40\n    if options.png_quality == 0:\n        options.png_quality = DEFAULT_PNG_QUALITY if options.optimize < 3 else 30\n    if options.jbig2_page_group_size == 0:\n        options.jbig2_page_group_size = 10 if options.jbig2_lossy else 1\n\n    with Pdf.open(input_file) as pdf:\n        root = output_file.parent / 'images'\n        root.mkdir(exist_ok=True)\n\n        jpegs, pngs = extract_images_generic(pdf, root, options)\n        transcode_jpegs(pdf, jpegs, root, options, executor)\n        deflate_jpegs(pdf, root, options, executor)\n                                   \n                                 \n                                                                \n        transcode_pngs(pdf, pngs, png_name, root, options, executor)\n\n        jbig2_groups = extract_images_jbig2(pdf, root, options)\n        convert_to_jbig2(pdf, jbig2_groups, root, options, executor)\n\n        target_file = output_file.with_suffix('.opt.pdf')\n        pdf.remove_unreferenced_resources()\n        pdf.save(target_file, **save_settings)\n\n    input_size = input_file.stat().st_size\n    output_size = target_file.stat().st_size\n    if output_size == 0:\n        raise OutputFileAccessError(\n            f\"Output file not created after optimizing. We probably ran \"\n            f\"out of disk space in the temporary folder: {tempfile.gettempdir()}.\"\n        )\n    savings = 1 - output_size / input_size\n\n    if savings < 0:\n        log.info(\n            \"Image optimization did not improve the file - \"\n            \"optimizations will not be used\"\n        )\n                                        \n        with Pdf.open(input_file) as pdf:\n            pdf.remove_unreferenced_resources()\n            pdf.save(output_file, **save_settings)\n    else:\n        safe_symlink(target_file, output_file)\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: optimize\\n```python\\ndef optimize(\\n    input_file: Path,\\n    output_file: Path,\\n    context: PdfContext,\\n    save_settings: dict[str, Any],\\n    executor: Executor = DEFAULT_EXECUTOR,\\n) -> Path:\\n                                        \\n    options = context.options\\n    if options.optimize == 0:\\n        safe_symlink(input_file, output_file)\\n        return output_file\\n\\n    if options.jpeg_quality == 0:\\n        options.jpeg_quality = DEFAULT_JPEG_QUALITY if options.optimize < 3 else 40\\n    if options.png_quality == 0:\\n        options.png_quality = DEFAULT_PNG_QUALITY if options.optimize < 3 else 30\\n    if options.jbig2_page_group_size == 0:\\n        options.jbig2_page_group_size = 10 if options.jbig2_lossy else 1\\n\\n    with Pdf.open(input_file) as pdf:\\n        root = output_file.parent / 'images'\\n        root.mkdir(exist_ok=True)\\n\\n        jpegs, pngs = extract_images_generic(pdf, root, options)\\n        transcode_jpegs(pdf, jpegs, root, options, executor)\\n        deflate_jpegs(pdf, root, options, executor)\\n                                   \\n                                 \\n                                                                \\n        transcode_pngs(pdf, pngs, png_name, root, options, executor)\\n\\n        jbig2_groups = extract_images_jbig2(pdf, root, options)\\n        convert_to_jbig2(pdf, jbig2_groups, root, options, executor)\\n\\n        target_file = output_file.with_suffix('.opt.pdf')\\n        pdf.remove_unreferenced_resources()\\n        pdf.save(target_file, **save_settings)\\n\\n    input_size = input_file.stat().st_size\\n    output_size = target_file.stat().st_size\\n    if output_size == 0:\\n        raise OutputFileAccessError(\\n            f\\\"Output file not created after optimizing. We probably ran \\\"\\n            f\\\"out of disk space in the temporary folder: {tempfile.gettempdir()}.\\\"\\n        )\\n    savings = 1 - output_size / input_size\\n\\n    if savings < 0:\\n        log.info(\\n            \\\"Image optimization did not improve the file - \\\"\\n            \\\"optimizations will not be used\\\"\\n        )\\n                                        \\n        with Pdf.open(input_file) as pdf:\\n            pdf.remove_unreferenced_resources()\\n            pdf.save(output_file, **save_settings)\\n    else:\\n        safe_symlink(target_file, output_file)\\n\\n    return output_file\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `optimize` function is designed to optimize a PDF file by reducing its size while maintaining the quality of images and other resources. It processes various image formats such as JPEG, PNG, and JBIG2, applying specific optimization techniques based on the provided options.\n\n### Parameters\n\n1. **input_file**: A `Path` object representing the path to the input PDF file.\n2. **output_file**: A `Path` object representing the path where the optimized PDF will be saved.\n3. **context**: A `PdfContext` object containing various configuration options for optimization.\n4. **save_settings**: A dictionary with settings to control how the PDF is saved, such as compression level or encryption options.\n5. **executor** (optional): An `Executor` object used to manage the execution of image processing tasks. Defaults to `DEFAULT_EXECUTOR`.\n\n### Behavior\n\n1. **Check for Optimization Level**: If the optimization level (`options.optimize`) is 0, a safe symbolic link is created from the input file to the output file, and the function returns immediately.\n2. **Set Default Quality Levels**: Depending on the optimization level, default JPEG and PNG quality levels are set. For higher optimization levels, lower quality levels are used.\n3. **Image Extraction and Transcoding**:\n   - Extracts images in various formats (JPEG, PNG, JBIG2) from the PDF.\n   - Transcodes JPEG images using specified options.\n   - Deflates JPEG images if required.\n   - Transcodes PNG images similarly.\n   - Groups pages for JBIG2 encoding based on lossy or non-lossy compression settings.\n4. **JBIG2 Conversion**: Converts grouped pages into JBIG2 format.\n5. **Save Optimized PDF**: The optimized content is saved to a new file, and unreferenced resources are removed.\n6. **File Size Check and Savings Calculation**:\n   - Calculates the size savings achieved by optimization.\n   - If no or negative savings are observed, the function reverts to saving the original PDF without modifications.\n\n### Edge Cases\n\n- **Disk Space**: The function checks if there is enough disk space in the temporary directory for processing. If not, it raises an `OutputFileAccessError`.\n- **Empty Output File**: If the output file is empty after optimization, indicating a failure to process images, the function logs an error and reverts to saving the original PDF.\n- **Negative Savings**: If the optimized file size is greater than the original size, suggesting no improvement or even degradation in quality, the function saves the original file instead of the optimized one.\n\n### Docstring\n\n```python\ndef optimize(\n    input_file: Path,\n    output_file: Path,\n    context: PdfContext,\n    save_settings: dict[str, Any],\n    executor: Executor = DEFAULT_EXECUTOR,\n) -> Path:\n    \"\"\"\n    Optimizes a PDF file by reducing its size while maintaining image quality.\n\n    Parameters:\n    input_file (Path): The path to the input PDF file.\n    output_file (Path): The path where the optimized PDF will be saved.\n    context (PdfContext): Configuration options for optimization.\n    save_settings (dict[str, Any]): Settings to control how the PDF is saved.\n    executor (Executor, optional): Executor for image processing tasks. Defaults to DEFAULT_EXECUTOR.\n\n    Returns:\n    Path: The path to the optimized PDF file.\n\n    Raises:\n    OutputFileAccessError: If the output file cannot be created due to insufficient disk space.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_optimize.py", "func_name": "test_extract_image_filter_with_small_stream_size", "whole_func_string": "def test_extract_image_filter_with_small_stream_size():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 50\n    assert extract_image_filter(image, None) is None", "func_code_string": "def test_extract_image_filter_with_small_stream_size():\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 50\n    assert extract_image_filter(image, None) is None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_optimize.py\\nFunction/Class: test_extract_image_filter_with_small_stream_size\\n```python\\ndef test_extract_image_filter_with_small_stream_size():\\n    image = MagicMock()\\n    image.Subtype = Name.Image\\n    image.Length = 50\\n    assert extract_image_filter(image, None) is None\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe function `test_extract_image_filter_with_small_stream_size` tests the behavior of an image extraction filter when applied to an image with a small stream size. The purpose is to ensure that the filter correctly returns `None` under these conditions.\n\n### Parameters and Behavior\n- **Parameters**:\n  - None\n\n- **Behavior**:\n  - Creates a mock object representing an image.\n  - Sets the `Subtype` attribute of the image to `Name.Image`.\n  - Sets the `Length` attribute of the image to 50, which is considered small for this context.\n  - Calls the `extract_image_filter` function with the mock image and `None` as arguments.\n  - Asserts that the result of `extract_image_filter` is `None`.\n\n- **Edge Cases**:\n  - The test focuses on a specific condition where the image length is small, which might trigger certain behavior in the `extract_image_filter` function.\n\n### Docstring\n```python\ndef test_extract_image_filter_with_small_stream_size():\n    \"\"\"\n    Test the extract_image_filter function with an image that has a small stream size.\n    \n    The purpose is to ensure that the filter correctly returns None when applied to such an image.\n    \"\"\"\n    image = MagicMock()\n    image.Subtype = Name.Image\n    image.Length = 50\n    assert extract_image_filter(image, None) is None\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "test_dpi_not_credible", "whole_func_string": "def test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image, dpi=(30, 30))\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"not credible\" in caplog.text", "func_code_string": "def test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image, dpi=(30, 30))\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"not credible\" in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_image_input.py\\nFunction/Class: test_dpi_not_credible\\n```python\\ndef test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\\n    im = baiona\\n    assert 'dpi' not in im.info\\n    input_image = outdir / 'baiona_no_dpi.png'\\n    im.save(input_image, dpi=(30, 30))\\n\\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\\n    assert rc == ocrmypdf.ExitCode.input_file\\n    assert \\\"not credible\\\" in caplog.text\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `test_dpi_not_credible` function tests the behavior of OCRMyPDF when an image does not have a credible DPI setting. Specifically, it checks that OCRMyPDF correctly identifies and reports the absence of a credible DPI value in the input image.\n\n### Analysis\n- **Parameters**:\n  - `caplog`: A pytest fixture used for capturing log messages.\n  - `baiona`: An instance of an image object (likely from PIL or a similar library).\n  - `outdir`: A temporary directory where files are written during testing.\n  - `no_outpdf`: A flag to indicate whether output PDF should be suppressed.\n\n- **Behavior**:\n  - The function asserts that the input image does not have a 'dpi' key in its metadata (`im.info`).\n  - It saves the image with a fixed DPI of (30, 30) and then runs OCRMyPDF on this modified image.\n  - The function checks that OCRMyPDF returns an `ExitCode.input_file`, indicating that it was unable to process the file due to the lack of credible DPI information.\n  - It also verifies that the log message contains the string \"not credible\", confirming that OCRMyPDF correctly identified the issue.\n\n- **Edge Cases**:\n  - The function assumes that the input image does not have a valid DPI setting, which is the intended test case. If the image already has a valid DPI, this test would fail.\n\n### Documentation\n```python\ndef test_dpi_not_credible(caplog, baiona, outdir, no_outpdf):\n    \"\"\"\n    Tests OCRMyPDF's behavior when an input image does not have a credible DPI setting.\n    \n    Parameters:\n    - caplog: pytest fixture for capturing log messages.\n    - baiona: Image object without a valid DPI setting.\n    - outdir: Temporary directory for file operations.\n    - no_outpdf: Flag to suppress output PDF generation.\n    \n    Asserts:\n    - OCRMyPDF correctly identifies the absence of a credible DPI value in the input image.\n    - OCRMyPDF returns an ExitCode.input_file indicating processing failure.\n    - The log contains the message \"not credible\".\n    \"\"\"\n    im = baiona\n    assert 'dpi' not in im.info\n    input_image = outdir / 'baiona_no_dpi.png'\n    im.save(input_image, dpi=(30, 30))\n\n    rc = run_ocrmypdf_api(input_image, no_outpdf)\n    assert rc == ocrmypdf.ExitCode.input_file\n    assert \"not credible\" in caplog.text\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_soft_error.py", "func_name": "rasterize_pdf_page", "whole_func_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_code_string": "def rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n) -> Path:\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/gs_raster_soft_error.py\\nFunction/Class: rasterize_pdf_page\\n```python\\ndef rasterize_pdf_page(\\n    input_file,\\n    output_file,\\n    raster_device,\\n    raster_dpi,\\n    pageno,\\n    page_dpi,\\n    rotation,\\n    filter_vector,\\n    stop_on_soft_error,\\n) -> Path:\\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\\n        mock.side_effect = fail_if_stoponerror\\n        ghostscript.rasterize_pdf_page(\\n            input_file=input_file,\\n            output_file=output_file,\\n            raster_device=raster_device,\\n            raster_dpi=raster_dpi,\\n            pageno=pageno,\\n            page_dpi=page_dpi,\\n            rotation=rotation,\\n            filter_vector=filter_vector,\\n            stop_on_soft_error=stop_on_soft_error,\\n        )\\n        mock.assert_called()\\n        return output_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `rasterize_pdf_page` function is designed to rasterize a specific page from a PDF file using Ghostscript, while optionally stopping on soft errors and handling other parameters such as DPI settings and rotation.\n\n1. **High-Level Purpose**: The primary purpose of this function is to convert a single page of a PDF document into an image format (rasterized) using Ghostscript.\n2. **Parameters**:\n   - `input_file`: Path to the input PDF file.\n   - `output_file`: Path where the rasterized image will be saved.\n   - `raster_device`: The Ghostscript device to use for rasterization, e.g., \"pngalpha\".\n   - `raster_dpi`: DPI (dots per inch) setting for the output raster image.\n   - `pageno`: Page number in the PDF file to rasterize.\n   - `page_dpi`: DPI setting for the input page in the PDF.\n   - `rotation`: Rotation angle for the rasterized image.\n   - `filter_vector`: A list of filters to apply during rasterization.\n   - `stop_on_soft_error`: If True, stop processing if a soft error is encountered; otherwise, continue.\n3. **Behavior**:\n   - The function uses the `ghostscript.rasterize_pdf_page` method from the `ocrmypdf._exec.ghostscript` module to perform the rasterization.\n   - It sets up a mock for Ghostscript's `run` method using Python\u2019s `patch` to intercept calls and call a custom side effect (`fail_if_stoponerror`) when `stop_on_soft_error` is True.\n   - The function asserts that the mocked method was called, ensuring that the rasterization process executed as expected.\n4. **Edge Cases**:\n   - If `stop_on_soft_error` is True and a soft error occurs during rasterization, the function will stop processing and not complete successfully.\n   - If an invalid parameter (e.g., incorrect file paths or unsupported DPI settings) is provided, the Ghostscript method might raise exceptions that need to be handled appropriately.\n\n### Python Docstring\n\n```python\ndef rasterize_pdf_page(\n    input_file,\n    output_file,\n    raster_device,\n    raster_dpi,\n    pageno,\n    page_dpi,\n    rotation,\n    filter_vector,\n    stop_on_soft_error,\n) -> Path:\n    \"\"\"\n    Rasterizes a specific page from a PDF file using Ghostscript.\n\n    Parameters:\n    - input_file (Path): Path to the input PDF file.\n    - output_file (Path): Path where the rasterized image will be saved.\n    - raster_device (str): The Ghostscript device to use for rasterization.\n    - raster_dpi (int): DPI setting for the output raster image.\n    - pageno (int): Page number in the PDF file to rasterize.\n    - page_dpi (int): DPI setting for the input page in the PDF.\n    - rotation (float): Rotation angle for the rasterized image.\n    - filter_vector (list): A list of filters to apply during rasterization.\n    - stop_on_soft_error (bool): If True, stop processing if a soft error is encountered.\n\n    Returns:\n    - Path: The path to the saved rasterized image file.\n\n    Raises:\n    - Exception: If an error occurs during the rasterization process.\n    \"\"\"\n    with patch('ocrmypdf._exec.ghostscript.run') as mock:\n        mock.side_effect = fail_if_stoponerror\n        ghostscript.rasterize_pdf_page(\n            input_file=input_file,\n            output_file=output_file,\n            raster_device=raster_device,\n            raster_dpi=raster_dpi,\n            pageno=pageno,\n            page_dpi=page_dpi,\n            rotation=rotation,\n            filter_vector=filter_vector,\n            stop_on_soft_error=stop_on_soft_error,\n        )\n        mock.assert_called()\n        return output_file\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "text_encode", "whole_func_string": "def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_code_string": "def text_encode(self, text: str) -> bytes:\n        raise NotImplementedError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/hocrtransform/_font.py\\nFunction/Class: text_encode\\n```python\\ndef text_encode(self, text: str) -> bytes:\\n        raise NotImplementedError()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `text_encode` function is to convert a given string of text into its corresponding byte representation. This is often necessary for processing or transmitting text data in environments that require binary data formats.\n\n### Parameters\n\n- **text (str)**: The input string that needs to be encoded into bytes.\n\n### Behavior\n\nThe `text_encode` method raises a `NotImplementedError`, indicating that the specific implementation of encoding the text into bytes is not provided. This suggests that this function is meant to be overridden in subclasses or implemented elsewhere within the codebase.\n\n### Edge Cases\n\n- If an empty string is passed, the function should ideally return an empty bytes object (`b''`).\n- Non-string inputs would lead to a `TypeError`.\n\n### Python Docstring\n\n```python\ndef text_encode(self, text: str) -> bytes:\n    \"\"\"\n    Convert a given string of text into its corresponding byte representation.\n\n    Parameters:\n    - text (str): The input string that needs to be encoded into bytes.\n\n    Returns:\n    - bytes: The byte representation of the input string.\n\n    Raises:\n    - NotImplementedError: This method should be overridden in subclasses or implemented elsewhere.\n    \"\"\"\n    raise NotImplementedError()\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "rasterize_preview", "whole_func_string": "def rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\n                                                 \n    output_file = page_context.get_path('rasterize_preview.jpg')\n    canvas_dpi = Resolution(300.0, 300.0).take_min(\n        [get_canvas_square_dpi(page_context)]\n    )\n    page_dpi = Resolution(300.0, 300.0).take_min([get_page_square_dpi(page_context)])\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device='jpeggray',\n        raster_dpi=canvas_dpi,\n        pageno=page_context.pageinfo.pageno + 1,\n        page_dpi=page_dpi,\n        rotation=0,\n        filter_vector=False,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_code_string": "def rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\n                                                 \n    output_file = page_context.get_path('rasterize_preview.jpg')\n    canvas_dpi = Resolution(300.0, 300.0).take_min(\n        [get_canvas_square_dpi(page_context)]\n    )\n    page_dpi = Resolution(300.0, 300.0).take_min([get_page_square_dpi(page_context)])\n    page_context.plugin_manager.hook.rasterize_pdf_page(\n        input_file=input_file,\n        output_file=output_file,\n        raster_device='jpeggray',\n        raster_dpi=canvas_dpi,\n        pageno=page_context.pageinfo.pageno + 1,\n        page_dpi=page_dpi,\n        rotation=0,\n        filter_vector=False,\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\n    )\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: rasterize_preview\\n```python\\ndef rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\\n                                                 \\n    output_file = page_context.get_path('rasterize_preview.jpg')\\n    canvas_dpi = Resolution(300.0, 300.0).take_min(\\n        [get_canvas_square_dpi(page_context)]\\n    )\\n    page_dpi = Resolution(300.0, 300.0).take_min([get_page_square_dpi(page_context)])\\n    page_context.plugin_manager.hook.rasterize_pdf_page(\\n        input_file=input_file,\\n        output_file=output_file,\\n        raster_device='jpeggray',\\n        raster_dpi=canvas_dpi,\\n        pageno=page_context.pageinfo.pageno + 1,\\n        page_dpi=page_dpi,\\n        rotation=0,\\n        filter_vector=False,\\n        stop_on_soft_error=not page_context.options.continue_on_soft_render_error,\\n    )\\n    return output_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `rasterize_preview` function is designed to convert a specific page from an input PDF file into a rasterized image preview. This preview is saved in JPEG format with a resolution of 300 DPI and is intended for quick visual inspection or display purposes.\n\n### Parameters\n- **input_file** (`Path`): The path to the input PDF file containing the page that needs to be rasterized.\n- **page_context** (`PageContext`): An object containing context-specific information about the page to be rasterized, including options and plugins.\n\n### Behavior\n1. **Output File Path**: Determines the output file path for the rasterized preview image using `page_context.get_path('rasterize_preview.jpg')`.\n2. **Resolution Settings**:\n   - Sets `canvas_dpi` to 300 DPI using `Resolution(300.0, 300.0)`, but ensures it does not exceed any other DPI values specified in the `page_context` using `.take_min()`.\n   - Similarly sets `page_dpi` to 300 DPI.\n3. **Plugin Invocation**: Calls a plugin hook (`rasterize_pdf_page`) to perform the actual rasterization of the page. The plugin is passed several parameters:\n   - `input_file`: The path to the input PDF file.\n   - `output_file`: The path where the output JPEG image will be saved.\n   - `raster_device`: Specifies the device type for rasterization, set to 'jpeggray'.\n   - `raster_dpi`: The resolution at which the page should be rasterized, using `canvas_dpi`.\n   - `pageno`: The page number of the input PDF file being processed, incremented by 1.\n   - `page_dpi`: The DPI of the page being rasterized.\n   - `rotation`: Set to 0 degrees (no rotation).\n   - `filter_vector`: Set to False, indicating that vector graphics should not be filtered during rasterization.\n   - `stop_on_soft_error`: Determines whether rendering errors should stop the process or continue, based on the `continue_on_soft_render_error` option in `page_context.options`.\n4. **Return Value**: Returns the path to the saved JPEG image file.\n\n### Edge Cases\n- If the input PDF does not contain a valid page at the specified page number, the plugin hook may raise an error.\n- If any of the DPI settings are out of bounds or cannot be processed by the rasterization device, the function will handle these cases based on the `stop_on_soft_error` option.\n\n### Docstring\n```python\ndef rasterize_preview(input_file: Path, page_context: PageContext) -> Path:\n    \"\"\"\n    Rasterizes a specific page from an input PDF file into a JPEG image preview.\n    \n    Parameters:\n        input_file (Path): The path to the input PDF file containing the page to be rasterized.\n        page_context (PageContext): An object containing context-specific information about the page.\n\n    Returns:\n        Path: The path to the saved JPEG image file representing the rasterized preview.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_completion.py", "func_name": "test_fish", "whole_func_string": "def test_fish():\n    try:\n        proc = run(\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('fish is not installed')", "func_code_string": "def test_fish():\n    try:\n        proc = run(\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('fish is not installed')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_completion.py\\nFunction/Class: test_fish\\n```python\\ndef test_fish():\\n    try:\\n        proc = run(\\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\\n            check=True,\\n            encoding='utf-8',\\n            capture_output=True,\\n        )\\n        assert proc.stderr == '', proc.stderr\\n    except FileNotFoundError:\\n        pytest.xfail('fish is not installed')\\n```\", \"assistant\": \"\"}", "response": "## Purpose of `test_fish`\n\nThe function `test_fish` is designed to test the functionality of a command-line tool named `fish` with specific options and arguments related to PDF completion. The purpose is to ensure that when the `fish` command is executed with the specified parameters, it does not produce any error output (`stderr`).\n\n## Parameters and Behavior\n\n- **Parameters**:\n  - None explicitly defined in the function signature.\n\n- **Behavior**:\n  - The function attempts to execute a subprocess using the `run` function from Python's `subprocess` module.\n  - It runs the `fish` command with the options `-n` followed by a file path (`misc/completion/ocrmypdf.fish`).\n  - The `check=True` parameter ensures that an exception is raised if the command returns a non-zero exit status, indicating failure.\n  - The `encoding='utf-8'` parameter specifies that the output should be captured and decoded using UTF-8 encoding.\n  - The `capture_output=True` parameter instructs `run` to capture both `stdout` and `stderr`.\n\n- **Edge Cases**:\n  - If the `fish` command is not installed on the system, a `FileNotFoundError` will be raised. In this case, the test will mark itself as \"xfail\" (expected to fail) using `pytest.xfail`, indicating that it is acceptable for the test to fail under these conditions.\n\n## Docstring or Summary\n\n```python\ndef test_fish():\n    \"\"\"\n    Test the 'fish' command with specific options and arguments related to PDF completion.\n    Asserts that the stderr output of the command is empty, ensuring no error occurred.\n    If 'fish' is not installed, the test will be marked as expected to fail.\n    \"\"\"\n    try:\n        proc = run(\n            ['fish', '-n', 'misc/completion/ocrmypdf.fish'],\n            check=True,\n            encoding='utf-8',\n            capture_output=True,\n        )\n        assert proc.stderr == '', proc.stderr\n    except FileNotFoundError:\n        pytest.xfail('fish is not installed')\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "setup_plugins", "whole_func_string": "def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_code_string": "def setup_plugins(self):\n        self.add_hookspecs(pluginspec)\n\n                              \n        if self.__builtins:\n            for module in sorted(\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\n            ):\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\n                module = importlib.import_module(name)\n                self.register(module)\n\n                                      \n        try:\n                                                     \n            from multiprocessing.synchronize import SemLock\n\n            del SemLock\n        except ImportError:\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n                                        \n        self.load_setuptools_entrypoints('ocrmypdf')\n\n                                                       \n        for name in self.__plugins:\n            if isinstance(name, Path) or name.endswith('.py'):\n                                    \n                module_name = Path(name).stem\n                spec = importlib.util.spec_from_file_location(module_name, name)\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                spec.loader.exec_module(module)\n            else:\n                                              \n                module = importlib.import_module(name)\n            self.register(module)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_plugin_manager.py\\nFunction/Class: setup_plugins\\n```python\\ndef setup_plugins(self):\\n        self.add_hookspecs(pluginspec)\\n\\n                              \\n        if self.__builtins:\\n            for module in sorted(\\n                pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)\\n            ):\\n                name = f'ocrmypdf.builtin_plugins.{module.name}'\\n                module = importlib.import_module(name)\\n                self.register(module)\\n\\n                                      \\n        try:\\n                                                     \\n            from multiprocessing.synchronize import SemLock\\n\\n            del SemLock\\n        except ImportError:\\n            self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\\n\\n                                        \\n        self.load_setuptools_entrypoints('ocrmypdf')\\n\\n                                                       \\n        for name in self.__plugins:\\n            if isinstance(name, Path) or name.endswith('.py'):\\n                                    \\n                module_name = Path(name).stem\\n                spec = importlib.util.spec_from_file_location(module_name, name)\\n                module = importlib.util.module_from_spec(spec)\\n                sys.modules[module_name] = module\\n                spec.loader.exec_module(module)\\n            else:\\n                                              \\n                module = importlib.import_module(name)\\n            self.register(module)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `setup_plugins` in the file `src/ocrmypdf/_plugin_manager.py` is responsible for setting up and registering various plugins that can extend the functionality of OCRMyPDF. The primary purpose is to ensure that all relevant plugins are loaded, registered, and ready to be used within the OCRMyPDF application.\n\n### High-Level Purpose\nThe high-level purpose of this function is to dynamically discover, import, and register plugins that provide additional features or integrations for OCRMyPDF. This allows OCRMyPDF to be extensible without modifying its core codebase.\n\n### Parameters\n- **self**: The instance of the class containing this method. It should have attributes like `__builtins`, `__plugins`, and methods like `add_hookspecs`, `register`, and `load_setuptools_entrypoints`.\n\n### Behavior\n1. **Hook Specifications Initialization**: The function initializes hook specifications using `add_hookspecs(pluginspec)`. This sets up the framework for plugin hooks.\n2. **Built-in Plugin Registration**: If built-in plugins are enabled (`self.__builtins` is True), it iterates through all modules in the `ocrmypdf.builtin_plugins` package, imports them, and registers them.\n3. **Semaphore Lock Fix**: The function attempts to import and delete a semaphore lock class from the standard library. If this fails (indicating an older Python version without support for the specific feature), it falls back to using a custom module (`ocrmypdf.extra_plugins.semfree`).\n4. **Setuptools Entry Points Loading**: It loads plugins registered via setuptools entry points under the 'ocrmypdf' group.\n5. **File and Module-Based Plugin Registration**: For each plugin specified in `self.__plugins`, the function attempts to import it as either a module or a file. If it's a file, it dynamically imports the module from that file.\n\n### Edge Cases\n- **Missing Built-in Plugins**: If built-in plugins are disabled (`self.__builtins` is False), no built-in plugins will be registered.\n- **Import Errors**: If any plugin import fails (e.g., due to missing dependencies), the function will continue processing other plugins.\n- **Non-existent Entry Points**: If there are no setuptools entry points under 'ocrmypdf', this part of the setup will simply pass.\n- **File-Based Imports**: The function handles both regular Python modules and files, but assumes that file-based plugins are correctly named (i.e., with a `.py` extension).\n\n### Summary\n```python\ndef setup_plugins(self):\n    \"\"\"\n    Sets up and registers various plugins to extend OCRMyPDF functionality.\n\n    This function initializes hook specifications, loads built-in plugins,\n    handles semaphore lock compatibility, loads setuptools entry points,\n    and dynamically imports file-based plugins.\n    \"\"\"\n    self.add_hookspecs(pluginspec)\n\n    if self.__builtins:\n        for module in sorted(pkgutil.iter_modules(ocrmypdf.builtin_plugins.__path__)):\n            name = f'ocrmypdf.builtin_plugins.{module.name}'\n            module = importlib.import_module(name)\n            self.register(module)\n\n    try:\n        del SemLock\n    except ImportError:\n        self.register(importlib.import_module('ocrmypdf.extra_plugins.semfree'))\n\n    self.load_setuptools_entrypoints('ocrmypdf')\n\n    for name in self.__plugins:\n        if isinstance(name, Path) or name.endswith('.py'):\n            module_name = Path(name).stem\n            spec = importlib.util.spec_from_file_location(module_name, name)\n            module = importlib.util.module_from_spec(spec)\n            sys.modules[module_name] = module\n            spec.loader.exec_module(module)\n        else:\n            module = importlib.import_module(name)\n        self.register(module)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_pagesize_consistency", "whole_func_string": "def test_pagesize_consistency(renderer, resources, outpdf):\n    infile = resources / '3small.pdf'\n\n    before_dims = first_page_dimensions(infile)\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--clean' if have_unpaper() else None,\n        '--deskew',\n                                \n        '--clean-final' if have_unpaper() else None,\n        '-k',\n        '--pages',\n        '1',\n    )\n\n    after_dims = first_page_dimensions(outpdf)\n\n    assert isclose(before_dims[0], after_dims[0], rel_tol=1e-4)\n    assert isclose(before_dims[1], after_dims[1], rel_tol=1e-4)", "func_code_string": "def test_pagesize_consistency(renderer, resources, outpdf):\n    infile = resources / '3small.pdf'\n\n    before_dims = first_page_dimensions(infile)\n\n    check_ocrmypdf(\n        infile,\n        outpdf,\n        '--pdf-renderer',\n        renderer,\n        '--clean' if have_unpaper() else None,\n        '--deskew',\n                                \n        '--clean-final' if have_unpaper() else None,\n        '-k',\n        '--pages',\n        '1',\n    )\n\n    after_dims = first_page_dimensions(outpdf)\n\n    assert isclose(before_dims[0], after_dims[0], rel_tol=1e-4)\n    assert isclose(before_dims[1], after_dims[1], rel_tol=1e-4)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_pagesize_consistency\\n```python\\ndef test_pagesize_consistency(renderer, resources, outpdf):\\n    infile = resources / '3small.pdf'\\n\\n    before_dims = first_page_dimensions(infile)\\n\\n    check_ocrmypdf(\\n        infile,\\n        outpdf,\\n        '--pdf-renderer',\\n        renderer,\\n        '--clean' if have_unpaper() else None,\\n        '--deskew',\\n                                \\n        '--clean-final' if have_unpaper() else None,\\n        '-k',\\n        '--pages',\\n        '1',\\n    )\\n\\n    after_dims = first_page_dimensions(outpdf)\\n\\n    assert isclose(before_dims[0], after_dims[0], rel_tol=1e-4)\\n    assert isclose(before_dims[1], after_dims[1], rel_tol=1e-4)\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `test_pagesize_consistency` function is designed to verify that the page size remains consistent after processing a PDF file using OCRMyPDF with specific rendering and cleaning options. This test ensures that the dimensions of the first page do not change during the OCR process, thereby maintaining the integrity of the original document's layout.\n\n### Parameters\n- `renderer`: A string specifying the PDF renderer to be used by OCRMyPDF.\n- `resources`: A path object pointing to a directory containing resource files, such as test PDFs.\n- `outpdf`: A file-like object or a path where the output PDF will be saved after processing.\n\n### Behavior\n1. The function loads a sample PDF file (`'3small.pdf'`) from the `resources` directory.\n2. It retrieves the dimensions of the first page before processing using the `first_page_dimensions` function.\n3. It processes the input PDF using OCRMyPDF with the specified renderer and cleaning options:\n   - `'--pdf-renderer': renderer`: Specifies the PDF renderer to use.\n   - `'--clean' if have_unpaper() else None`: Optionally applies cleaning using Unpaper based on its availability.\n   - `'--deskew'`: Attempts to deskew the pages.\n   - `'--clean-final' if have_unpaper() else None`: Optionally applies final cleaning using Unpaper.\n   - `'-k', '--pages', '1'`: Specifies that only the first page should be processed.\n4. After processing, it retrieves the dimensions of the first page again using `first_page_dimensions`.\n5. It asserts that the dimensions of the first page before and after processing are approximately equal within a relative tolerance of `1e-4`.\n\n### Edge Cases\n- If Unpaper is not available (`have_unpaper()` returns `False`), the `--clean` and `--clean-final` options will be omitted.\n- The test assumes that the input PDF has at least one page. If there are no pages, this test may fail or need to be adjusted.\n\n### Python Docstring\n```python\ndef test_pagesize_consistency(renderer, resources, outpdf):\n    \"\"\"\n    Verifies that the first page's dimensions remain consistent after processing a PDF using OCRMyPDF with specified rendering and cleaning options.\n    \n    Parameters:\n    renderer (str): The PDF renderer to be used by OCRMyPDF.\n    resources (pathlib.Path): Path to the directory containing resource files, such as test PDFs.\n    outpdf (file-like or str): File-like object or path where the output PDF will be saved after processing.\n\n    Raises:\n    AssertionError: If the dimensions of the first page before and after processing differ by more than a relative tolerance of 1e-4.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "run_unpaper", "whole_func_string": "def run_unpaper(\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\n) -> None:\n    args_unpaper = ['unpaper', '-v', '--dpi', str(round(dpi, 6))] + mode_args\n\n    with _setup_unpaper_io(input_file) as (input_png, output_pnm, tmpdir):\n                                                                           \n                             \n                                                                   \n                                                                          \n                                                                \n                                                                            \n                                                                      \n        args_unpaper.extend([os.fspath(input_png), os.fspath(output_pnm)])\n        run(\n            args_unpaper,\n            close_fds=True,\n            check=True,\n            stderr=STDOUT,                                                      \n            stdout=PIPE,                                         \n            cwd=tmpdir,\n            logs_errors_to_stdout=True,\n        )\n        try:\n            with Image.open(output_pnm) as imout:\n                imout.save(output_file, dpi=(dpi, dpi))\n        except OSError as e:\n            raise SubprocessOutputError(\n                \"unpaper: failed to produce the expected output file. \"\n                + \" Called with: \"\n                + str(args_unpaper)\n            ) from e", "func_code_string": "def run_unpaper(\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\n) -> None:\n    args_unpaper = ['unpaper', '-v', '--dpi', str(round(dpi, 6))] + mode_args\n\n    with _setup_unpaper_io(input_file) as (input_png, output_pnm, tmpdir):\n                                                                           \n                             \n                                                                   \n                                                                          \n                                                                \n                                                                            \n                                                                      \n        args_unpaper.extend([os.fspath(input_png), os.fspath(output_pnm)])\n        run(\n            args_unpaper,\n            close_fds=True,\n            check=True,\n            stderr=STDOUT,                                                      \n            stdout=PIPE,                                         \n            cwd=tmpdir,\n            logs_errors_to_stdout=True,\n        )\n        try:\n            with Image.open(output_pnm) as imout:\n                imout.save(output_file, dpi=(dpi, dpi))\n        except OSError as e:\n            raise SubprocessOutputError(\n                \"unpaper: failed to produce the expected output file. \"\n                + \" Called with: \"\n                + str(args_unpaper)\n            ) from e", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/unpaper.py\\nFunction/Class: run_unpaper\\n```python\\ndef run_unpaper(\\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\\n) -> None:\\n    args_unpaper = ['unpaper', '-v', '--dpi', str(round(dpi, 6))] + mode_args\\n\\n    with _setup_unpaper_io(input_file) as (input_png, output_pnm, tmpdir):\\n                                                                           \\n                             \\n                                                                   \\n                                                                          \\n                                                                \\n                                                                            \\n                                                                      \\n        args_unpaper.extend([os.fspath(input_png), os.fspath(output_pnm)])\\n        run(\\n            args_unpaper,\\n            close_fds=True,\\n            check=True,\\n            stderr=STDOUT,                                                      \\n            stdout=PIPE,                                         \\n            cwd=tmpdir,\\n            logs_errors_to_stdout=True,\\n        )\\n        try:\\n            with Image.open(output_pnm) as imout:\\n                imout.save(output_file, dpi=(dpi, dpi))\\n        except OSError as e:\\n            raise SubprocessOutputError(\\n                \\\"unpaper: failed to produce the expected output file. \\\"\\n                + \\\" Called with: \\\"\\n                + str(args_unpaper)\\n            ) from e\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\nThe function `run_unpaper` is designed to process an image file using the `unpaper` tool. It adjusts the image resolution and applies specified modes before saving the processed image.\n\n### Analysis:\n\n1. **Parameters**:\n   - `input_file`: The path to the input image file.\n   - `output_file`: The path where the processed image will be saved.\n   - `dpi`: The desired resolution in dots per inch (DPI).\n   - `mode_args`: A list of additional arguments for the `unpaper` command.\n\n2. **Behavior**:\n   - Converts the input image to a PNG format if it's not already one.\n   - Runs the `unpaper` command with specified arguments, including DPI and mode options.\n   - Captures and handles the output from the `unpaper` command.\n   - Converts the processed PNM file back to the desired format (presumably PDF) and saves it at the specified output path.\n\n3. **Edge Cases**:\n   - If the input image is not a PNG, it may need conversion, which could fail if the image cannot be read.\n   - If `unpaper` fails to produce an expected output file, an error is raised with details about the command called.\n\n### Docstring:\n\n```python\ndef run_unpaper(\n    input_file: Path, output_file: Path, *, dpi: DecFloat, mode_args: list[str]\n) -> None:\n    \"\"\"\n    Processes an image using the unpaper tool.\n\n    Parameters:\n    - input_file (Path): The path to the input image file.\n    - output_file (Path): The path where the processed image will be saved.\n    - dpi (DecFloat): The desired resolution in dots per inch (DPI).\n    - mode_args (list[str]): Additional arguments for the unpaper command.\n\n    Raises:\n    - SubprocessOutputError: If unpaper fails to produce the expected output file.\n\n    Note:\n    This function assumes that the input image is compatible with unpaper. It may need\n    conversion if the original format is not supported.\n    \"\"\"\n```\n\nThis docstring clearly states the purpose of the function, its parameters, and any potential exceptions it might raise, ensuring that users understand how to use the function effectively."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "_gs_version_in_path_key", "whole_func_string": "def _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\n           \n    match = re.search(r'gs[/\\\\]?([0-9.]+)[/\\\\]bin', str(path))\n    if match:\n        try:\n            version_str = match.group(1)\n            version = Version(version_str)\n            return 'gs', version\n        except InvalidVersion:\n            pass\n    return path.name, None", "func_code_string": "def _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\n           \n    match = re.search(r'gs[/\\\\]?([0-9.]+)[/\\\\]bin', str(path))\n    if match:\n        try:\n            version_str = match.group(1)\n            version = Version(version_str)\n            return 'gs', version\n        except InvalidVersion:\n            pass\n    return path.name, None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/subprocess/_windows.py\\nFunction/Class: _gs_version_in_path_key\\n```python\\ndef _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\\n           \\n    match = re.search(r'gs[/\\\\\\\\]?([0-9.]+)[/\\\\\\\\]bin', str(path))\\n    if match:\\n        try:\\n            version_str = match.group(1)\\n            version = Version(version_str)\\n            return 'gs', version\\n        except InvalidVersion:\\n            pass\\n    return path.name, None\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `_gs_version_in_path_key` is designed to extract the Ghostscript (GS) executable name and its version from a given file path. This function helps in identifying GS installations within a system's PATH or other directories where GS executables might be located.\n\n### Parameters\n\n- **path**: A `Path` object representing the directory path that may contain a Ghostscript executable.\n\n### Behavior\n\n1. The function uses a regular expression to search for the pattern `gs[/\\\\\\\\]?([0-9.]+)[/\\\\\\\\]bin` within the string representation of the provided path.\n2. If the regex matches, it extracts the version number as a string.\n3. It attempts to convert this string into a `Version` object using Python's `packaging.version` module.\n4. If successful, the function returns a tuple containing the executable name `'gs'` and the extracted `Version` object.\n5. If the regex does not match or the version string is invalid, it returns a tuple with the path name and `None`.\n\n### Edge Cases\n\n- The function assumes that the Ghostscript executable path follows the pattern `gs[/\\\\\\\\]?([0-9.]+)[/\\\\\\\\]bin`. If this pattern is not found, it falls back to returning the path name without any version information.\n- If the extracted version string is invalid (e.g., contains non-numeric characters), it catches the `InvalidVersion` exception and returns `None` for the version.\n\n### Summary\n\nThe `_gs_version_in_path_key` function parses a given directory path to identify if it contains a Ghostscript executable. It extracts the executable name and its version, returning them as a tuple. If no match is found or the version string is invalid, it provides the path name without a version.\n\n```python\ndef _gs_version_in_path_key(path: Path) -> tuple[str, Version | None]:\n    \"\"\"\n    Extracts the Ghostscript executable name and version from a given directory path.\n    \n    Parameters:\n        path (Path): The directory path that may contain a Ghostscript executable.\n        \n    Returns:\n        tuple[str, Version | None]: A tuple containing the executable name ('gs') and the extracted version,\n                                   or (path.name, None) if no valid match is found.\n    \"\"\"\n    match = re.search(r'gs[/\\\\\\\\]?([0-9.]+)[/\\\\\\\\]bin', str(path))\n    if match:\n        try:\n            version_str = match.group(1)\n            version = Version(version_str)\n            return 'gs', version\n        except InvalidVersion:\n            pass\n    return path.name, None\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_tesseract.py", "func_name": "test_tesseract_log_output", "whole_func_string": "def test_tesseract_log_output(caplog, in_, logged):\n    caplog.set_level(logging.INFO)\n    tesseract.tesseract_log_output(in_)\n    if logged == '':\n        assert caplog.text == ''\n    else:\n        assert logged in caplog.text", "func_code_string": "def test_tesseract_log_output(caplog, in_, logged):\n    caplog.set_level(logging.INFO)\n    tesseract.tesseract_log_output(in_)\n    if logged == '':\n        assert caplog.text == ''\n    else:\n        assert logged in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_tesseract.py\\nFunction/Class: test_tesseract_log_output\\n```python\\ndef test_tesseract_log_output(caplog, in_, logged):\\n    caplog.set_level(logging.INFO)\\n    tesseract.tesseract_log_output(in_)\\n    if logged == '':\\n        assert caplog.text == ''\\n    else:\\n        assert logged in caplog.text\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_tesseract_log_output` is designed to test the logging functionality of a Tesseract OCR tool. It ensures that the correct log messages are captured and asserted based on the expected output.\n\n### Analysis\n\n1. **Parameters**:\n   - `caplog`: A fixture provided by pytest for capturing log messages.\n   - `in_`: The input data passed to the Tesseract OCR function, which is expected to generate a log message.\n   - `logged`: The expected log message or substring that should be present in the captured logs.\n\n2. **Behavior**:\n   - The function sets the logging level to `INFO`.\n   - It then calls the `tesseract.tesseract_log_output` function with the input data `in_`.\n   - Depending on whether the expected log message `logged` is an empty string, it asserts that no log messages are captured or that the expected log message substring is present in the captured logs.\n\n3. **Edge Cases**:\n   - If `logged` is an empty string, the function expects there to be no log output.\n   - If `logged` is not empty, the function expects the specified substring to be present in the log output.\n\n### Python Docstring/Summary\n\n```python\ndef test_tesseract_log_output(caplog, in_, logged):\n    \"\"\"\n    Test the logging functionality of Tesseract OCR.\n\n    Parameters:\n    caplog (pytest fixture): Fixture for capturing log messages.\n    in_ (any): Input data passed to the Tesseract OCR function.\n    logged (str): Expected log message or substring. If empty, no log output is expected.\n\n    Asserts that the correct log message(s) are captured based on the input and expected output.\n    \"\"\"\n    caplog.set_level(logging.INFO)\n    tesseract.tesseract_log_output(in_)\n    if logged == '':\n        assert caplog.text == '', f\"Expected no log output, but got: {caplog.text}\"\n    else:\n        assert logged in caplog.text, f\"Expected log message '{logged}' not found in: {caplog.text}\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "protected_file", "whole_func_string": "def protected_file(outdir):\n    protected_file = outdir / 'protected.pdf'\n    protected_file.touch()\n    protected_file.chmod(0o400)             \n    yield protected_file", "func_code_string": "def protected_file(outdir):\n    protected_file = outdir / 'protected.pdf'\n    protected_file.touch()\n    protected_file.chmod(0o400)             \n    yield protected_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: protected_file\\n```python\\ndef protected_file(outdir):\\n    protected_file = outdir / 'protected.pdf'\\n    protected_file.touch()\\n    protected_file.chmod(0o400)             \\n    yield protected_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `protected_file` function is designed to create a protected PDF file in a specified output directory. This function ensures that the file is created with restricted access permissions, making it unreadable by non-owners.\n\n### Analysis\n\n#### Parameters\n- `outdir`: A `Path` object representing the directory where the protected file should be created.\n\n#### Behavior\n1. The function constructs the path to the protected PDF file using the provided output directory and appends `'protected.pdf'`.\n2. It creates the file at the specified path using the `touch()` method.\n3. It sets the file permissions to 0o400, which restricts read access to the owner only.\n4. The function yields the created file object.\n\n#### Edge Cases\n- If the output directory does not exist, it will raise a `FileNotFoundError`.\n- If there is an issue creating or modifying the file permissions, it may raise an appropriate exception (e.g., `PermissionError`).\n\n### Python Docstring\n\n```python\ndef protected_file(outdir):\n    \"\"\"\n    Create and protect a PDF file in the specified output directory.\n\n    Args:\n        outdir (Path): The directory where the protected file should be created.\n\n    Yields:\n        Path: A Path object representing the created protected PDF file.\n\n    Raises:\n        FileNotFoundError: If the output directory does not exist.\n        PermissionError: If there is an issue setting file permissions.\n    \"\"\"\n    protected_file = outdir / 'protected.pdf'\n    protected_file.touch()\n    protected_file.chmod(0o400)\n    yield protected_file\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_very_high_dpi", "whole_func_string": "def test_very_high_dpi(resources, outpdf):\n                                                                 \n    check_ocrmypdf(\n        resources / '2400dpi.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(outpdf)\n\n    image = pdfinfo[0].images[0]\n    assert isclose(image.dpi.x, image.dpi.y)\n    assert isclose(image.dpi.x, 2400)", "func_code_string": "def test_very_high_dpi(resources, outpdf):\n                                                                 \n    check_ocrmypdf(\n        resources / '2400dpi.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(outpdf)\n\n    image = pdfinfo[0].images[0]\n    assert isclose(image.dpi.x, image.dpi.y)\n    assert isclose(image.dpi.x, 2400)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_very_high_dpi\\n```python\\ndef test_very_high_dpi(resources, outpdf):\\n                                                                 \\n    check_ocrmypdf(\\n        resources / '2400dpi.pdf',\\n        outpdf,\\n        '--plugin',\\n        'tests/plugins/tesseract_cache.py',\\n    )\\n    pdfinfo = PdfInfo(outpdf)\\n\\n    image = pdfinfo[0].images[0]\\n    assert isclose(image.dpi.x, image.dpi.y)\\n    assert isclose(image.dpi.x, 2400)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\nThe purpose of the `test_very_high_dpi` function is to verify that a PDF processed with OCRmypdf at very high DPI (2400 dpi) maintains consistent and correct DPI values for its images.\n\n### Analysis of Parameters:\n- **resources**: A path object pointing to a directory containing resources, including the input PDF file `2400dpi.pdf`.\n- **outpdf**: A path object where the output PDF will be saved after processing by OCRmypdf.\n\n### Behavior:\n1. The function calls `check_ocrmypdf` with the input PDF (`resources / '2400dpi.pdf'`) and the output file path (`outpdf`), along with a plugin parameter to use a specific OCRmyPDF plugin (`tests/plugins/tesseract_cache.py`). This effectively processes the input PDF using OCRmyPDF.\n2. After processing, it creates an instance of `PdfInfo` to extract information about the processed PDF (`outpdf`).\n3. It retrieves the first page's images and checks that both the horizontal (`dpi.x`) and vertical (`dpi.y`) DPI values are consistent and equal to 2400 dpi.\n4. The function uses assertions to validate these conditions.\n\n### Edge Cases:\n- The input PDF must contain at least one image with a DPI of 2400 to pass the assertions.\n- If the OCRmyPDF plugin does not correctly handle high DPI images, the DPI values may not be preserved, causing the assertions to fail.\n\n### Python Docstring:\n\n```python\ndef test_very_high_dpi(resources, outpdf):\n    \"\"\"\n    Verify that processing a PDF at very high DPI (2400 dpi) with OCRmypdf maintains consistent image DPI values.\n\n    Parameters:\n        resources (pathlib.Path): Path to the directory containing the input PDF '2400dpi.pdf'.\n        outpdf (pathlib.Path): Path where the processed PDF will be saved.\n\n    Raises:\n        AssertionError: If the DPI of the images in the output PDF is not consistent or does not match the expected 2400 dpi.\n    \"\"\"\n    check_ocrmypdf(\n        resources / '2400dpi.pdf',\n        outpdf,\n        '--plugin',\n        'tests/plugins/tesseract_cache.py',\n    )\n    pdfinfo = PdfInfo(outpdf)\n\n    image = pdfinfo[0].images[0]\n    assert isclose(image.dpi.x, image.dpi.y)\n    assert isclose(image.dpi.x, 2400)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "run_ocrmypdf_api", "whole_func_string": "def run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\n           \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n\n    api.check_options(options, plugin_manager)\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)", "func_code_string": "def run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\n           \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n\n    api.check_options(options, plugin_manager)\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/conftest.py\\nFunction/Class: run_ocrmypdf_api\\n```python\\ndef run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\\n           \\n    api_args = [str(input_file), str(output_file)] + [\\n        str(arg) for arg in args if arg is not None\\n    ]\\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\\n\\n    api.check_options(options, plugin_manager)\\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `run_ocrmypdf_api` function is designed to interface with an OCR (Optical Character Recognition) API using the provided arguments. It processes the input file and saves the output to a specified location while handling various options and plugins.\n\n### Parameters\n\n- **input_file** (`Path`): The path to the input file that needs to be processed by OCR.\n- **output_file** (`Path`): The path where the output file with recognized text will be saved.\n- ***args**: Additional arguments that can be passed to configure the OCR process, such as options for language, resolution, or other processing settings. If an argument is `None`, it is ignored.\n\n### Behavior\n\n1. **Argument Preparation**:\n   - The function constructs a list of arguments (`api_args`) by converting the input and output file paths to strings.\n   - It appends each non-`None` argument from `*args` to the `api_args` list, ensuring that only valid options are passed to the OCR API.\n\n2. **Option Parsing**:\n   - The function calls `get_parser_options_plugins` with the constructed arguments (`api_args`) to parse these options and initialize a parser, options object, and plugin manager.\n\n3. **Option Validation**:\n   - It validates the parsed options against the available plugins using `api.check_options`.\n\n4. **Pipeline Execution**:\n   - Finally, it runs the OCR pipeline using `api.run_pipeline_cli` with the validated options and plugin manager, returning the exit code of the operation.\n\n### Edge Cases\n\n- If any of the input or output file paths are invalid (`Path` objects that do not exist), this could lead to errors during file operations.\n- If `*args` contains `None`, it is simply ignored without raising an error.\n- If there are syntax errors in the additional arguments passed, they might be treated as unrecognized options, causing the OCR process to fail or behave unexpectedly.\n\n### Python Docstring\n\n```python\ndef run_ocrmypdf_api(input_file: Path, output_file: Path, *args) -> ExitCode:\n    \"\"\"\n    Runs the OCRMyPDF API with the specified input and output files and additional arguments.\n    \n    Parameters:\n        input_file (Path): The path to the input file that needs OCR processing.\n        output_file (Path): The path where the output file with OCR text will be saved.\n        *args: Additional arguments to configure the OCR process. Non-None arguments are passed to the OCR API.\n        \n    Returns:\n        ExitCode: The exit code of the OCR pipeline execution.\n    \n    Raises:\n        FileNotFoundError: If input_file or output_file does not exist.\n        ValueError: If any of the additional arguments contain invalid options.\n    \"\"\"\n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n    \n    api.check_options(options, plugin_manager)\n    return api.run_pipeline_cli(options, plugin_manager=plugin_manager)\n```\n\nThis docstring provides a clear description of the function's purpose, parameters, return value, and potential exceptions that can be raised."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/gs_raster_soft_error.py", "func_name": "fail_if_stoponerror", "whole_func_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run(args, **kwargs)", "func_code_string": "def fail_if_stoponerror(args, **kwargs):\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run(args, **kwargs)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/gs_raster_soft_error.py\\nFunction/Class: fail_if_stoponerror\\n```python\\ndef fail_if_stoponerror(args, **kwargs):\\n    if '-dPDFSTOPONERROR' in args:\\n        raise CalledProcessError(1, 'gs', output=b\\\"\\\", stderr=b\\\"PDF STOP ON ERROR\\\")\\n    return run(args, **kwargs)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**Purpose**: The function `fail_if_stoponerror` is designed to intercept the invocation of a command-line tool (`gs`, likely Ghostscript) and raise an exception if the `-dPDFSTOPONERROR` option is present in the arguments. This effectively prevents the execution from continuing on error when processing PDF files.\n\n### Parameter Analysis\n\n- **args** (list): A list of strings representing the command-line arguments to be passed to the `gs` tool.\n- **kwargs** (dict): Additional keyword arguments that can be passed to the `run` function, typically used for configuring subprocess behavior.\n\n### Behavior\n\n1. The function checks if the string `-dPDFSTOPONERROR` is present in the `args` list.\n2. If the option is found, it raises a `CalledProcessError` with an exit code of 1, a command name of `'gs'`, and specific error messages indicating that PDF processing stopped on encountering an error.\n3. If the option is not found, the function proceeds to run the command using the provided arguments and keyword arguments.\n\n### Edge Cases\n\n- **No `-dPDFSTOPONERROR` Option**: The function will pass through as expected, allowing the `gs` tool to execute normally.\n- **Multiple Instances of `-dPDFSTOPONERROR`**: Only the presence of the option is checked. If multiple instances exist, it will still raise an error.\n- **Empty or Invalid Arguments**: The function assumes that `args` and `kwargs` are valid inputs suitable for passing to a subprocess.\n\n### Python Docstring\n\n```python\ndef fail_if_stoponerror(args, **kwargs):\n    \"\"\"\n    Intercepts the invocation of the 'gs' tool and raises an exception if the '-dPDFSTOPONERROR'\n    option is present in the arguments. This prevents the execution from continuing on error when processing PDF files.\n\n    :param args: List of strings representing the command-line arguments to be passed to the 'gs' tool.\n    :param kwargs: Additional keyword arguments for configuring subprocess behavior.\n    :return: The result of running the command using the provided arguments and keyword arguments.\n    :raises CalledProcessError: If the '-dPDFSTOPONERROR' option is found, raising an error with a specific message.\n    \"\"\"\n    if '-dPDFSTOPONERROR' in args:\n        raise CalledProcessError(1, 'gs', output=b\"\", stderr=b\"PDF STOP ON ERROR\")\n    return run(args, **kwargs)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "creator_tag", "whole_func_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"", "func_code_string": "def creator_tag(options):\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\n        return f\"NO-OP {tag} {NoopOcrEngine.version()}\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_noop.py\\nFunction/Class: creator_tag\\n```python\\ndef creator_tag(options):\\n        tag = '-PDF' if options.pdf_renderer == 'sandwich' else '-hOCR'\\n        return f\\\"NO-OP {tag} {NoopOcrEngine.version()}\\\"\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `creator_tag` function is designed to generate a tag string for an OCR engine based on the provided options. This tag helps in identifying the type of OCR operation being performed and includes information about the OCR engine version.\n\n### Parameters\n- `options`: A dictionary containing configuration options, including `pdf_renderer`.\n\n### Behavior\n1. **PDF Renderer Check**: The function checks if the `pdf_renderer` option is set to `'sandwich'`.\n2. **Tag Assignment**:\n   - If `pdf_renderer` is `'sandwich'`, it assigns `'-PDF'` to the variable `tag`.\n   - Otherwise, it assigns `'-hOCR'` to `tag`.\n3. **Return Statement**: The function returns a formatted string that includes:\n   - The prefix `\"NO-OP \"`.\n   - The tag (`'-PDF'` or `'-hOCR'`).\n   - The version of the OCR engine obtained from `NoopOcrEngine.version()`.\n\n### Edge Cases\n- If `pdf_renderer` is not `'sandwich'`, the function will use `'-hOCR'` as the default tag.\n- Ensure that `NoopOcrEngine.version()` returns a valid version string to avoid issues in the output.\n\n### Python Docstring\n```python\ndef creator_tag(options):\n    \"\"\"\n    Generate a tag string for an OCR engine based on the provided options.\n\n    Parameters:\n    - options (dict): A dictionary containing configuration options, including `pdf_renderer`.\n\n    Returns:\n    str: A formatted string indicating the type of OCR operation and the OCR engine version.\n    \"\"\"\n    tag = '-PDF' if options.get('pdf_renderer') == 'sandwich' else '-hOCR'\n    return f\"NO-OP {tag} {NoopOcrEngine.version()}\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "__init__", "whole_func_string": "def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False", "func_code_string": "def __init__(self, *args, **kwargs):\n                                    \n        super().__init__(*args, **kwargs)\n        self._api_mode = False", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/cli.py\\nFunction/Class: __init__\\n```python\\ndef __init__(self, *args, **kwargs):\\n                                    \\n        super().__init__(*args, **kwargs)\\n        self._api_mode = False\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The `__init__` method is the constructor for a class that initializes an object and sets up any necessary initial conditions or default values.\n\n2. **Analysis of Parameters and Behavior**:\n   - **Parameters**:\n     - `*args`: Allows passing a variable number of positional arguments to the superclass constructor.\n     - `**kwargs`: Allows passing a variable number of keyword arguments to the superclass constructor.\n   - **Behavior**:\n     - The method calls the `__init__` method of the superclass using `super().__init__(*args, **kwargs)` to ensure that any initialization code in the superclass is executed.\n     - It then sets an instance variable `_api_mode` to `False`, indicating that the object is not operating in API mode initially.\n\n3. **Edge Cases**:\n   - The method does not handle any specific edge cases related to its parameters or behavior.\n\n### Python Docstring\n\n```python\ndef __init__(self, *args, **kwargs):\n    \"\"\"\n    Initialize the class instance and set up initial conditions.\n    \n    Parameters:\n    *args (tuple): Variable length argument list passed to the superclass constructor.\n    **kwargs (dict): Variable keyword arguments passed to the superclass constructor.\n    \n    The `_api_mode` attribute is initialized to `False`.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._api_mode = False\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_hocr_to_pdf_api", "whole_func_string": "def test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'ccitt.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\n    mangled = hocr.replace('the', 'hocr')\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\n\n    text = extract_text(outpdf)\n    assert 'hocr' in text and 'the' not in text", "func_code_string": "def test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'ccitt.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\n    mangled = hocr.replace('the', 'hocr')\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\n\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\n\n    text = extract_text(outpdf)\n    assert 'hocr' in text and 'the' not in text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_api.py\\nFunction/Class: test_hocr_to_pdf_api\\n```python\\ndef test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\\n    ocrmypdf.api._pdf_to_hocr(\\n        resources / 'ccitt.pdf',\\n        outdir,\\n        language='eng',\\n        skip_text=True,\\n        plugins=['tests/plugins/tesseract_cache.py'],\\n    )\\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\\n    mangled = hocr.replace('the', 'hocr')\\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\\n\\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\\n\\n    text = extract_text(outpdf)\\n    assert 'hocr' in text and 'the' not in text\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_hocr_to_pdf_api` is designed to test the OCR (Optical Character Recognition) process from PDF to HOCR and then from HOCR back to PDF. It ensures that the OCR engine correctly extracts text and performs basic string replacements before converting it back to a PDF.\n\n### Parameters Analysis\n\n- **resources (Path)**: A path to a directory containing resource files, specifically a PDF named `ccitt.pdf`.\n- **outdir (Path)**: The output directory where intermediate HOCR files will be saved.\n- **outpdf (Path)**: The final output PDF file after processing.\n\n### Behavior and Edge Cases\n\n1. **OCR Conversion**:\n   - Converts the input PDF to an HOCR file using `ocrmypdf.api._pdf_to_hocr`.\n   - Verifies that the HOCR file is created in the specified output directory.\n   - Modifies the HOCR content by replacing occurrences of 'the' with 'hocr'.\n   - Ensures that the modified HOCR file contains the replacement text.\n\n2. **PDF Conversion**:\n   - Converts the HOCR file back to a PDF using `ocrmypdf.api._hocr_to_ocr_pdf`.\n   - Verifies that the final output PDF contains the modified text ('hocr') and does not contain the original text ('the').\n\n### Python Docstring\n\n```python\ndef test_hocr_to_pdf_api(resources: Path, outdir: Path, outpdf: Path):\n    \"\"\"\n    Test OCR conversion from PDF to HOCR and then back to PDF.\n\n    Parameters:\n    resources (Path): Directory containing resource files.\n    outdir (Path): Output directory for intermediate files.\n    outpdf (Path): Final output PDF file after processing.\n\n    Edge Cases:\n    - Ensures that the OCR process correctly extracts text.\n    - Verifies that string replacements in HOCR content are preserved during conversion.\n    \"\"\"\n    # Convert PDF to HOCR\n    ocrmypdf.api._pdf_to_hocr(\n        resources / 'ccitt.pdf',\n        outdir,\n        language='eng',\n        skip_text=True,\n        plugins=['tests/plugins/tesseract_cache.py'],\n    )\n    assert (outdir / '000001_ocr_hocr.hocr').exists()\n\n    # Modify HOCR content\n    hocr = (outdir / '000001_ocr_hocr.hocr').read_text(encoding='utf-8')\n    mangled = hocr.replace('the', 'hocr')\n    (outdir / '000001_ocr_hocr.hocr').write_text(mangled, encoding='utf-8')\n\n    # Convert HOCR back to PDF\n    ocrmypdf.api._hocr_to_ocr_pdf(outdir, outpdf, optimize=0)\n\n    # Verify final output PDF contains the modified text\n    text = extract_text(outpdf)\n    assert 'hocr' in text and 'the' not in text\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "test_page_rotate_tag", "whole_func_string": "def test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\n                                                                            \n                                                                               \n    test = make_rotate_test(\n        resources / 'crom.png', outdir, 'test', -page_rotate_angle, page_rotate_angle\n    )\n    out = test.with_suffix('.out.pdf')\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n    )\n    assert exitcode == 0, caplog.text\n\n    def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )\n\n    test_text = pdftotext(out)\n    assert 'is a' in test_text, test_text", "func_code_string": "def test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\n                                                                            \n                                                                               \n    test = make_rotate_test(\n        resources / 'crom.png', outdir, 'test', -page_rotate_angle, page_rotate_angle\n    )\n    out = test.with_suffix('.out.pdf')\n    exitcode = run_ocrmypdf_api(\n        test,\n        out,\n        '-O0',\n    )\n    assert exitcode == 0, caplog.text\n\n    def pdftotext(filename):\n        return (\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\n            .stdout.strip()\n            .decode('utf-8')\n        )\n\n    test_text = pdftotext(out)\n    assert 'is a' in test_text, test_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_rotation.py\\nFunction/Class: test_page_rotate_tag\\n```python\\ndef test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\\n                                                                            \\n                                                                               \\n    test = make_rotate_test(\\n        resources / 'crom.png', outdir, 'test', -page_rotate_angle, page_rotate_angle\\n    )\\n    out = test.with_suffix('.out.pdf')\\n    exitcode = run_ocrmypdf_api(\\n        test,\\n        out,\\n        '-O0',\\n    )\\n    assert exitcode == 0, caplog.text\\n\\n    def pdftotext(filename):\\n        return (\\n            run(['pdftotext', '-enc', 'UTF-8', filename, '-'], capture_output=True)\\n            .stdout.strip()\\n            .decode('utf-8')\\n        )\\n\\n    test_text = pdftotext(out)\\n    assert 'is a' in test_text, test_text\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `test_page_rotate_tag` function is designed to test the OCRMyPDF functionality for rotating pages in PDF files. Specifically, it checks whether the rotated text content remains intact after rotation and OCR processing.\n\n### Parameters\n\n- **page_rotate_angle**: The angle (in degrees) by which the page should be rotated.\n- **resources**: A path to a directory containing resource files used for testing.\n- **outdir**: A directory where output PDFs will be saved.\n- **caplog**: A logging object for capturing log messages.\n\n### Behavior\n\n1. **Test Setup**:\n   - The function sets up an OCR test using the `make_rotate_test` function, which creates a PDF with the specified rotation angle and saves it to the `outdir`.\n   - It then specifies the output file path by appending `.out.pdf` to the test file name.\n\n2. **OCR Processing**:\n   - The OCRMyPDF API is called with the test file as input and the output file as the target.\n   - The `-O0` option is used, which means no optimization is applied during the OCR process.\n\n3. **Validation**:\n   - The function checks that the OCRMyPDF process exits successfully (exit code 0).\n   - It defines a helper function `pdftotext` to extract text from the output PDF using `pdftotext`.\n   - Finally, it asserts that the keyword \"is a\" is present in the extracted text, ensuring that the rotation and OCR processes did not alter the content.\n\n### Edge Cases\n\n- **Invalid Rotation Angle**: If `page_rotate_angle` is outside the valid range (0 to 360 degrees), behavior is not explicitly defined. The function should handle such cases gracefully.\n- **Non-PDF Files**: If the input file in `resources` is not a PDF, `make_rotate_test` and subsequent functions may fail.\n- **Insufficient Permissions**: If the output directory (`outdir`) does not have write permissions, the test will fail.\n\n### Docstring\n\n```python\ndef test_page_rotate_tag(page_rotate_angle, resources, outdir, caplog):\n    \"\"\"\n    Test OCRMyPDF functionality for rotating pages in PDF files and ensuring text content remains intact.\n\n    Parameters:\n    - page_rotate_angle: The angle (in degrees) by which the page should be rotated.\n    - resources: A path to a directory containing resource files used for testing.\n    - outdir: A directory where output PDFs will be saved.\n    - caplog: A logging object for capturing log messages.\n\n    Raises:\n    - AssertionError: If OCRMyPDF fails to process the file or if the rotated text is altered.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "calculate_raster_dpi", "whole_func_string": "def calculate_raster_dpi(page_context: PageContext):\n                                              \n                                                                          \n                             \n    image_dpi = calculate_image_dpi(page_context)\n    dpi_profile = page_context.pageinfo.page_dpi_profile()\n    canvas_dpi = get_canvas_square_dpi(page_context, image_dpi)\n    page_dpi = get_page_square_dpi(page_context, image_dpi)\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        log.warning(\n            \"Weighted average image DPI is %0.1f, max DPI is %0.1f. \"\n            \"The discrepancy may indicate a high detail region on this page, \"\n            \"but could also indicate a problem with the input PDF file. \"\n            \"Page image will be rendered at %0.1f DPI.\",\n            dpi_profile.weighted_dpi,\n            dpi_profile.max_dpi,\n            canvas_dpi.to_scalar(),\n        )\n    return canvas_dpi, page_dpi", "func_code_string": "def calculate_raster_dpi(page_context: PageContext):\n                                              \n                                                                          \n                             \n    image_dpi = calculate_image_dpi(page_context)\n    dpi_profile = page_context.pageinfo.page_dpi_profile()\n    canvas_dpi = get_canvas_square_dpi(page_context, image_dpi)\n    page_dpi = get_page_square_dpi(page_context, image_dpi)\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\n        log.warning(\n            \"Weighted average image DPI is %0.1f, max DPI is %0.1f. \"\n            \"The discrepancy may indicate a high detail region on this page, \"\n            \"but could also indicate a problem with the input PDF file. \"\n            \"Page image will be rendered at %0.1f DPI.\",\n            dpi_profile.weighted_dpi,\n            dpi_profile.max_dpi,\n            canvas_dpi.to_scalar(),\n        )\n    return canvas_dpi, page_dpi", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: calculate_raster_dpi\\n```python\\ndef calculate_raster_dpi(page_context: PageContext):\\n                                              \\n                                                                          \\n                             \\n    image_dpi = calculate_image_dpi(page_context)\\n    dpi_profile = page_context.pageinfo.page_dpi_profile()\\n    canvas_dpi = get_canvas_square_dpi(page_context, image_dpi)\\n    page_dpi = get_page_square_dpi(page_context, image_dpi)\\n    if dpi_profile and dpi_profile.average_to_max_dpi_ratio < 0.8:\\n        log.warning(\\n            \\\"Weighted average image DPI is %0.1f, max DPI is %0.1f. \\\"\\n            \\\"The discrepancy may indicate a high detail region on this page, \\\"\\n            \\\"but could also indicate a problem with the input PDF file. \\\"\\n            \\\"Page image will be rendered at %0.1f DPI.\\\",\\n            dpi_profile.weighted_dpi,\\n            dpi_profile.max_dpi,\\n            canvas_dpi.to_scalar(),\\n        )\\n    return canvas_dpi, page_dpi\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `calculate_raster_dpi` function calculates the raster DPI (dots per inch) for a given page context. This involves determining both the canvas DPI and the page DPI based on various factors such as the image DPI and any specific DPI profiles associated with the page.\n\n### Parameters\n\n- **page_context**: An instance of `PageContext`, which contains all necessary information about the current page, including its images and DPI settings.\n\n### Behavior\n\n1. **Image DPI Calculation**: The function starts by calculating the DPI of the images on the page using the `calculate_image_dpi` function.\n2. **DPI Profile Retrieval**: It retrieves a DPI profile for the page from the `pageinfo` attribute of `page_context`.\n3. **Canvas DPI Calculation**: Based on the image DPI and other factors, it calculates the canvas DPI using the `get_canvas_square_dpi` function.\n4. **Page DPI Calculation**: Similarly, it calculates the page DPI using the `get_page_square_dpi` function.\n5. **DPI Discrepancy Check**: If a DPI profile is present and the ratio of the weighted average DPI to the maximum DPI is less than 0.8, it logs a warning message indicating potential issues with the image quality or PDF file.\n6. **Return Values**: The function returns both the canvas DPI and the page DPI.\n\n### Edge Cases\n\n- If no DPI profile is present (`dpi_profile` is `None`), the function does not log any warnings.\n- If the discrepancy between the average and maximum DPI exceeds 0.8, a warning message is logged, indicating that either there is high detail on the page or an issue with the input PDF file.\n\n### Docstring\n\n```python\ndef calculate_raster_dpi(page_context: PageContext) -> Tuple[DPI, DPI]:\n    \"\"\"\n    Calculates the raster DPI for a given page context.\n\n    Parameters:\n        page_context (PageContext): The current page context containing image and DPI information.\n\n    Returns:\n        Tuple[DPI, DPI]: A tuple containing the canvas DPI and the page DPI.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_metadata.py", "func_name": "test_unset_metadata", "whole_func_string": "def test_unset_metadata(output_type, field, resources, outpdf, caplog):\n    input_file = resources / 'meta.pdf'\n\n                                                       \n    meta = {\n        'title': b'NFY5f7Ft2DWMkxLhXwxvFf7eWR2KeK3vEDcd',\n        'author': b'yXaryipxyRk9dVjWjSSaVaNCKeLRgEVzPRMp',\n        'subject': b't49vimctvnuH7ZeAjAkv52ACvWFjcnm5MPJr',\n        'keywords': b's9EeALwUg7urA7fnnhm5EtUyC54sW2WPUzqh',\n    }\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        f'--{field}',\n        '',\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n                                                                        \n                                                                            \n                                                                     \n                                                                       \n                                                                            \n                                                                          \n                 \n    with open(input_file, 'rb') as before, open(outpdf, 'rb') as after:\n        before_data = before.read()\n        after_data = after.read()\n\n    for k, v in meta.items():\n        assert v in before_data\n        if k == field:\n            assert v not in after_data\n        else:\n            assert v in after_data", "func_code_string": "def test_unset_metadata(output_type, field, resources, outpdf, caplog):\n    input_file = resources / 'meta.pdf'\n\n                                                       \n    meta = {\n        'title': b'NFY5f7Ft2DWMkxLhXwxvFf7eWR2KeK3vEDcd',\n        'author': b'yXaryipxyRk9dVjWjSSaVaNCKeLRgEVzPRMp',\n        'subject': b't49vimctvnuH7ZeAjAkv52ACvWFjcnm5MPJr',\n        'keywords': b's9EeALwUg7urA7fnnhm5EtUyC54sW2WPUzqh',\n    }\n\n    exitcode = run_ocrmypdf_api(\n        input_file,\n        outpdf,\n        f'--{field}',\n        '',\n        '--output-type',\n        output_type,\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n\n    assert exitcode == ExitCode.ok, caplog.text\n\n                                                                        \n                                                                            \n                                                                     \n                                                                       \n                                                                            \n                                                                          \n                 \n    with open(input_file, 'rb') as before, open(outpdf, 'rb') as after:\n        before_data = before.read()\n        after_data = after.read()\n\n    for k, v in meta.items():\n        assert v in before_data\n        if k == field:\n            assert v not in after_data\n        else:\n            assert v in after_data", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_metadata.py\\nFunction/Class: test_unset_metadata\\n```python\\ndef test_unset_metadata(output_type, field, resources, outpdf, caplog):\\n    input_file = resources / 'meta.pdf'\\n\\n                                                       \\n    meta = {\\n        'title': b'NFY5f7Ft2DWMkxLhXwxvFf7eWR2KeK3vEDcd',\\n        'author': b'yXaryipxyRk9dVjWjSSaVaNCKeLRgEVzPRMp',\\n        'subject': b't49vimctvnuH7ZeAjAkv52ACvWFjcnm5MPJr',\\n        'keywords': b's9EeALwUg7urA7fnnhm5EtUyC54sW2WPUzqh',\\n    }\\n\\n    exitcode = run_ocrmypdf_api(\\n        input_file,\\n        outpdf,\\n        f'--{field}',\\n        '',\\n        '--output-type',\\n        output_type,\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n\\n    assert exitcode == ExitCode.ok, caplog.text\\n\\n                                                                        \\n                                                                            \\n                                                                     \\n                                                                       \\n                                                                            \\n                                                                          \\n                 \\n    with open(input_file, 'rb') as before, open(outpdf, 'rb') as after:\\n        before_data = before.read()\\n        after_data = after.read()\\n\\n    for k, v in meta.items():\\n        assert v in before_data\\n        if k == field:\\n            assert v not in after_data\\n        else:\\n            assert v in after_data\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\n**Purpose:**\nThe `test_unset_metadata` function is designed to test the behavior of unsetting a specific metadata field from a PDF file using OCRmyPDF. The function aims to ensure that when a particular metadata field (like title, author, subject, keywords) is unset, it no longer appears in the PDF's metadata while other fields remain unchanged.\n\n**Parameters:**\n- `output_type`: A string specifying the type of output format (e.g., 'pdf', 'png').\n- `field`: The specific metadata field to be unset.\n- `resources`: A Path object representing the directory containing test resources, including an input PDF file named 'meta.pdf'.\n- `outpdf`: A Path object where the modified PDF will be saved.\n- `caplog`: A fixture used for capturing log messages.\n\n**Behavior:**\n1. The function reads a sample PDF ('meta.pdf') with predefined metadata fields (title, author, subject, keywords).\n2. It calls the `run_ocrmypdf_api` function to process the input PDF, unsetting the specified metadata field using the `--{field}` option.\n3. After processing, it asserts that:\n   - The exit code from `run_ocrmypdf_api` is `ExitCode.ok`, indicating successful execution.\n   - The metadata fields are present in both the original and modified files.\n   - If the unset field matches the specified `field`, it ensures that this field is no longer present in the modified file.\n   - All other metadata fields remain unchanged.\n\n**Edge Cases:**\n- The function assumes that all specified metadata fields are initially present in the input PDF. If any of these fields are not set, the test may fail or behave unpredictably.\n- Ensure that `run_ocrmypdf_api` is robust and handles edge cases such as invalid field names or other unexpected inputs.\n\n**Docstring:**\n```python\ndef test_unset_metadata(output_type, field, resources, outpdf, caplog):\n    \"\"\"\n    Test unsetting a specific metadata field from a PDF file using OCRmyPDF.\n\n    Parameters:\n    - output_type (str): The type of output format (e.g., 'pdf', 'png').\n    - field (str): The specific metadata field to be unset.\n    - resources (Path): Directory containing test resources, including the input PDF 'meta.pdf'.\n    - outpdf (Path): Path where the modified PDF will be saved.\n    - caplog (fixture): Fixture for capturing log messages.\n\n    The function asserts that:\n    - The exit code from `run_ocrmypdf_api` is `ExitCode.ok`.\n    - All metadata fields are present in both the original and modified files.\n    - If the unset field matches the specified `field`, it ensures that this field is no longer present in the modified file.\n    - All other metadata fields remain unchanged.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_image_too_big", "whole_func_string": "def test_unpaper_image_too_big(resources, outdir, caplog):\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\n        infile = resources / 'crom.png'\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\n\n        assert any(\n            'too large for cleaning' in rec.message\n            for rec in caplog.get_records('call')\n            if rec.levelno == logging.WARNING\n        )", "func_code_string": "def test_unpaper_image_too_big(resources, outdir, caplog):\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\n        infile = resources / 'crom.png'\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\n\n        assert any(\n            'too large for cleaning' in rec.message\n            for rec in caplog.get_records('call')\n            if rec.levelno == logging.WARNING\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_unpaper.py\\nFunction/Class: test_unpaper_image_too_big\\n```python\\ndef test_unpaper_image_too_big(resources, outdir, caplog):\\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\\n        infile = resources / 'crom.png'\\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\\n\\n        assert any(\\n            'too large for cleaning' in rec.message\\n            for rec in caplog.get_records('call')\\n            if rec.levelno == logging.WARNING\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The function `test_unpaper_image_too_big` is designed to test the behavior of an image cleaning tool when it encounters an image that exceeds a specified pixel limit.\n\n2. **Parameter Analysis**:\n   - `resources`: A directory containing various resource files used in the tests.\n   - `outdir`: A directory where output files will be saved.\n   - `caplog`: A fixture provided by pytest to capture log messages.\n\n3. **Behavior and Edge Cases**:\n   - The function uses a mock to set the `UNPAPER_IMAGE_PIXEL_LIMIT` to 42 pixels.\n   - It reads an image file named 'crom.png' from the `resources` directory.\n   - The function attempts to clean the image using the `unpaper.clean` method with a DPI of 300.\n   - An assertion checks if the original file is returned, indicating that no cleaning occurred due to the pixel limit.\n   - A log message warning about the image being too large for cleaning is captured and verified.\n\n4. **Python Docstring or Summary**:\n```python\ndef test_unpaper_image_too_big(resources, outdir, caplog):\n    \"\"\"\n    Test the behavior of unpaper when an input image exceeds the pixel limit.\n\n    Parameters:\n    resources (pathlib.Path): Directory containing resource files.\n    outdir (pathlib.Path): Directory for output files.\n    caplog (pytest.LogCaptureFixture): Fixture to capture log messages.\n\n    Mocks the UNPAPER_IMAGE_PIXEL_LIMIT to 42 pixels, reads 'crom.png', and asserts\n    that the original file is returned without cleaning. Verifies a warning log message\n    indicating the image is too large.\n    \"\"\"\n    with patch('ocrmypdf._exec.unpaper.UNPAPER_IMAGE_PIXEL_LIMIT', 42):\n        infile = resources / 'crom.png'\n        unpaper.clean(infile, outdir / 'out.png', dpi=300) == infile\n\n        assert any(\n            'too large for cleaning' in rec.message\n            for rec in caplog.get_records('call')\n            if rec.levelno == logging.WARNING\n        )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/ghostscript.py", "func_name": "DuplicateFilter", "whole_func_string": "class DuplicateFilter(logging.Filter):\n           \n\n    def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0\n\n    def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_code_string": "class DuplicateFilter(logging.Filter):\n           \n\n    def __init__(self, logger: logging.Logger, context_window=5):\n        self.window: deque[str] = deque([], maxlen=context_window)\n        self.logger = logger\n        self.levelno = logging.DEBUG\n        self.count = 0\n\n    def filter(self, record):\n        if record.msg in self.window:\n            self.count += 1\n            self.levelno = record.levelno\n            return False\n        else:\n            if self.count >= 1:\n                rep_msg = f\"(suppressed {self.count} repeated lines)\"\n                self.count = 0                            \n                self.logger.log(self.levelno, rep_msg)\n                self.window.clear()\n            self.window.append(record.msg)\n            return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/ghostscript.py\\nFunction/Class: DuplicateFilter\\n```python\\nclass DuplicateFilter(logging.Filter):\\n           \\n\\n    def __init__(self, logger: logging.Logger, context_window=5):\\n        self.window: deque[str] = deque([], maxlen=context_window)\\n        self.logger = logger\\n        self.levelno = logging.DEBUG\\n        self.count = 0\\n\\n    def filter(self, record):\\n        if record.msg in self.window:\\n            self.count += 1\\n            self.levelno = record.levelno\\n            return False\\n        else:\\n            if self.count >= 1:\\n                rep_msg = f\\\"(suppressed {self.count} repeated lines)\\\"\\n                self.count = 0                            \\n                self.logger.log(self.levelno, rep_msg)\\n                self.window.clear()\\n            self.window.append(record.msg)\\n            return True\\n```\", \"assistant\": \"\"}", "response": "## Purpose\n\nThe `DuplicateFilter` class is designed to filter out duplicate log messages within a specified context window. This helps in reducing the verbosity of logs by suppressing repeated messages, thereby making the log output cleaner and more readable.\n\n## Analysis\n\n### Parameters\n\n- `logger: logging.Logger`: The logger instance that will be used to log the suppressed message.\n- `context_window: int = 5`: The number of recent log messages to consider for determining if a new message is a duplicate. Default is 5.\n\n### Behavior\n\n1. **Initialization**:\n   - A deque (`self.window`) is created with a maximum length equal to `context_window`. This deque will store the most recent log messages.\n   - The logger instance is stored in `self.logger`.\n   - The logging level (`self.levelno`) is set to `logging.DEBUG` by default, indicating that the filter will operate at this level or higher.\n\n2. **Filtering**:\n   - When a new log message record is processed by the `filter` method:\n     - If the message is already in the deque (`record.msg in self.window`), it is considered a duplicate.\n       - The duplicate count is incremented (`self.count += 1`).\n       - The logging level of the filter is updated to match that of the current record (`self.levelno = record.levelno`).\n       - `False` is returned, indicating that this log message should not be logged (i.e., it is filtered out).\n     - If the message is not a duplicate:\n       - If there were previously suppressed messages (`self.count >= 1`), a summary message is created (`rep_msg = f\\\"(suppressed {self.count} repeated lines)\\\"`).\n       - The count of suppressed messages is reset to 0 (`self.count = 0`).\n       - The logger logs the summary message at the recorded level.\n       - The deque is cleared to start a new context window.\n       - The new message is added to the deque (`self.window.append(record.msg)`).\n       - `True` is returned, indicating that this log message should be logged.\n\n### Edge Cases\n\n- **Small Context Window**: If `context_window` is set too small (e.g., 1), it may lead to frequent suppression of messages.\n- **Large Context Window**: If `context_window` is too large, it may delay detection of true duplicates.\n- **Logging Level**: The filter operates at the `DEBUG` level or higher by default. If the logger's level is set higher (e.g., `INFO`, `WARNING`), some duplicate messages might not be caught.\n\n## Summary\n\nThe `DuplicateFilter` class filters out duplicate log messages within a specified context window, reducing verbosity and improving the readability of log outputs. It uses a deque to store recent log messages and counts repeated occurrences of messages, logging a summary message when duplicates are detected."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/ocr.py", "func_name": "run_pipeline_cli", "whole_func_string": "def run_pipeline_cli(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return cli_exception_handler(_run_pipeline, options, plugin_manager)", "func_code_string": "def run_pipeline_cli(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n           \n    return cli_exception_handler(_run_pipeline, options, plugin_manager)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/ocr.py\\nFunction/Class: run_pipeline_cli\\n```python\\ndef run_pipeline_cli(\\n    options: argparse.Namespace,\\n    *,\\n    plugin_manager: OcrmypdfPluginManager,\\n) -> ExitCode:\\n           \\n    return cli_exception_handler(_run_pipeline, options, plugin_manager)\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `run_pipeline_cli` function is the primary entry point for executing OCR (Optical Character Recognition) operations using command-line interface (CLI). It facilitates the processing of PDF files by applying OCR to images within the PDF. The function manages the pipeline execution, handles exceptions gracefully, and returns an exit code indicating the success or failure of the operation.\n\n### Parameters\n- **options (`argparse.Namespace`)**: A namespace object containing parsed command-line options provided by the user. This includes settings such as input PDF file paths, output directory, OCR engine configuration, and more.\n  \n- **plugin_manager (`OcrmypdfPluginManager`, optional)**: An instance of `OcrmypdfPluginManager` that manages plugins for OCR engines. If not provided, a default manager is used.\n\n### Behavior\n1. **Exception Handling**: The function uses the `cli_exception_handler` to wrap `_run_pipeline`, ensuring that any exceptions raised during pipeline execution are caught and handled gracefully.\n2. **Pipeline Execution**: The actual pipeline logic is executed by calling `_run_pipeline` with the provided options and plugin manager.\n3. **Return Value**: The function returns an exit code, which can be used by the caller to determine if the OCR operation was successful (`0` indicates success, non-zero values indicate errors).\n\n### Edge Cases\n- **Invalid Options**: If the `options` namespace contains invalid or unsupported parameters, the function should handle these gracefully and return an appropriate error code.\n- **Missing Dependencies**: If necessary OCR engines are not installed or configured correctly, the function should raise a meaningful error message to inform the user.\n- **File I/O Errors**: If there are issues reading input PDF files or writing output files, the function should handle these errors by providing informative messages and returning an appropriate exit code.\n\n### Python Docstring\n```python\ndef run_pipeline_cli(\n    options: argparse.Namespace,\n    *,\n    plugin_manager: OcrmypdfPluginManager,\n) -> ExitCode:\n    \"\"\"\n    Execute the OCR pipeline using command-line interface (CLI).\n\n    Parameters:\n    - options (`argparse.Namespace`): Command-line options for the OCR operation.\n    - plugin_manager (`OcrmypdfPluginManager`, optional): Plugin manager for OCR engines.\n\n    Returns:\n    - `ExitCode`: An integer exit code indicating the success or failure of the OCR operation.\n\n    Edge Cases:\n    - Invalid options: Handle gracefully and return an appropriate error code.\n    - Missing dependencies: Raise a meaningful error message.\n    - File I/O errors: Handle gracefully and provide informative messages.\n    \"\"\"\n    return cli_exception_handler(_run_pipeline, options, plugin_manager)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_graft.py", "func_name": "count", "whole_func_string": "def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )", "func_code_string": "def count(string, page):\n        return len(\n            [\n                True\n                for operands, operator in pikepdf.parse_content_stream(page)\n                if operator == pikepdf.Operator('Tj')\n                and operands[0] == pikepdf.String(string)\n            ]\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_graft.py\\nFunction/Class: count\\n```python\\ndef count(string, page):\\n        return len(\\n            [\\n                True\\n                for operands, operator in pikepdf.parse_content_stream(page)\\n                if operator == pikepdf.Operator('Tj')\\n                and operands[0] == pikepdf.String(string)\\n            ]\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `count` function is to count the occurrences of a specific string within the content streams of a PDF page using the `pikepdf` library. The function iterates through each operator in the parsed content stream and checks if it matches the specified string.\n\n### Detailed Analysis\n\n- **Parameters**:\n  - `string`: A string that needs to be counted within the PDF page.\n  - `page`: A `pikepdf.Page` object representing the PDF page to search within.\n\n- **Behavior**:\n  - The function uses `pikepdf.parse_content_stream(page)` to parse the content stream of the given PDF page. This method returns a list of tuples, where each tuple contains operands and an operator.\n  - It then filters these tuples based on two conditions: \n    1. The operator is equal to `pikepdf.Operator('Tj')`, which represents text rendering commands in PDFs.\n    2. The first operand (the actual string) matches the input `string`.\n  - For each matching tuple, it adds `True` to a list.\n  - Finally, the function returns the length of this list, which corresponds to the count of occurrences of the specified string within the page.\n\n- **Edge Cases**:\n  - If no occurrences are found, the function returns 0.\n  - If the input `page` is not a valid `pikepdf.Page` object, an error will be raised when attempting to parse its content stream.\n  - The function assumes that all operands in text rendering commands are strings. If this assumption is violated, the code might not behave as expected.\n\n### Python Docstring\n\n```python\ndef count(string, page):\n    \"\"\"\n    Count the occurrences of a specific string within the content streams of a PDF page.\n\n    Parameters:\n    string (str): The string to search for in the PDF page.\n    page (pikepdf.Page): The PDF page object to search within.\n\n    Returns:\n    int: The number of times the specified string appears in the text rendering commands of the page.\n\n    Raises:\n    TypeError: If `page` is not a valid `pikepdf.Page` object.\n    \"\"\"\n    return len(\n        [\n            True\n            for operands, operator in pikepdf.parse_content_stream(page)\n            if operator == pikepdf.Operator('Tj')\n            and operands[0] == pikepdf.String(string)\n        ]\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "XrefExt", "whole_func_string": "class XrefExt(NamedTuple):\n                                              \n\n    xref: Xref\n    ext: str", "func_code_string": "class XrefExt(NamedTuple):\n                                              \n\n    xref: Xref\n    ext: str", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: XrefExt\\n```python\\nclass XrefExt(NamedTuple):\\n                                              \\n\\n    xref: Xref\\n    ext: str\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `XrefExt` class is designed to encapsulate an extended reference (xref) and its associated extension type within the context of a PDF file. This class facilitates easy access and manipulation of xrefs and their extensions, which are crucial for optimizing and manipulating PDF files.\n\n### Parameters and Behavior\n\n- **Parameters**:\n  - `xref` (`Xref`): An instance representing the cross-reference table of a PDF file.\n  - `ext` (`str`): A string indicating the type of extension associated with the xref. This could be used to denote different types of extensions such as compression, encryption, etc.\n\n- **Behavior**:\n  The class is a subclass of `NamedTuple`, which means it provides tuple-like functionality but with named fields for better readability and clarity. It allows for straightforward access to its components via attribute names (`xref` and `ext`). This makes it easy to work with xrefs and their extensions in a structured manner.\n\n- **Edge Cases**:\n  - Both `xref` and `ext` must be provided upon instantiation.\n  - The type of `ext` should be a string, ensuring that the extension is clearly identified and can be easily processed or referenced later.\n  - There are no inherent edge cases in terms of data validation within the class itself, as `NamedTuple` handles basic type checking.\n\n### Docstring/Summary\n\n```python\nclass XrefExt(NamedTuple):\n    \"\"\"Encapsulates an extended reference (xref) and its associated extension type within a PDF file.\n\n    Parameters:\n        xref (Xref): The cross-reference table of the PDF file.\n        ext (str): The type of extension associated with the xref.\n\n    Usage Example:\n        >>> from ocrmypdf.optimize import XrefExt\n        >>> xref_instance = Xref()  # Assume Xref is already defined and initialized\n        >>> xref_ext = XrefExt(xref=xref_instance, ext=\"compression\")\n        >>> print(xref_ext.xref)\n        <Xref object at 0x...>\n        >>> print(xref_ext.ext)\n        'compression'\n    \"\"\"\n```\n\nThis docstring provides a clear purpose, detailed parameter descriptions, and an example usage to help users understand how to effectively use the `XrefExt` class in their code."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_validation.py", "func_name": "check_options_languages", "whole_func_string": "def check_options_languages(\n    options: Namespace, ocr_engine_languages: list[str]\n) -> None:\n    if not options.languages:\n        options.languages = [DEFAULT_LANGUAGE]\n        system_lang = locale.getlocale()[0]\n        if system_lang and not system_lang.startswith('en'):\n            log.debug(\"No language specified; assuming --language %s\", DEFAULT_LANGUAGE)\n    if not ocr_engine_languages:\n        return\n\n    missing_languages = set(options.languages) - set(ocr_engine_languages)\n    if missing_languages:\n        lang_text = '\\n'.join(lang for lang in missing_languages)\n        msg = (\n            \"OCR engine does not have language data for the following \"\n            \"requested languages: \\n\"\n            f\"{lang_text}\\n\"\n            \"Please install the appropriate language data for your OCR engine.\\n\"\n            \"\\n\"\n            \"See the online documentation for instructions:\\n\"\n            \"    https://ocrmypdf.readthedocs.io/en/latest/languages.html\\n\"\n            \"\\n\"\n            \"Note: most languages are identified by a 3-letter ISO 639-2 Code.\\n\"\n            \"For example, English is 'eng', German is 'deu', and Spanish is 'spa'.\\n\"\n            \"Simplified Chinese is 'chi_sim' and Traditional Chinese is 'chi_tra'.\"\n            \"\\n\"\n        )\n        raise MissingDependencyError(msg)", "func_code_string": "def check_options_languages(\n    options: Namespace, ocr_engine_languages: list[str]\n) -> None:\n    if not options.languages:\n        options.languages = [DEFAULT_LANGUAGE]\n        system_lang = locale.getlocale()[0]\n        if system_lang and not system_lang.startswith('en'):\n            log.debug(\"No language specified; assuming --language %s\", DEFAULT_LANGUAGE)\n    if not ocr_engine_languages:\n        return\n\n    missing_languages = set(options.languages) - set(ocr_engine_languages)\n    if missing_languages:\n        lang_text = '\\n'.join(lang for lang in missing_languages)\n        msg = (\n            \"OCR engine does not have language data for the following \"\n            \"requested languages: \\n\"\n            f\"{lang_text}\\n\"\n            \"Please install the appropriate language data for your OCR engine.\\n\"\n            \"\\n\"\n            \"See the online documentation for instructions:\\n\"\n            \"    https://ocrmypdf.readthedocs.io/en/latest/languages.html\\n\"\n            \"\\n\"\n            \"Note: most languages are identified by a 3-letter ISO 639-2 Code.\\n\"\n            \"For example, English is 'eng', German is 'deu', and Spanish is 'spa'.\\n\"\n            \"Simplified Chinese is 'chi_sim' and Traditional Chinese is 'chi_tra'.\"\n            \"\\n\"\n        )\n        raise MissingDependencyError(msg)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_validation.py\\nFunction/Class: check_options_languages\\n```python\\ndef check_options_languages(\\n    options: Namespace, ocr_engine_languages: list[str]\\n) -> None:\\n    if not options.languages:\\n        options.languages = [DEFAULT_LANGUAGE]\\n        system_lang = locale.getlocale()[0]\\n        if system_lang and not system_lang.startswith('en'):\\n            log.debug(\\\"No language specified; assuming --language %s\\\", DEFAULT_LANGUAGE)\\n    if not ocr_engine_languages:\\n        return\\n\\n    missing_languages = set(options.languages) - set(ocr_engine_languages)\\n    if missing_languages:\\n        lang_text = '\\\\n'.join(lang for lang in missing_languages)\\n        msg = (\\n            \\\"OCR engine does not have language data for the following \\\"\\n            \\\"requested languages: \\\\n\\\"\\n            f\\\"{lang_text}\\\\n\\\"\\n            \\\"Please install the appropriate language data for your OCR engine.\\\\n\\\"\\n            \\\"\\\\n\\\"\\n            \\\"See the online documentation for instructions:\\\\n\\\"\\n            \\\"    https://ocrmypdf.readthedocs.io/en/latest/languages.html\\\\n\\\"\\n            \\\"\\\\n\\\"\\n            \\\"Note: most languages are identified by a 3-letter ISO 639-2 Code.\\\\n\\\"\\n            \\\"For example, English is 'eng', German is 'deu', and Spanish is 'spa'.\\\\n\\\"\\n            \\\"Simplified Chinese is 'chi_sim' and Traditional Chinese is 'chi_tra'.\\\"\\n            \\\"\\\\n\\\"\\n        )\\n        raise MissingDependencyError(msg)\\n```\", \"assistant\": \"\"}", "response": "### Function: `check_options_languages`\n\n#### High-Level Purpose:\nThe function `check_options_languages` ensures that the OCR engine has the necessary language data for all requested languages specified in the options. If no languages are specified, it defaults to a default language (likely English). It also checks if the OCR engine can handle each of the requested languages and raises an error if any language is missing.\n\n#### Parameters:\n- `options: Namespace`: An object containing configuration options, including a list of languages to be used for OCR.\n- `ocr_engine_languages: list[str]`: A list of language codes that the OCR engine supports.\n\n#### Behavior:\n1. **Language Defaulting**: If no languages are specified in the options (`options.languages` is empty), the function sets it to a default language (e.g., English) and logs a debug message indicating the default assumption.\n2. **Language Validation**: The function compares the requested languages with those supported by the OCR engine.\n3. **Error Handling**: If any of the requested languages are not supported by the OCR engine, an error is raised detailing which languages are missing. The error includes instructions on how to install additional language data and details about language codes.\n\n#### Edge Cases:\n- **Empty Language List**: If `options.languages` is empty, it defaults to a single language.\n- **Supported Languages**: Only languages supported by the OCR engine should be specified.\n- **Language Codes**: Ensure that all language codes are correctly formatted according to ISO 639-2 standards.\n\n#### Python Docstring:\n```python\ndef check_options_languages(\n    options: Namespace, ocr_engine_languages: list[str]\n) -> None:\n    \"\"\"\n    Ensures the OCR engine has the necessary language data for all requested languages.\n    \n    If no languages are specified, defaults to a default language (likely English).\n    Raises an error if any of the requested languages are not supported by the OCR engine.\n\n    Parameters:\n    options (Namespace): An object containing configuration options, including a list of languages to be used for OCR.\n    ocr_engine_languages (list[str]): A list of language codes that the OCR engine supports.\n\n    Raises:\n    MissingDependencyError: If any requested languages are not supported by the OCR engine.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/extra_plugins/semfree.py", "func_name": "get_logging_console", "whole_func_string": "def get_logging_console():\n                                                  \n    return logging.StreamHandler()", "func_code_string": "def get_logging_console():\n                                                  \n    return logging.StreamHandler()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/extra_plugins/semfree.py\\nFunction/Class: get_logging_console\\n```python\\ndef get_logging_console():\\n                                                  \\n    return logging.StreamHandler()\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe function `get_logging_console` is designed to provide a logging handler that outputs log messages to the console. This is useful for applications where real-time output of log information is desired without writing to files.\n\n### Parameters\n- None\n\n### Behavior\n- The function returns an instance of `logging.StreamHandler`, which directs the log output to the standard error stream (usually the console).\n\n### Edge Cases\n- If no logging configuration has been set up before calling this function, it will use default settings provided by `StreamHandler`.\n- In a multi-threaded environment, each thread may have its own logger and handler, leading to multiple console outputs if not managed carefully.\n\n### Docstring\n```python\ndef get_logging_console():\n    \"\"\"\n    Returns a logging handler that outputs log messages to the standard error stream (console).\n\n    Parameters:\n        None\n\n    Returns:\n        logging.StreamHandler: A stream handler that directs logs to the console.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_validation.py", "func_name": "test_pagesegmode_warning", "whole_func_string": "def test_pagesegmode_warning(caplog):\n    opts = make_opts(tesseract_pagesegmode='0')\n    plugin_manager = get_plugin_manager(opts.plugins)\n    vd.check_options(opts, plugin_manager)\n    assert 'disable OCR' in caplog.text", "func_code_string": "def test_pagesegmode_warning(caplog):\n    opts = make_opts(tesseract_pagesegmode='0')\n    plugin_manager = get_plugin_manager(opts.plugins)\n    vd.check_options(opts, plugin_manager)\n    assert 'disable OCR' in caplog.text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_validation.py\\nFunction/Class: test_pagesegmode_warning\\n```python\\ndef test_pagesegmode_warning(caplog):\\n    opts = make_opts(tesseract_pagesegmode='0')\\n    plugin_manager = get_plugin_manager(opts.plugins)\\n    vd.check_options(opts, plugin_manager)\\n    assert 'disable OCR' in caplog.text\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_pagesegmode_warning` is designed to test the behavior of a warning message when a specific configuration option for Tesseract (`tesseract_pagesegmode`) is set. The purpose of this test is to ensure that a warning is correctly logged when the value '0' is provided for `tesseract_pagesegmode`, indicating that OCR (Optical Character Recognition) should be disabled.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**:\n  - `caplog`: A fixture used for capturing log messages. This parameter is essential for asserting the presence of a specific warning message in the logs.\n\n- **Behavior**:\n  - The function sets up options with `tesseract_pagesegmode` set to '0'.\n  - It then retrieves a plugin manager using these options.\n  - The `vd.check_options` function is called with the options and the plugin manager, which presumably performs validation checks.\n  - Finally, it asserts that the string 'disable OCR' is present in the captured log messages.\n\n- **Edge Cases**:\n  - If `tesseract_pagesegmode` is not set to '0', the test should pass without logging any warning about disabling OCR.\n  - The function does not handle cases where other plugins or options might be involved, focusing solely on the warning related to `tesseract_pagesegmode`.\n\n### Python Docstring\n\n```python\ndef test_pagesegmode_warning(caplog):\n    \"\"\"\n    Tests that a warning is logged when 'tesseract_pagesegmode' is set to '0',\n    indicating that OCR should be disabled.\n    \n    Parameters:\n    - caplog: A fixture for capturing log messages.\n\n    Asserts:\n    - The string 'disable OCR' is present in the captured log messages.\n    \"\"\"\n    opts = make_opts(tesseract_pagesegmode='0')\n    plugin_manager = get_plugin_manager(opts.plugins)\n    vd.check_options(opts, plugin_manager)\n    assert 'disable OCR' in caplog.text\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "should_visible_page_image_use_jpg", "whole_func_string": "def should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\n           \n    return bool(pageinfo.images) and all(\n        im.enc == Encoding.jpeg for im in pageinfo.images\n    )", "func_code_string": "def should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\n           \n    return bool(pageinfo.images) and all(\n        im.enc == Encoding.jpeg for im in pageinfo.images\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: should_visible_page_image_use_jpg\\n```python\\ndef should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\\n           \\n    return bool(pageinfo.images) and all(\\n        im.enc == Encoding.jpeg for im in pageinfo.images\\n    )\\n```\", \"assistant\": \"\"}", "response": "## Function: `should_visible_page_image_use_jpg`\n\n### Purpose\n\nThe function `should_visible_page_image_use_jpg` determines whether visible images on a page should be encoded using JPEG format based on the provided `PageInfo` object.\n\n### Parameters\n\n- **pageinfo** (`PageInfo`): An object containing information about the pages in an OCR document, including details about the images present on each page.\n\n### Behavior\n\n1. The function first checks if there are any images present on the page by evaluating whether `pageinfo.images` is non-empty.\n2. If images are present, it proceeds to check if all images on the page are encoded using JPEG format (`Encoding.jpeg`).\n3. The function returns `True` if both conditions are met (i.e., there are images and they are all in JPEG format). Otherwise, it returns `False`.\n\n### Edge Cases\n\n- If `pageinfo.images` is an empty list or contains no elements, the function will return `False`.\n- If any image on the page is not encoded using JPEG format (`Encoding.jpeg`), the function will return `False`.\n- The function assumes that each image in `pageinfo.images` has a valid `enc` attribute indicating its encoding type.\n\n### Docstring\n\n```python\ndef should_visible_page_image_use_jpg(pageinfo: PageInfo) -> bool:\n    \"\"\"\n    Determines whether visible images on a page should be encoded using JPEG format.\n    \n    Args:\n        pageinfo (PageInfo): An object containing information about the pages in an OCR document, including details about the images present on each page.\n        \n    Returns:\n        bool: True if all visible images are in JPEG format, False otherwise.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_unpaper_args_invalid", "whole_func_string": "def test_unpaper_args_invalid(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"unpaper is not going to like these arguments\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n                                                                            \n                           \n    assert exitcode == ExitCode.child_process_error", "func_code_string": "def test_unpaper_args_invalid(resources, outpdf):\n    exitcode = run_ocrmypdf_api(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        \"--unpaper-args\",\n        \"unpaper is not going to like these arguments\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )\n                                                                            \n                           \n    assert exitcode == ExitCode.child_process_error", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_unpaper.py\\nFunction/Class: test_unpaper_args_invalid\\n```python\\ndef test_unpaper_args_invalid(resources, outpdf):\\n    exitcode = run_ocrmypdf_api(\\n        resources / \\\"skew.pdf\\\",\\n        outpdf,\\n        \\\"-c\\\",\\n        \\\"--unpaper-args\\\",\\n        \\\"unpaper is not going to like these arguments\\\",\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n                                                                            \\n                           \\n    assert exitcode == ExitCode.child_process_error\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**:\n   The function `test_unpaper_args_invalid` is designed to test the behavior of OCRmyPDF when provided with invalid arguments for the `--unpaper-args` option. This test ensures that the OCRmyPDF process gracefully handles such errors and returns the expected exit code.\n\n2. **Parameter Analysis**:\n   - `resources`: A file system path containing various resources, including a PDF file named \"skew.pdf\" that will be processed.\n   - `outpdf`: The output file path where the processed PDF should be saved.\n\n3. **Behavior**:\n   - The function calls `run_ocrmypdf_api` with specific arguments to simulate an OCRmyPDF process.\n   - It uses an invalid argument for `--unpaper-args`, which is expected to cause an error in the OCRmyPDF process.\n   - The function asserts that the exit code returned by `run_ocrmypdf_api` matches `ExitCode.child_process_error`, indicating that the child process (OCRmyPDF) encountered an error.\n\n4. **Edge Cases**:\n   - An invalid argument for `--unpaper-args` should cause OCRmyPDF to fail gracefully.\n   - The exit code returned by `run_ocrmypdf_api` should accurately reflect the failure of the OCRmyPDF child process.\n\n5. **Python Docstring**:\n```python\ndef test_unpaper_args_invalid(resources, outpdf):\n    \"\"\"\n    Test OCRmyPDF's behavior when provided with invalid arguments for the --unpaper-args option.\n    \n    Parameters:\n    - resources (pathlib.Path): The path to a directory containing various resources.\n    - outpdf (pathlib.Path): The output file path for the processed PDF.\n    \n    Asserts that the exit code returned by run_ocrmypdf_api is ExitCode.child_process_error,\n    indicating that the OCRmyPDF child process encountered an error due to invalid arguments.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_helpers.py", "func_name": "cpu_count_raises", "whole_func_string": "def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()", "func_code_string": "def cpu_count_raises():\n        nonlocal invoked\n        invoked = True\n        raise NotImplementedError()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_helpers.py\\nFunction/Class: cpu_count_raises\\n```python\\ndef cpu_count_raises():\\n        nonlocal invoked\\n        invoked = True\\n        raise NotImplementedError()\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `cpu_count_raises` is designed to simulate a scenario where the number of CPU cores on a system cannot be determined. This function will be used in unit tests to verify that other parts of the code handle this exception appropriately.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**: None\n  - The function does not accept any parameters.\n\n- **Behavior**:\n  - When called, the function sets a nonlocal variable `invoked` to `True`.\n  - It then raises a `NotImplementedError`, indicating that the number of CPU cores cannot be determined.\n\n- **Edge Cases**:\n  - If this function is not properly mocked in tests, it will raise an exception and halt test execution.\n  - The edge case here is ensuring that the function is only used as part of a proper test setup to check how other code handles the `NotImplementedError`.\n\n### Python Docstring\n\n```python\ndef cpu_count_raises():\n    \"\"\"\n    Simulates a scenario where the number of CPU cores cannot be determined.\n\n    This function sets a nonlocal variable 'invoked' to True and raises a NotImplementedError.\n    It is intended for use in unit tests to verify how other code handles this exception.\n    \n    Parameters:\n        None\n    \n    Returns:\n        None\n    \n    Raises:\n        NotImplementedError: Always raised to simulate an inability to determine CPU count.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "get_result", "whole_func_string": "def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_code_string": "def get_result(self) -> LTPage | None:\n                                             \n        return self.result", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/pdfinfo/layout.py\\nFunction/Class: get_result\\n```python\\ndef get_result(self) -> LTPage | None:\\n                                             \\n        return self.result\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `get_result` function is a method within a class designed to retrieve the processed result of a PDF layout analysis. The primary purpose of this function is to provide access to the outcome of the layout analysis, which could be an instance of `LTPage` if the analysis was successful, or `None` if no result is available.\n\n### Parameters\n\n- **self**: Represents the instance of the class where this method is called. It implicitly contains the state and attributes relevant to the current context of the object.\n\n### Behavior\n\nThe function simply returns the attribute `result` from the instance it belongs to. The behavior can be summarized as follows:\n1. Accesses the `result` attribute of the current instance (`self.result`).\n2. Returns the value of the `result` attribute.\n\n### Edge Cases\n\n- **No Result**: If the `result` attribute is not set (i.e., `None`), the function will return `None`.\n- **Type Checking**: The function assumes that the `result` attribute is either an instance of `LTPage` or `None`. If the type does not match, this could lead to runtime errors.\n\n### Python Docstring\n\n```python\ndef get_result(self) -> LTPage | None:\n    \"\"\"\n    Retrieve the result of the PDF layout analysis.\n\n    Returns:\n        LTPage | None: The result of the layout analysis if successful, otherwise `None`.\n    \"\"\"\n    return self.result\n```\n\nThis docstring clearly states the purpose of the function and what it returns, providing a concise summary of its behavior."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "_offset_rect", "whole_func_string": "def _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]):\n                                               \n    return (\n        rect[0] + offset[0],\n        rect[1] + offset[1],\n        rect[2] + offset[0],\n        rect[3] + offset[1],\n    )", "func_code_string": "def _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]):\n                                               \n    return (\n        rect[0] + offset[0],\n        rect[1] + offset[1],\n        rect[2] + offset[0],\n        rect[3] + offset[1],\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: _offset_rect\\n```python\\ndef _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]):\\n                                               \\n    return (\\n        rect[0] + offset[0],\\n        rect[1] + offset[1],\\n        rect[2] + offset[0],\\n        rect[3] + offset[1],\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**Purpose:** The function `_offset_rect` is designed to adjust the position of a rectangle by applying an offset vector. This is useful in scenarios where you need to translate geometric shapes without modifying their size.\n\n**Parameters:**\n- `rect`: A tuple representing the coordinates of a rectangle in the format `(x1, y1, x2, y2)`. Here, `(x1, y1)` are the coordinates of the bottom-left corner and `(x2, y2)` are the coordinates of the top-right corner.\n- `offset`: A tuple representing the translation vector to be applied to the rectangle in the format `(dx, dy)`.\n\n**Behavior:**\nThe function takes a rectangle defined by two points `(x1, y1)` and `(x2, y2)` and an offset vector `(dx, dy)`. It returns a new rectangle where each coordinate of the original rectangle is increased or decreased by the corresponding component of the offset vector. This effectively translates the entire rectangle by `dx` units horizontally and `dy` units vertically.\n\n**Edge Cases:**\n- If `rect` contains non-finite values (e.g., `NaN`, `Infinity`), the function may produce incorrect results.\n- If `offset` contains non-finite values, the resulting rectangle will also contain these non-finite values.\n- The function does not validate the input types or ranges of the parameters.\n\n**Docstring:**\n```python\ndef _offset_rect(rect: tuple[float, float, float, float], offset: tuple[float, float]) -> tuple[float, float, float, float]:\n    \"\"\"\n    Offsets a rectangle by applying a translation vector.\n\n    Parameters:\n    rect (tuple[float, float, float, float]): The coordinates of the rectangle in the format (x1, y1, x2, y2).\n    offset (tuple[float, float]): The translation vector to be applied to the rectangle in the format (dx, dy).\n\n    Returns:\n    tuple[float, float, float, float]: The new rectangle coordinates after applying the offset.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "generate_pdf", "whole_func_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_code_string": "def generate_pdf(input_file, output_pdf, output_text, options):\n        with Image.open(input_file) as im:\n            dpi = im.info['dpi']\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\n        pdf = pikepdf.new()\n        pdf.add_blank_page(page_size=ptsize)\n        pdf.save(output_pdf, static_id=True)\n        output_text.write_text('')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_noop.py\\nFunction/Class: generate_pdf\\n```python\\ndef generate_pdf(input_file, output_pdf, output_text, options):\\n        with Image.open(input_file) as im:\\n            dpi = im.info['dpi']\\n            pagesize = im.size[0] / dpi[0], im.size[1] / dpi[1]\\n        ptsize = pagesize[0] * 72, pagesize[1] * 72\\n        pdf = pikepdf.new()\\n        pdf.add_blank_page(page_size=ptsize)\\n        pdf.save(output_pdf, static_id=True)\\n        output_text.write_text('')\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `generate_pdf` function is designed to generate a PDF file from an image input. It takes the input image and saves it as a PDF along with an empty text file.\n\n### Parameters\n\n- **input_file (str)**: The path to the input image file.\n- **output_pdf (str)**: The path where the generated PDF file will be saved.\n- **output_text (Path)**: The path to the output text file, which will be written as empty.\n- **options (dict)**: A dictionary containing any additional options that might be needed for processing the image.\n\n### Behavior\n\n1. The function opens the input image using the `PIL` library.\n2. It calculates the DPI and page size of the image.\n3. Converts the page size from inches to points.\n4. Creates a new PDF file using the `pikepdf` library.\n5. Adds a blank page to the PDF with the calculated page size.\n6. Saves the PDF to the specified output path.\n7. Writes an empty string to the output text file.\n\n### Edge Cases\n\n- If the input image does not contain valid DPI information, it might default to standard values (e.g., 72 DPI).\n- If `output_text` is not a writable path, it will raise an error when trying to write to it.\n- The function assumes that `pikepdf` and `PIL` are installed and available in the environment.\n\n### Python Docstring\n\n```python\ndef generate_pdf(input_file: str, output_pdf: str, output_text: Path, options: dict) -> None:\n    \"\"\"\n    Generates a PDF file from an image input.\n\n    Parameters:\n    - input_file (str): The path to the input image file.\n    - output_pdf (str): The path where the generated PDF file will be saved.\n    - output_text (Path): The path to the output text file, which will be written as empty.\n    - options (dict): A dictionary containing any additional options that might be needed for processing the image.\n\n    Raises:\n    - IOError: If the input file cannot be opened or if there is an issue writing to the output files.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "languages", "whole_func_string": "def languages(options):\n        return {'eng'}", "func_code_string": "def languages(options):\n        return {'eng'}", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_debug_rotate.py\\nFunction/Class: languages\\n```python\\ndef languages(options):\\n        return {'eng'}\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `languages` function in the `tesseract_debug_rotate.py` file is designed to specify the language(s) that the Tesseract OCR engine should recognize during text extraction. This function returns a set containing the ISO 639-2 code for English (`eng`). This ensures that the OCR process will focus on identifying and extracting text in English.\n\n### Parameters\n\n- `options`: A dictionary of options passed to the function, which is currently not used within the function.\n\n### Behavior\n\nThe function always returns a set containing the string `'eng'`, indicating that the OCR engine should recognize English text. This is a fixed implementation and does not vary based on the input parameters.\n\n### Edge Cases\n\n- If additional languages were to be supported in the future, this function would need to be updated accordingly.\n- Passing different options dictionaries to the function will have no effect since they are ignored within the function.\n\n### Python Docstring\n\n```python\ndef languages(options):\n    \"\"\"\n    Specify the language(s) that the Tesseract OCR engine should recognize during text extraction.\n    \n    Parameters:\n    - options (dict): A dictionary of options passed to the function, currently not used.\n    \n    Returns:\n    - set: A set containing the ISO 639-2 code for English ('eng').\n    \"\"\"\n    return {'eng'}\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_ghostscript.py", "func_name": "duplicate_filter_logger", "whole_func_string": "def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger", "func_code_string": "def duplicate_filter_logger(self):\n                                                                                  \n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\n        logger.setLevel(logging.DEBUG)\n        logger.addFilter(DuplicateFilter(logger))\n        return logger", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_ghostscript.py\\nFunction/Class: duplicate_filter_logger\\n```python\\ndef duplicate_filter_logger(self):\\n                                                                                  \\n        logger = logging.getLogger(__name__ + secrets.token_urlsafe(8))\\n        logger.setLevel(logging.DEBUG)\\n        logger.addFilter(DuplicateFilter(logger))\\n        return logger\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose:**\nThe `duplicate_filter_logger` function is designed to create a custom logging instance specifically tailored for applications that require filtering out duplicate log messages. This ensures that each unique message is logged only once, reducing clutter and making the logs more readable.\n\n**Parameter Analysis:**\n- **No parameters**: The function does not accept any input arguments.\n\n**Behavior:**\n1. **Logger Creation**: The function creates a new logger instance using `logging.getLogger(__name__ + secrets.token_urlsafe(8))`. This ensures that each logger is unique even within the same module.\n2. **Logging Level Setting**: It sets the logging level of the created logger to `DEBUG`, allowing all levels of logs (debug, info, warning, error, critical) to be captured.\n3. **Filter Addition**: The function adds a custom filter (`DuplicateFilter`) to the logger. This filter is responsible for ensuring that only unique log messages are logged.\n\n**Edge Cases:**\n- **Logger Uniqueness**: By appending a random token to the logger name using `secrets.token_urlsafe(8)`, the function ensures that each call to `duplicate_filter_logger` returns a new, unique logger instance.\n- **No Duplicate Messages**: The `DuplicateFilter` will ensure that no duplicate messages are logged, even if they occur multiple times within the application.\n\n**Python Docstring:**\n```python\ndef duplicate_filter_logger(self):\n    \"\"\"\n    Create and configure a custom logger with a DuplicateFilter to prevent logging of duplicate messages.\n\n    Returns:\n        logging.Logger: A new instance of the logger configured with a DuplicateFilter.\n    \"\"\"\n```\n\nThis concise docstring summarizes the purpose, behavior, and return value of the `duplicate_filter_logger` function."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_rotation.py", "func_name": "rasterize", "whole_func_string": "def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )", "func_code_string": "def rasterize(pdf, pageno, png):\n        if png.exists():\n            print(png)\n            return\n        ghostscript.rasterize_pdf(\n            pdf,\n            png,\n            raster_device='pngmono',\n            raster_dpi=Resolution(100, 100),\n            pageno=pageno,\n            rotation=0,\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_rotation.py\\nFunction/Class: rasterize\\n```python\\ndef rasterize(pdf, pageno, png):\\n        if png.exists():\\n            print(png)\\n            return\\n        ghostscript.rasterize_pdf(\\n            pdf,\\n            png,\\n            raster_device='pngmono',\\n            raster_dpi=Resolution(100, 100),\\n            pageno=pageno,\\n            rotation=0,\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-Level Purpose:**\nThe `rasterize` function is designed to convert a specific page of a PDF document into a PNG image using Ghostscript. If the output PNG file already exists, it will skip the rasterization process and print the existing file path.\n\n**Parameters Analysis:**\n- **pdf (str):** The path to the input PDF file.\n- **pageno (int):** The page number of the PDF to be rasterized.\n- **png (Path):** The output PNG file path where the rasterized image will be saved.\n\n**Behavior and Edge Cases:**\n1. **Check for Existing Output:** If the PNG file already exists, the function will print the file path and skip further processing.\n2. **Rasterization Process:** If the PNG file does not exist, the function will call Ghostscript's `rasterize_pdf` method to convert the specified page of the PDF into a PNG image with the given DPI (dots per inch) and rotation angle.\n3. **Default Parameters:** The default raster device is set to 'pngmono' and the default resolution is 100 DPI in both horizontal and vertical directions.\n\n**Concise Python Docstring:**\n```python\ndef rasterize(pdf, pageno, png):\n    \"\"\"\n    Convert a specific page of a PDF document into a PNG image using Ghostscript.\n    \n    Parameters:\n    pdf (str): The path to the input PDF file.\n    pageno (int): The page number of the PDF to be rasterized.\n    png (Path): The output PNG file path where the rasterized image will be saved.\n    \n    If the output PNG file already exists, it will skip the rasterization process and print the existing file path.\n    \"\"\"\n    if png.exists():\n        print(png)\n        return\n    ghostscript.rasterize_pdf(\n        pdf,\n        png,\n        raster_device='pngmono',\n        raster_dpi=Resolution(100, 100),\n        pageno=pageno,\n        rotation=0,\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_image_input.py", "func_name": "baiona", "whole_func_string": "def baiona(resources):\n    return Image.open(resources / 'baiona_gray.png')", "func_code_string": "def baiona(resources):\n    return Image.open(resources / 'baiona_gray.png')", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_image_input.py\\nFunction/Class: baiona\\n```python\\ndef baiona(resources):\\n    return Image.open(resources / 'baiona_gray.png')\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\nThe function `baiona` is designed to open an image file named \"baiona_gray.png\" using the Python Imaging Library (PIL). The purpose of this function is to facilitate loading a specific image resource for further processing or display.\n\n### Parameters:\n- **resources**: A `Path` object representing the directory containing the image file. This parameter ensures that the function knows where to locate the \"baiona_gray.png\" file relative to the specified directory.\n\n### Behavior:\n1. The function takes a single parameter, which is expected to be a `Path` object.\n2. It uses the `Image.open()` method from the PIL library to open the image located at `resources / 'baiona_gray.png'`.\n3. The function returns an `Image` object representing the opened image.\n\n### Edge Cases:\n- If the file \"baiona_gray.png\" does not exist in the specified directory, the function will raise a `FileNotFoundError`.\n- If the provided `resources` parameter is not a valid `Path` object, it may result in unexpected behavior or errors when attempting to access the file path.\n\n### Python Docstring:\n```python\ndef baiona(resources):\n    \"\"\"\n    Open and return the \"baiona_gray.png\" image from the specified directory.\n\n    Parameters:\n    resources (pathlib.Path): The directory containing the \"baiona_gray.png\" file.\n\n    Returns:\n    PIL.Image.Image: An Image object representing the opened image.\n\n    Raises:\n    FileNotFoundError: If the \"baiona_gray.png\" file does not exist in the specified directory.\n    TypeError: If the `resources` parameter is not a valid Path object.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/pdfinfo/layout.py", "func_name": "__exit__", "whole_func_string": "def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True", "func_code_string": "def __exit__(self, exc_type, exc_value, traceback):\n                                       \n        if self.file:\n            self.file.close()\n        return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/pdfinfo/layout.py\\nFunction/Class: __exit__\\n```python\\ndef __exit__(self, exc_type, exc_value, traceback):\\n                                       \\n        if self.file:\\n            self.file.close()\\n        return True\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `__exit__` method is a special method in Python that is used to define the behavior of an object when it is used as a context manager. It is typically called automatically by the `with` statement when exiting the block of code within the `with` statement.\n\nIn this case, the `__exit__` method is part of a class designed to manage file operations, specifically for closing a file after its use within a `with` block.\n\n### Parameters\n\n- `exc_type`: The type of exception that was raised, or `None` if no exception was raised.\n- `exc_value`: The actual exception instance that was raised, or `None` if no exception was raised.\n- `traceback`: A traceback object representing the call stack at the point where the exception was raised, or `None` if no exception was raised.\n\n### Behavior\n\n1. **File Closing**: If a file (`self.file`) has been opened, it is closed using the `close()` method of the file object.\n2. **Return Value**: The method returns `True`, indicating that any exceptions raised during the execution block (within the `with` statement) have been handled gracefully and can be ignored.\n\n### Edge Cases\n\n- **No File Opened**: If no file has been opened (`self.file` is `None`), the method does nothing.\n- **Exception Handling**: Regardless of whether an exception was raised or not, the file is always closed if it was previously opened. This ensures that resources are properly released even in the event of errors.\n\n### Python Docstring\n\n```python\ndef __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"\n    Close the file when exiting the context manager.\n\n    Parameters:\n    exc_type (type): The type of exception raised.\n    exc_value (Exception): The exception instance raised.\n    traceback (TracebackType): A traceback object or None if no exception was raised.\n\n    Returns:\n    bool: True to suppress any exceptions that were raised.\n    \"\"\"\n```\n\nThis docstring provides a clear description of the method's purpose, parameters, and return value, adhering to Python's standard conventions for documentation."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "img_name", "whole_func_string": "def img_name(root: Path, xref: Xref, ext: str) -> Path:\n                                                                          \n    return root / f'{xref:08d}{ext}'", "func_code_string": "def img_name(root: Path, xref: Xref, ext: str) -> Path:\n                                                                          \n    return root / f'{xref:08d}{ext}'", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: img_name\\n```python\\ndef img_name(root: Path, xref: Xref, ext: str) -> Path:\\n                                                                          \\n    return root / f'{xref:08d}{ext}'\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The function `img_name` is designed to generate a file path for an image based on its Xref (cross-reference) ID and desired extension.\n\n2. **Parameter Analysis**:\n   - `root`: A `Path` object representing the root directory where the image files are stored.\n   - `xref`: An integer representing the Xref ID, which uniquely identifies a specific page or element in an OCR'd PDF.\n   - `ext`: A string representing the file extension for the image.\n\n3. **Behavior**:\n   - The function constructs and returns a `Path` object that combines the `root` directory with a filename composed of the formatted `xref` ID and the provided `ext`.\n   - The `xref` ID is zero-padded to 8 digits, ensuring consistent file naming across different Xref IDs.\n\n4. **Edge Cases**:\n   - If `root` is not an existing directory, attempting to write a file there will raise a `FileNotFoundError`.\n   - If `ext` does not start with a dot (e.g., `.png`, `.jpg`), the resulting filename may not be recognized as an image by most systems.\n   - An empty or invalid `root` path could lead to unexpected behavior, depending on how it is handled in subsequent file operations.\n\n### Concise Python Docstring\n\n```python\ndef img_name(root: Path, xref: Xref, ext: str) -> Path:\n    \"\"\"\n    Generate a file path for an image based on its Xref ID and desired extension.\n    \n    Parameters:\n    - root (Path): The root directory where the image files are stored.\n    - xref (Xref): The Xref ID, which uniquely identifies a specific page or element in an OCR'd PDF.\n    - ext (str): The file extension for the image, e.g., '.png', '.jpg'.\n    \n    Returns:\n    Path: A `Path` object representing the constructed image file path.\n    \n    Note:\n    - The `xref` ID is zero-padded to 8 digits for consistent file naming.\n    - Ensure that `root` exists and is a valid directory.\n    \"\"\"\n    return root / f'{xref:08d}{ext}'\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_acroform.py", "func_name": "digitally_signed", "whole_func_string": "def digitally_signed(acroform, outdir):\n    out = outdir / 'acroform_signed.pdf'\n    with pikepdf.open(acroform) as pdf:\n        pdf.Root.AcroForm.SigFlags = 3\n        pdf.save(out)\n    yield out", "func_code_string": "def digitally_signed(acroform, outdir):\n    out = outdir / 'acroform_signed.pdf'\n    with pikepdf.open(acroform) as pdf:\n        pdf.Root.AcroForm.SigFlags = 3\n        pdf.save(out)\n    yield out", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_acroform.py\\nFunction/Class: digitally_signed\\n```python\\ndef digitally_signed(acroform, outdir):\\n    out = outdir / 'acroform_signed.pdf'\\n    with pikepdf.open(acroform) as pdf:\\n        pdf.Root.AcroForm.SigFlags = 3\\n        pdf.save(out)\\n    yield out\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `digitally_signed` function is to take an existing PDF file with an AcroForm and digitally sign it, saving the signed document to a specified output directory.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n**Parameters:**\n- `acroform`: The path to the input PDF file that contains an AcroForm.\n- `outdir`: The directory where the signed PDF will be saved.\n\n**Behavior:**\n1. The function opens the input PDF file using `pikepdf.open`.\n2. It sets the `SigFlags` attribute of the `AcroForm` dictionary to 3, which typically indicates a visible signature.\n3. The modified PDF is saved to the specified output directory with the filename `acroform_signed.pdf`.\n4. A generator yields the path to the signed PDF file.\n\n**Edge Cases:**\n- If the input file does not exist or is not a valid PDF, `pikepdf.open` will raise an exception.\n- If the output directory does not exist, it will need to be created before saving the file.\n- The function assumes that the AcroForm dictionary exists and can be modified. If it doesn't, this will cause an AttributeError.\n\n### Python Docstring\n\n```python\ndef digitally_signed(acroform, outdir):\n    \"\"\"\n    Digitally sign a PDF file with an AcroForm and save it to the specified output directory.\n\n    Parameters:\n    acroform (Path): The path to the input PDF file that contains an AcroForm.\n    outdir (Path): The directory where the signed PDF will be saved.\n\n    Yields:\n    Path: The path to the signed PDF file.\n\n    Raises:\n    FileNotFoundError: If the input file does not exist or is not a valid PDF.\n    pikepdf.PdfError: If there is an error opening or modifying the PDF.\n    \"\"\"\n    out = outdir / 'acroform_signed.pdf'\n    with pikepdf.open(acroform) as pdf:\n        pdf.Root.AcroForm.SigFlags = 3\n        pdf.save(out)\n    yield out\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_optimize_jpeg", "whole_func_string": "def _optimize_jpeg(\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\n) -> tuple[Xref, Path | None]:\n    with Image.open(in_jpg) as im:\n        im.save(opt_jpg, optimize=True, quality=jpeg_quality)\n\n    if opt_jpg.stat().st_size > in_jpg.stat().st_size:\n        log.debug(f\"xref {xref}, jpeg, made larger - skip\")\n        opt_jpg.unlink()\n        return xref, None\n    return xref, opt_jpg", "func_code_string": "def _optimize_jpeg(\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\n) -> tuple[Xref, Path | None]:\n    with Image.open(in_jpg) as im:\n        im.save(opt_jpg, optimize=True, quality=jpeg_quality)\n\n    if opt_jpg.stat().st_size > in_jpg.stat().st_size:\n        log.debug(f\"xref {xref}, jpeg, made larger - skip\")\n        opt_jpg.unlink()\n        return xref, None\n    return xref, opt_jpg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: _optimize_jpeg\\n```python\\ndef _optimize_jpeg(\\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\\n) -> tuple[Xref, Path | None]:\\n    with Image.open(in_jpg) as im:\\n        im.save(opt_jpg, optimize=True, quality=jpeg_quality)\\n\\n    if opt_jpg.stat().st_size > in_jpg.stat().st_size:\\n        log.debug(f\\\"xref {xref}, jpeg, made larger - skip\\\")\\n        opt_jpg.unlink()\\n        return xref, None\\n    return xref, opt_jpg\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `_optimize_jpeg` is designed to optimize a JPEG image by reducing its file size without significantly compromising the quality. It uses Python's `Pillow` library to perform this optimization.\n\n### Detailed Analysis\n\n**Parameters:**\n1. **xref (Xref):** A reference to the object in an OCRmyPDF context.\n2. **in_jpg (Path):** The path to the input JPEG file that needs to be optimized.\n3. **opt_jpg (Path):** The path where the optimized JPEG file will be saved.\n4. **jpeg_quality (int):** An integer representing the quality of the output JPEG file, ranging from 0 (worst) to 95 (best).\n\n**Behavior:**\n- The function opens the input JPEG image using `Pillow`'s `Image.open`.\n- It then saves the image to the specified output path with optimization enabled and the given quality level.\n- After saving the optimized image, it checks if the size of the output file is greater than the size of the input file.\n  - If the output file is larger, it logs a debug message indicating that the optimization did not reduce the file size sufficiently and skips further processing by deleting the output file. It then returns the original `xref` and `None`.\n  - If the output file is smaller or equal in size, it returns the updated `xref` and the path to the optimized JPEG file.\n\n**Edge Cases:**\n- **File Size Comparison:** The function relies on comparing the sizes of the input and output files. It assumes that any reduction in size indicates successful optimization.\n- **Quality Settings:** The quality setting can range from 0 to 95, but very low values might result in poor image quality.\n\n### Python Docstring\n\n```python\ndef _optimize_jpeg(\n    xref: Xref, in_jpg: Path, opt_jpg: Path, jpeg_quality: int\n) -> tuple[Xref, Path | None]:\n    \"\"\"\n    Optimizes a JPEG image by reducing its file size without significantly compromising the quality.\n\n    Parameters:\n        xref (Xref): A reference to the object in an OCRmyPDF context.\n        in_jpg (Path): The path to the input JPEG file that needs to be optimized.\n        opt_jpg (Path): The path where the optimized JPEG file will be saved.\n        jpeg_quality (int): An integer representing the quality of the output JPEG file, ranging from 0 (worst) to 95 (best).\n\n    Returns:\n        tuple[Xref, Path | None]: A tuple containing the updated Xref and the path to the optimized JPEG file or `None` if optimization did not reduce the file size.\n\n    Edge Cases:\n        - If the output file is larger than the input file, the function logs a debug message and skips further processing by deleting the output file.\n        - Very low quality settings might result in poor image quality.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_debug_rotate.py", "func_name": "get_orientation", "whole_func_string": "def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)", "func_code_string": "def get_orientation(input_file, options):\n        page = page_number(input_file)\n\n        angle = ((page - 1) * 90) % 360\n\n        return OrientationConfidence(angle=angle, confidence=99.9)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_debug_rotate.py\\nFunction/Class: get_orientation\\n```python\\ndef get_orientation(input_file, options):\\n        page = page_number(input_file)\\n\\n        angle = ((page - 1) * 90) % 360\\n\\n        return OrientationConfidence(angle=angle, confidence=99.9)\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `get_orientation` function is designed to determine the orientation of a document page based on its position in a multi-page input file. The function calculates an angle representing the rotation needed to orient the page correctly and returns this information along with a high level of confidence.\n\n### Parameters\n\n- **input_file (str)**: The path to the input file containing multiple pages.\n- **options (dict)**: A dictionary of options that may influence the orientation calculation. Currently, this parameter is not used in the function.\n\n### Behavior\n\n1. **Page Number Extraction**: The function extracts the page number from the `input_file` using a hypothetical `page_number` function.\n2. **Angle Calculation**: It calculates the rotation angle required to orient the page correctly. This is done by multiplying the (page - 1) by 90 degrees and taking modulo 360 to ensure the angle is within a standard 360-degree circle.\n3. **Orientation Confidence Object**: The function returns an `OrientationConfidence` object with the calculated angle and a high confidence level of 99.9.\n\n### Edge Cases\n\n- **Single Page File**: If the input file contains only one page, the calculation should return an angle of 0 degrees since no rotation is needed.\n- **Invalid Input**: The function assumes that the `page_number` function will handle invalid inputs gracefully and raise appropriate exceptions if necessary.\n\n### Python Docstring\n\n```python\ndef get_orientation(input_file: str, options: dict) -> OrientationConfidence:\n    \"\"\"\n    Determine the orientation of a document page based on its position in a multi-page input file.\n\n    Parameters:\n    - input_file (str): The path to the input file containing multiple pages.\n    - options (dict): A dictionary of options that may influence the orientation calculation. Currently, this parameter is not used.\n\n    Returns:\n    - OrientationConfidence: An object representing the calculated rotation angle and high confidence level.\n\n    Edge Cases:\n    - Single Page File: Returns an angle of 0 degrees since no rotation is needed.\n    - Invalid Input: The function assumes that the page_number function will handle invalid inputs gracefully.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_transcode_png", "whole_func_string": "def _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\n    output = filename.with_suffix('.png.pdf')\n    with output.open('wb') as f:\n        img2pdf.convert(fspath(filename), outputstream=f, **IMG2PDF_KWARGS)\n\n    with Pdf.open(output) as pdf_image:\n        foreign_image = next(iter(pdf_image.pages[0].images.values()))\n        local_image = pdf.copy_foreign(foreign_image)\n\n        im_obj = pdf.get_object(xref, 0)\n        im_obj.write(\n            local_image.read_raw_bytes(),\n            filter=local_image.Filter,\n            decode_parms=local_image.DecodeParms,\n        )\n\n                                               \n        del_keys = set(im_obj.keys()) - set(local_image.keys())\n                                                                          \n                                                                          \n                                                                         \n        keep_fields = {\n            '/ID',\n            '/Intent',\n            '/Interpolate',\n            '/Mask',\n            '/Metadata',\n            '/OC',\n            '/OPI',\n            '/SMask',\n            '/StructParent',\n        }\n        del_keys -= keep_fields\n        for key in local_image.keys():\n            if key != Name.Length and str(key) not in keep_fields:\n                im_obj[key] = local_image[key]\n        for key in del_keys:\n            del im_obj[key]\n    return True", "func_code_string": "def _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\n    output = filename.with_suffix('.png.pdf')\n    with output.open('wb') as f:\n        img2pdf.convert(fspath(filename), outputstream=f, **IMG2PDF_KWARGS)\n\n    with Pdf.open(output) as pdf_image:\n        foreign_image = next(iter(pdf_image.pages[0].images.values()))\n        local_image = pdf.copy_foreign(foreign_image)\n\n        im_obj = pdf.get_object(xref, 0)\n        im_obj.write(\n            local_image.read_raw_bytes(),\n            filter=local_image.Filter,\n            decode_parms=local_image.DecodeParms,\n        )\n\n                                               \n        del_keys = set(im_obj.keys()) - set(local_image.keys())\n                                                                          \n                                                                          \n                                                                         \n        keep_fields = {\n            '/ID',\n            '/Intent',\n            '/Interpolate',\n            '/Mask',\n            '/Metadata',\n            '/OC',\n            '/OPI',\n            '/SMask',\n            '/StructParent',\n        }\n        del_keys -= keep_fields\n        for key in local_image.keys():\n            if key != Name.Length and str(key) not in keep_fields:\n                im_obj[key] = local_image[key]\n        for key in del_keys:\n            del im_obj[key]\n    return True", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: _transcode_png\\n```python\\ndef _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\\n    output = filename.with_suffix('.png.pdf')\\n    with output.open('wb') as f:\\n        img2pdf.convert(fspath(filename), outputstream=f, **IMG2PDF_KWARGS)\\n\\n    with Pdf.open(output) as pdf_image:\\n        foreign_image = next(iter(pdf_image.pages[0].images.values()))\\n        local_image = pdf.copy_foreign(foreign_image)\\n\\n        im_obj = pdf.get_object(xref, 0)\\n        im_obj.write(\\n            local_image.read_raw_bytes(),\\n            filter=local_image.Filter,\\n            decode_parms=local_image.DecodeParms,\\n        )\\n\\n                                               \\n        del_keys = set(im_obj.keys()) - set(local_image.keys())\\n                                                                          \\n                                                                          \\n                                                                         \\n        keep_fields = {\\n            '/ID',\\n            '/Intent',\\n            '/Interpolate',\\n            '/Mask',\\n            '/Metadata',\\n            '/OC',\\n            '/OPI',\\n            '/SMask',\\n            '/StructParent',\\n        }\\n        del_keys -= keep_fields\\n        for key in local_image.keys():\\n            if key != Name.Length and str(key) not in keep_fields:\\n                im_obj[key] = local_image[key]\\n        for key in del_keys:\\n            del im_obj[key]\\n    return True\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe `_transcode_png` function is designed to transcode a PNG image embedded within a PDF file into a more efficient format. This process involves converting the PNG image to a different format, replacing the original image in the PDF, and then cleaning up any unnecessary metadata or properties.\n\n### Parameters\n- `pdf`: An instance of the `Pdf` class representing the PDF document containing the PNG image.\n- `filename`: A `Path` object representing the path to the original PDF file.\n- `xref`: An instance of the `Xref` class representing the cross-reference table for the PDF.\n\n### Behavior\n1. **Conversion**: The function converts the PNG image to a different format using the `img2pdf.convert` method, which outputs a new PDF file with the image embedded in it.\n2. **Replacement**: It then opens this new PDF file and extracts the transcoded image.\n3. **Update**: The original PDF is updated by replacing the old image with the newly transcoded one.\n4. **Metadata Cleanup**: Any unnecessary metadata or properties from the original image are removed, leaving only essential ones.\n\n### Edge Cases\n- **File Not Found**: If the input file does not exist, an error will be raised.\n- **PDF Structure Changes**: The function assumes that the PDF has a specific structure with images embedded in it. If the structure is different, the function may not work as expected.\n- **Image Corruption**: If the PNG image within the PDF is corrupted or invalid, the transcoding process might fail.\n\n### Summary\n```python\ndef _transcode_png(pdf: Pdf, filename: Path, xref: Xref) -> bool:\n    \"\"\"\n    Transcodes a PNG image embedded in a PDF file into a more efficient format.\n\n    Parameters:\n    - pdf (Pdf): The PDF document containing the PNG image.\n    - filename (Path): The path to the original PDF file.\n    - xref (Xref): The cross-reference table for the PDF.\n\n    Returns:\n    - bool: True if the transcoding is successful, False otherwise.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/conftest.py", "func_name": "check_ocrmypdf", "whole_func_string": "def check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\n                                                                          \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n    api.check_options(options, plugin_manager)\n    result = api.run_pipeline(options, plugin_manager=plugin_manager)\n\n    assert result == 0\n    assert output_file.exists(), \"Output file not created\"\n    assert output_file.stat().st_size > 100, \"PDF too small or empty\"\n\n    return output_file", "func_code_string": "def check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\n                                                                          \n    api_args = [str(input_file), str(output_file)] + [\n        str(arg) for arg in args if arg is not None\n    ]\n\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\n    api.check_options(options, plugin_manager)\n    result = api.run_pipeline(options, plugin_manager=plugin_manager)\n\n    assert result == 0\n    assert output_file.exists(), \"Output file not created\"\n    assert output_file.stat().st_size > 100, \"PDF too small or empty\"\n\n    return output_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/conftest.py\\nFunction/Class: check_ocrmypdf\\n```python\\ndef check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\\n                                                                          \\n    api_args = [str(input_file), str(output_file)] + [\\n        str(arg) for arg in args if arg is not None\\n    ]\\n\\n    _parser, options, plugin_manager = get_parser_options_plugins(args=api_args)\\n    api.check_options(options, plugin_manager)\\n    result = api.run_pipeline(options, plugin_manager=plugin_manager)\\n\\n    assert result == 0\\n    assert output_file.exists(), \\\"Output file not created\\\"\\n    assert output_file.stat().st_size > 100, \\\"PDF too small or empty\\\"\\n\\n    return output_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n**High-level purpose of the function:**\nThe `check_ocrmypdf` function is designed to automate the process of applying OCR (Optical Character Recognition) to a PDF file using the `ocrmypdf` library. It ensures that the OCR operation completes successfully and produces a valid, non-empty output file.\n\n**Analysis of parameters:**\n- **input_file:** A `Path` object representing the input PDF file that needs to be processed.\n- **output_file:** A `Path` object representing the path where the OCR-processed PDF will be saved.\n- **args:** Variable-length arguments that can include additional options for the OCR process.\n\n**Behavior:**\n1. The function constructs a command-line argument list (`api_args`) from the provided inputs and any optional arguments, excluding those that are `None`.\n2. It uses these arguments to parse options and plugins required for the OCR operation.\n3. It checks if the provided options are valid using `api.check_options`.\n4. It runs the OCR pipeline using `api.run_pipeline` with the parsed options and plugin manager.\n5. The function asserts that the OCR process was successful (`result == 0`), that the output file exists, and that the output file is not empty or too small.\n\n**Edge cases:**\n- If any of the provided arguments are invalid (e.g., non-existent input file, invalid options), the function will raise an assertion error.\n- If the OCR process fails (`result != 0`), or if the output file does not meet the size criteria, the function will also raise an assertion error.\n\n**Python docstring:**\n```python\ndef check_ocrmypdf(input_file: Path, output_file: Path, *args) -> Path:\n    \"\"\"\n    Apply OCR to a PDF file using ocrmypdf and validate the output.\n\n    Parameters:\n    input_file (Path): The path to the input PDF file.\n    output_file (Path): The path where the OCR-processed PDF will be saved.\n    *args: Additional arguments for the OCR process, optional.\n\n    Returns:\n    Path: The path to the output PDF file after OCR processing.\n\n    Raises:\n    AssertionError: If the OCR process fails or the output file is invalid.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_corrupt_font_detection", "whole_func_string": "def test_corrupt_font_detection(resources, testfile):\n    filename = resources / testfile\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\n    assert pdf[0].has_corrupt_text", "func_code_string": "def test_corrupt_font_detection(resources, testfile):\n    filename = resources / testfile\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\n    assert pdf[0].has_corrupt_text", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: test_corrupt_font_detection\\n```python\\ndef test_corrupt_font_detection(resources, testfile):\\n    filename = resources / testfile\\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\\n    assert pdf[0].has_corrupt_text\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe high-level purpose of the `test_corrupt_font_detection` function is to verify that it correctly identifies whether a font in a PDF file is corrupt. This function takes two parameters: `resources`, which likely provides access to test files, and `testfile`, the specific PDF file to be tested.\n\n### Analysis of Parameters\n\n- **resources**: A parameter that should provide access to resources or test files necessary for testing.\n- **testfile**: The name of the PDF file to be tested for corrupt font detection.\n\n### Behavior and Edge Cases\n\nThe function uses `pdfinfo.PdfInfo` to analyze a PDF file with detailed analysis enabled. It then checks if the first element in the result (`pdf[0]`) has a corrupt text attribute (`has_corrupt_text`). The assertion ensures that this attribute is `True`, indicating that the font detection algorithm correctly identifies corruption.\n\n### Edge Cases\n\n- **Empty or Invalid File**: If `testfile` does not exist or is invalid, `pdfinfo.PdfInfo` should handle it gracefully.\n- **No Font Corruption**: The test should also cover cases where there are no corrupt fonts in the PDF to ensure the function behaves correctly in such scenarios.\n\n### Python Docstring\n\n```python\ndef test_corrupt_font_detection(resources, testfile):\n    \"\"\"\n    Test the detection of corrupt fonts in a PDF file.\n\n    Parameters:\n    - resources: A resource manager or directory providing access to test files.\n    - testfile: The name of the PDF file to be tested for corrupt font detection.\n\n    This function asserts that a corrupt font is correctly identified within the first element\n    of the PDF analysis result. It verifies that `has_corrupt_text` attribute is True,\n    indicating successful corrupt font detection.\n    \"\"\"\n    filename = resources / testfile\n    pdf = pdfinfo.PdfInfo(filename, detailed_analysis=True)\n    assert pdf[0].has_corrupt_text\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/cli.py", "func_name": "str_to_int", "whole_func_string": "def str_to_int(mapping: Mapping[str, int]):\n                                                             \n\n    def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None\n\n    return _str_to_int", "func_code_string": "def str_to_int(mapping: Mapping[str, int]):\n                                                             \n\n    def _str_to_int(s: str) -> int:\n        try:\n            return mapping[s]\n        except KeyError:\n            raise argparse.ArgumentTypeError(\n                f\"{s!r} must be one of: {', '.join(mapping.keys())}\"\n            ) from None\n\n    return _str_to_int", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/cli.py\\nFunction/Class: str_to_int\\n```python\\ndef str_to_int(mapping: Mapping[str, int]):\\n                                                             \\n\\n    def _str_to_int(s: str) -> int:\\n        try:\\n            return mapping[s]\\n        except KeyError:\\n            raise argparse.ArgumentTypeError(\\n                f\\\"{s!r} must be one of: {', '.join(mapping.keys())}\\\"\\n            ) from None\\n\\n    return _str_to_int\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The `str_to_int` function is designed to create a custom type converter for use with command-line arguments, specifically for converting string inputs into integer values based on a predefined mapping.\n\n2. **Parameters**:\n   - `mapping`: A dictionary where keys are strings and values are integers. This mapping defines the allowable string-to-integer conversions.\n\n3. **Behavior**:\n   - The function returns another function `_str_to_int`, which takes a single argument `s` of type string.\n   - When called, `_str_to_int` attempts to retrieve the integer value associated with the string `s` from the provided mapping.\n   - If the string `s` is found in the mapping, its corresponding integer value is returned.\n   - If the string `s` is not found in the mapping, an `argparse.ArgumentTypeError` is raised with a message indicating that the input must be one of the allowed values.\n\n4. **Edge Cases**:\n   - The function will raise an error if the input string `s` is not present in the mapping.\n   - If the mapping is empty or incorrectly configured, the function may raise unexpected errors when trying to convert strings.\n\n5. **Docstring/Summary**:\n   ```python\n   def str_to_int(mapping: Mapping[str, int]) -> Callable[[str], int]:\n       \"\"\"\n       Create a custom type converter for command-line arguments that converts strings to integers based on a predefined mapping.\n\n       Args:\n           mapping (Mapping[str, int]): A dictionary mapping string keys to integer values.\n\n       Returns:\n           Callable[[str], int]: A function that takes a string and returns its corresponding integer value from the mapping.\n           If the string is not in the mapping, raises argparse.ArgumentTypeError with a list of allowed values.\n       \"\"\"\n   ```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "extract_image_generic", "whole_func_string": "def extract_image_generic(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                   \n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n                                                                        \n    if pim.bits_per_component == 1:\n        return None\n\n    if filtdp[0] == Name.DCTDecode and options.optimize >= 2:\n                                                                              \n                                                                          \n                                                                             \n                   \n                                                          \n                                                                    \n                                        \n                         \n        try:\n            imgname = root / f'{xref:08d}'\n            with imgname.open('wb') as f:\n                ext = pim.extract_to(stream=f)\n            imgname.rename(imgname.with_suffix(ext))\n        except (UnsupportedImageTypeError, HifiPrintImageNotTranscodableError):\n            return None\n        return XrefExt(xref, ext)\n    elif (\n        pim.indexed\n        and pim.colorspace in pim.SIMPLE_COLORSPACES\n        and options.optimize >= 3\n    ):\n                                                                           \n                             \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n    elif not pim.indexed and pim.colorspace in pim.SIMPLE_COLORSPACES:\n                                                                            \n                                               \n        try:\n            pim.as_pil_image().save(png_name(root, xref))\n        except NotImplementedError:\n            log.warning(\"PDF contains an atypical image that cannot be optimized.\")\n            return None\n        return XrefExt(xref, '.png')\n    elif (\n        not pim.indexed\n        and pim.colorspace == Name.ICCBased\n        and pim.bits_per_component == 1\n        and not options.jbig2_lossy\n    ):\n                                                                           \n                                                                           \n                     \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n\n    return None", "func_code_string": "def extract_image_generic(\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\n) -> XrefExt | None:\n                                   \n    result = extract_image_filter(image, xref)\n    if result is None:\n        return None\n    pim, filtdp = result\n\n                                                                        \n    if pim.bits_per_component == 1:\n        return None\n\n    if filtdp[0] == Name.DCTDecode and options.optimize >= 2:\n                                                                              \n                                                                          \n                                                                             \n                   \n                                                          \n                                                                    \n                                        \n                         \n        try:\n            imgname = root / f'{xref:08d}'\n            with imgname.open('wb') as f:\n                ext = pim.extract_to(stream=f)\n            imgname.rename(imgname.with_suffix(ext))\n        except (UnsupportedImageTypeError, HifiPrintImageNotTranscodableError):\n            return None\n        return XrefExt(xref, ext)\n    elif (\n        pim.indexed\n        and pim.colorspace in pim.SIMPLE_COLORSPACES\n        and options.optimize >= 3\n    ):\n                                                                           \n                             \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n    elif not pim.indexed and pim.colorspace in pim.SIMPLE_COLORSPACES:\n                                                                            \n                                               \n        try:\n            pim.as_pil_image().save(png_name(root, xref))\n        except NotImplementedError:\n            log.warning(\"PDF contains an atypical image that cannot be optimized.\")\n            return None\n        return XrefExt(xref, '.png')\n    elif (\n        not pim.indexed\n        and pim.colorspace == Name.ICCBased\n        and pim.bits_per_component == 1\n        and not options.jbig2_lossy\n    ):\n                                                                           \n                                                                           \n                     \n        pim.as_pil_image().save(png_name(root, xref))\n        return XrefExt(xref, '.png')\n\n    return None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: extract_image_generic\\n```python\\ndef extract_image_generic(\\n    *, pdf: Pdf, root: Path, image: Stream, xref: Xref, options\\n) -> XrefExt | None:\\n                                   \\n    result = extract_image_filter(image, xref)\\n    if result is None:\\n        return None\\n    pim, filtdp = result\\n\\n                                                                        \\n    if pim.bits_per_component == 1:\\n        return None\\n\\n    if filtdp[0] == Name.DCTDecode and options.optimize >= 2:\\n                                                                              \\n                                                                          \\n                                                                             \\n                   \\n                                                          \\n                                                                    \\n                                        \\n                         \\n        try:\\n            imgname = root / f'{xref:08d}'\\n            with imgname.open('wb') as f:\\n                ext = pim.extract_to(stream=f)\\n            imgname.rename(imgname.with_suffix(ext))\\n        except (UnsupportedImageTypeError, HifiPrintImageNotTranscodableError):\\n            return None\\n        return XrefExt(xref, ext)\\n    elif (\\n        pim.indexed\\n        and pim.colorspace in pim.SIMPLE_COLORSPACES\\n        and options.optimize >= 3\\n    ):\\n                                                                           \\n                             \\n        pim.as_pil_image().save(png_name(root, xref))\\n        return XrefExt(xref, '.png')\\n    elif not pim.indexed and pim.colorspace in pim.SIMPLE_COLORSPACES:\\n                                                                            \\n                                               \\n        try:\\n            pim.as_pil_image().save(png_name(root, xref))\\n        except NotImplementedError:\\n            log.warning(\\\"PDF contains an atypical image that cannot be optimized.\\\")\\n            return None\\n        return XrefExt(xref, '.png')\\n    elif (\\n        not pim.indexed\\n        and pim.colorspace == Name.ICCBased\\n        and pim.bits_per_component == 1\\n        and not options.jbig2_lossy\\n    ):\\n                                                                           \\n                                                                           \\n                     \\n        pim.as_pil_image().save(png_name(root, xref))\\n        return XrefExt(xref, '.png')\\n\\n    return None\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `extract_image_generic` function is designed to extract images from a PDF file and optimize them using various filters and image formats. It processes different types of images based on their properties and user-defined optimization options, and saves the optimized images to disk.\n\n### Parameters\n\n- **pdf**: The `Pdf` object representing the PDF document.\n- **root**: The directory path where the output files will be saved.\n- **image**: The `Stream` object representing the image stream to be extracted.\n- **xref**: The `Xref` object containing information about the image's cross-reference in the PDF file.\n- **options**: An object containing various optimization options.\n\n### Behavior\n\n1. **Filter Extraction**: The function first attempts to extract and filter the image using a generic filter (`extract_image_filter`). If no result is obtained, it returns `None`.\n2. **Bit Depth Check**: If the image has a bit depth of 1 (i.e., a monochrome image), it skips further processing.\n3. **JPEG Filter Optimization**:\n   - If the image uses the DCTDecode filter and the optimization level is 2 or higher, it saves the image as a PNG file using `as_pil_image().save`.\n4. **Indexed Image Optimization**:\n   - For indexed images with simple colorspaces and an optimization level of 3 or higher, it also saves them as PNG files.\n5. **Simple Colorspace Images**:\n   - For non-indexed images with simple colorspaces, it attempts to save them as PNG files. If not supported, it logs a warning and returns `None`.\n6. **ICCBased Image Optimization**:\n   - For images using the ICCBased colorspace with 1 bit per component and no JBIG2 lossy optimization, it also saves them as PNG files.\n\n### Edge Cases\n\n- **Unsupported Filter Types**: If the filter type is not supported (e.g., `UnsupportedImageTypeError`, `HifiPrintImageNotTranscodableError`), the function returns `None`.\n- **Atypical Images**: If an image cannot be converted to a PIL image due to atypical properties, it logs a warning and returns `None`.\n\n### Summary\n\nThe `extract_image_generic` function processes images from a PDF file based on their properties and optimization options. It saves optimized images as PNG files and handles various edge cases related to unsupported filters and image types."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_api.py", "func_name": "test_language_list", "whole_func_string": "def test_language_list():\n    with pytest.raises(\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\n    ):\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])", "func_code_string": "def test_language_list():\n    with pytest.raises(\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\n    ):\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_api.py\\nFunction/Class: test_language_list\\n```python\\ndef test_language_list():\\n    with pytest.raises(\\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\\n    ):\\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\nThe `test_language_list` function is designed to test the behavior of the OCRmyPDF library when it encounters a non-existent input file and attempts to specify multiple languages for OCR processing.\n\n### Parameters and Behavior\n- **Parameters**: None. The function does not accept any parameters.\n- **Behavior**:\n  - The function uses `pytest.raises` to assert that an exception is raised when attempting to run OCR on a non-existent PDF file (`'doesnotexist.pdf'`) and specifying languages (`['eng', 'deu']`).\n  - It checks for either `ocrmypdf.exceptions.InputFileError` or `ocrmypdf.exceptions.MissingDependencyError`, indicating issues with the input file or required dependencies.\n\n### Edge Cases\n- **Non-existent Input File**: The function tests how OCRmyPDF handles an attempt to process a file that does not exist.\n- **Invalid Language Codes**: Although not explicitly tested in this snippet, it's implied that specifying invalid language codes could also lead to errors.\n\n### Python Docstring\n```python\ndef test_language_list():\n    \"\"\"\n    Test the behavior of OCRmyPDF when attempting to process a non-existent PDF file\n    and specify multiple languages for OCR.\n    \n    Asserts that either `ocrmypdf.exceptions.InputFileError` or \n    `ocrmypdf.exceptions.MissingDependencyError` is raised, indicating issues with the input file\n    or required dependencies.\n    \"\"\"\n    with pytest.raises(\n        (ocrmypdf.exceptions.InputFileError, ocrmypdf.exceptions.MissingDependencyError)\n    ):\n        ocrmypdf.ocr('doesnotexist.pdf', '_.pdf', language=['eng', 'deu'])\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "UnsupportedImageFormatError", "whole_func_string": "class UnsupportedImageFormatError(ExitCodeException):\n                                            \n\n    exit_code = ExitCode.input_file", "func_code_string": "class UnsupportedImageFormatError(ExitCodeException):\n                                            \n\n    exit_code = ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/exceptions.py\\nFunction/Class: UnsupportedImageFormatError\\n```python\\nclass UnsupportedImageFormatError(ExitCodeException):\\n                                            \\n\\n    exit_code = ExitCode.input_file\\n```\", \"assistant\": \"\"}", "response": "## Purpose-First Chain-of-Thought for `UnsupportedImageFormatError`\n\n### High-Level Purpose\n\nThe `UnsupportedImageFormatError` class is a custom exception designed to handle scenarios where the input image format is not supported by the OCRmypdf application. This error extends from a base `ExitCodeException`, indicating that it involves an exit code related to input file handling.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**:\n  - None explicitly defined in the class definition, as inheritance takes care of any necessary parameters.\n\n- **Behavior**:\n  - The class is designed to be instantiated when an attempt is made to process an image with a format that OCRmypdf does not support.\n  - It inherits from `ExitCodeException`, which implies it will handle exit codes related to input file issues. Specifically, it uses the `exit_code` attribute set to `ExitCode.input_file`.\n\n- **Edge Cases**:\n  - Any attempt to process an image with a format that OCRmypdf does not support.\n  - The error message should be clear and informative to help users identify the unsupported image format.\n\n### Concise Python Docstring\n\n```python\nclass UnsupportedImageFormatError(ExitCodeException):\n    \"\"\"\n    Exception raised when the input image format is not supported by OCRmypdf.\n\n    This exception extends ExitCodeException and uses the exit code related to input file handling.\n    \"\"\"\n    exit_code = ExitCode.input_file\n```\n\nThis docstring clearly states the purpose of the class, its relationship with `ExitCodeException`, and the specific exit code it uses. It provides a concise overview that helps users understand when and why this exception might be raised in OCRmypdf."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "_find_image_xrefs_container", "whole_func_string": "def _find_image_xrefs_container(\n    pdf: Pdf,\n    container: Object,\n    pageno: int,\n    include_xrefs: MutableSet[Xref],\n    exclude_xrefs: MutableSet[Xref],\n    pageno_for_xref: dict[Xref, int],\n    depth: int = 0,\n):\n                                                                                   \n    if depth > 10:\n        log.warning(\"Recursion depth exceeded in _find_image_xrefs_page\")\n        return\n    try:\n        xobjs = container.Resources.XObject\n    except AttributeError:\n        return\n    for _imname, image in dict(xobjs).items():\n        if image.objgen[1] != 0:\n            continue                                       \n        xref = Xref(image.objgen[0])\n        if xref in include_xrefs or xref in exclude_xrefs:\n            continue                     \n        if Name.Subtype in image and image.Subtype == Name.Form:\n                                        \n            log.debug(f\"Recursing into Form XObject {_imname} in page {pageno}\")\n            _find_image_xrefs_container(\n                pdf,\n                image,\n                pageno,\n                include_xrefs,\n                exclude_xrefs,\n                pageno_for_xref,\n                depth + 1,\n            )\n            continue\n        if Name.SMask in image:\n                               \n            smask_xref = Xref(image.SMask.objgen[0])\n            exclude_xrefs.add(smask_xref)\n            log.debug(f\"xref {smask_xref}: skipping image because it is an SMask\")\n        include_xrefs.add(xref)\n        log.debug(f\"xref {xref}: treating as an optimization candidate\")\n        if xref not in pageno_for_xref:\n            pageno_for_xref[xref] = pageno", "func_code_string": "def _find_image_xrefs_container(\n    pdf: Pdf,\n    container: Object,\n    pageno: int,\n    include_xrefs: MutableSet[Xref],\n    exclude_xrefs: MutableSet[Xref],\n    pageno_for_xref: dict[Xref, int],\n    depth: int = 0,\n):\n                                                                                   \n    if depth > 10:\n        log.warning(\"Recursion depth exceeded in _find_image_xrefs_page\")\n        return\n    try:\n        xobjs = container.Resources.XObject\n    except AttributeError:\n        return\n    for _imname, image in dict(xobjs).items():\n        if image.objgen[1] != 0:\n            continue                                       \n        xref = Xref(image.objgen[0])\n        if xref in include_xrefs or xref in exclude_xrefs:\n            continue                     \n        if Name.Subtype in image and image.Subtype == Name.Form:\n                                        \n            log.debug(f\"Recursing into Form XObject {_imname} in page {pageno}\")\n            _find_image_xrefs_container(\n                pdf,\n                image,\n                pageno,\n                include_xrefs,\n                exclude_xrefs,\n                pageno_for_xref,\n                depth + 1,\n            )\n            continue\n        if Name.SMask in image:\n                               \n            smask_xref = Xref(image.SMask.objgen[0])\n            exclude_xrefs.add(smask_xref)\n            log.debug(f\"xref {smask_xref}: skipping image because it is an SMask\")\n        include_xrefs.add(xref)\n        log.debug(f\"xref {xref}: treating as an optimization candidate\")\n        if xref not in pageno_for_xref:\n            pageno_for_xref[xref] = pageno", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: _find_image_xrefs_container\\n```python\\ndef _find_image_xrefs_container(\\n    pdf: Pdf,\\n    container: Object,\\n    pageno: int,\\n    include_xrefs: MutableSet[Xref],\\n    exclude_xrefs: MutableSet[Xref],\\n    pageno_for_xref: dict[Xref, int],\\n    depth: int = 0,\\n):\\n                                                                                   \\n    if depth > 10:\\n        log.warning(\\\"Recursion depth exceeded in _find_image_xrefs_page\\\")\\n        return\\n    try:\\n        xobjs = container.Resources.XObject\\n    except AttributeError:\\n        return\\n    for _imname, image in dict(xobjs).items():\\n        if image.objgen[1] != 0:\\n            continue                                       \\n        xref = Xref(image.objgen[0])\\n        if xref in include_xrefs or xref in exclude_xrefs:\\n            continue                     \\n        if Name.Subtype in image and image.Subtype == Name.Form:\\n                                        \\n            log.debug(f\\\"Recursing into Form XObject {_imname} in page {pageno}\\\")\\n            _find_image_xrefs_container(\\n                pdf,\\n                image,\\n                pageno,\\n                include_xrefs,\\n                exclude_xrefs,\\n                pageno_for_xref,\\n                depth + 1,\\n            )\\n            continue\\n        if Name.SMask in image:\\n                               \\n            smask_xref = Xref(image.SMask.objgen[0])\\n            exclude_xrefs.add(smask_xref)\\n            log.debug(f\\\"xref {smask_xref}: skipping image because it is an SMask\\\")\\n        include_xrefs.add(xref)\\n        log.debug(f\\\"xref {xref}: treating as an optimization candidate\\\")\\n        if xref not in pageno_for_xref:\\n            pageno_for_xref[xref] = pageno\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\nThe function `_find_image_xrefs_container` is part of a larger OCRmypdf optimization process. Its primary purpose is to recursively find and categorize image cross-references (Xrefs) within a PDF document's container objects, such as pages or form XObjects.\n\n### Detailed Analysis:\n\n1. **Purpose**:\n   - The function aims to identify image resources within a given PDF container object (like a page or a form XObject).\n   - It categorizes these images into either `include_xrefs` or `exclude_xrefs` sets based on specific conditions.\n   - If an image is part of a form XObject, it recursively explores the child form XObjects.\n   - The function also handles SMask objects, which are used for masking images and skips them from further processing.\n\n2. **Parameters**:\n   - `pdf`: The PDF document object containing all pages and resources.\n   - `container`: The current container object (e.g., a page or form XObject) being examined.\n   - `pageno`: The page number of the current container within the PDF.\n   - `include_xrefs`: A mutable set that will store image Xrefs to be included in further processing.\n   - `exclude_xrefs`: A mutable set that will store image Xrefs to be excluded from further processing.\n   - `pageno_for_xref`: A dictionary mapping image Xrefs to their respective page numbers.\n   - `depth`: An optional parameter indicating the current recursion depth (default is 0).\n\n3. **Behavior**:\n   - The function first checks if the recursion depth exceeds 10, logging a warning and returning if true to prevent infinite recursion.\n   - It then attempts to access the XObjects within the current container using `container.Resources.XObject`.\n   - For each image found in these resources, it checks various conditions:\n     - If the image is not an actual image object (i.e., its generation number is not 0), it skips it.\n     - If the image's Xref is already in either the include or exclude set, it continues to the next image.\n     - If the image is a form XObject, it recursively calls itself with this form XObject as the new container.\n     - If the image has an SMask, its Xref is added to the exclude set and the image is skipped.\n     - Otherwise, the image's Xref is added to the include set, marked as a candidate for optimization, and mapped to the current page number in the `pageno_for_xref` dictionary.\n\n4. **Edge Cases**:\n   - If the container does not have any XObjects, the function returns immediately.\n   - Deep recursion could potentially cause stack overflow if the PDF structure is deeply nested, though this is mitigated by the depth check.\n   - Images with SMasks are excluded to avoid processing them multiple times unnecessarily.\n\n### Summary:\n\nThe `_find_image_xrefs_container` function is a recursive utility for identifying and categorizing image resources within PDF containers. It ensures that images in form XObjects are explored recursively, while SMask objects are skipped. The function uses sets to track which images should be included or excluded based on various conditions, ultimately populating a dictionary with the page numbers associated with each image's Xref."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_pdfinfo.py", "func_name": "test_oversized_page", "whole_func_string": "def test_oversized_page(resources):\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\n    image = pdf[0].images[0]\n    assert image.width * image.dpi.x > 200, \"this is supposed to be oversized\"", "func_code_string": "def test_oversized_page(resources):\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\n    image = pdf[0].images[0]\n    assert image.width * image.dpi.x > 200, \"this is supposed to be oversized\"", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_pdfinfo.py\\nFunction/Class: test_oversized_page\\n```python\\ndef test_oversized_page(resources):\\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\\n    image = pdf[0].images[0]\\n    assert image.width * image.dpi.x > 200, \\\"this is supposed to be oversized\\\"\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe purpose of the `test_oversized_page` function is to verify that a specific page in a PDF file contains an image whose width exceeds 200 pixels when rendered at its original DPI.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n1. **Parameters**:\n   - `resources`: A path object representing the directory containing the test resources, specifically the PDF file named 'poster.pdf'.\n\n2. **Behavior**:\n   - The function creates an instance of `pdfinfo.PdfInfo` by passing the path to the 'poster.pdf' file.\n   - It then accesses the first page of the PDF and retrieves the first image from that page.\n   - The function asserts that the width of the image, when multiplied by its horizontal DPI (`.dpi.x`), is greater than 200 pixels. If this condition is not met, it raises an assertion error with the message \"this is supposed to be oversized\".\n\n3. **Edge Cases**:\n   - If 'poster.pdf' does not contain any images or if the image's width when rendered at its original DPI is not greater than 200 pixels, the function will raise an assertion error.\n   - The function assumes that the PDF file exists and is accessible via the `resources` path.\n\n### Concise Python Docstring\n\n```python\ndef test_oversized_page(resources):\n    \"\"\"\n    Test if the first image on the first page of 'poster.pdf' has a width greater than 200 pixels when rendered at its original DPI.\n    \n    Parameters:\n    resources (Path): Path to the directory containing the PDF file 'poster.pdf'.\n    \n    Raises:\n    AssertionError: If the image's width, when rendered at its original DPI, is not greater than 200 pixels.\n    \"\"\"\n    pdf = pdfinfo.PdfInfo(resources / 'poster.pdf')\n    image = pdf[0].images[0]\n    assert image.width * image.dpi.x > 200, \"this is supposed to be oversized\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/plugins/tesseract_noop.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return NoopOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return NoopOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/plugins/tesseract_noop.py\\nFunction/Class: get_ocr_engine\\n```python\\ndef get_ocr_engine():\\n    return NoopOcrEngine()\\n```\", \"assistant\": \"\"}", "response": "**High-Level Purpose of the Function**\nThe `get_ocr_engine` function is designed to retrieve an OCR (Optical Character Recognition) engine instance. In this specific case, it returns an instance of a `NoopOcrEngine`, which appears to be a mock or no-operation implementation of an OCR engine.\n\n**Parameter Analysis**\n- This function does not accept any parameters.\n\n**Behavior and Edge Cases**\n- The function always returns an instance of `NoopOcrEngine`.\n- There are no edge cases to consider since the function is stateless and simply instantiates and returns a predefined object.\n\n**Concise Python Docstring or Summary**\n```python\ndef get_ocr_engine():\n    \"\"\"\n    Returns a NoopOcrEngine instance, which is a mock OCR engine.\n    \n    Parameters:\n    None\n    \n    Returns:\n    NoopOcrEngine: An instance of the NoopOcrEngine class.\n    \"\"\"\n    return NoopOcrEngine()\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "ColorConversionNeededError", "whole_func_string": "class ColorConversionNeededError(BadArgsError):\n                                     \n\n    message = dedent(\n        \"\"\"\\\n        The input PDF has an unusual color space. Use\n        --color-conversion-strategy to convert to a common color space\n        such as RGB, or use --output-type pdf to skip PDF/A conversion\n        and retain the original color space.\n        \"\"\"\n    )", "func_code_string": "class ColorConversionNeededError(BadArgsError):\n                                     \n\n    message = dedent(\n        \"\"\"\\\n        The input PDF has an unusual color space. Use\n        --color-conversion-strategy to convert to a common color space\n        such as RGB, or use --output-type pdf to skip PDF/A conversion\n        and retain the original color space.\n        \"\"\"\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/exceptions.py\\nFunction/Class: ColorConversionNeededError\\n```python\\nclass ColorConversionNeededError(BadArgsError):\\n                                     \\n\\n    message = dedent(\\n        \\\"\\\"\\\"\\\\\\n        The input PDF has an unusual color space. Use\\n        --color-conversion-strategy to convert to a common color space\\n        such as RGB, or use --output-type pdf to skip PDF/A conversion\\n        and retain the original color space.\\n        \\\"\\\"\\\"\\n    )\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\nThe `ColorConversionNeededError` class is a custom exception designed to be raised when an OCR process encounters a PDF with an unusual color space that requires conversion. This error helps users understand why the OCR operation failed and provides guidance on how to resolve it.\n\n### Parameters, Behavior, and Edge Cases\n- **Parameters**: None\n  - The exception does not take any parameters as its behavior is predefined by the `message` attribute.\n\n- **Behavior**:\n  - When an instance of this class is raised, it will display a specific error message indicating that the input PDF contains an unusual color space.\n  - This message provides guidance on how to handle the situation:\n    - Use the `--color-conversion-strategy` option to convert the PDF to a common color space like RGB.\n    - Alternatively, use the `--output-type pdf` option to skip PDF/A conversion and retain the original color space.\n\n- **Edge Cases**:\n  - The error message is designed to be clear and informative, ensuring that users can easily understand what went wrong and how to proceed. There are no special edge cases to handle since the message is static.\n\n### Python Docstring\n```python\nclass ColorConversionNeededError(BadArgsError):\n    \"\"\"\n    The input PDF has an unusual color space. Use\n    --color-conversion-strategy to convert to a common color space\n    such as RGB, or use --output-type pdf to skip PDF/A conversion\n    and retain the original color space.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_missing_docinfo", "whole_func_string": "def test_missing_docinfo(resources, outpdf):\n    result = run_ocrmypdf_api(\n        resources / 'missing_docinfo.pdf',\n        outpdf,\n        '-l',\n        'eng',\n        '--skip-text',\n        '--plugin',\n        Path('tests/plugins/tesseract_noop.py'),\n    )\n    assert result == ExitCode.ok", "func_code_string": "def test_missing_docinfo(resources, outpdf):\n    result = run_ocrmypdf_api(\n        resources / 'missing_docinfo.pdf',\n        outpdf,\n        '-l',\n        'eng',\n        '--skip-text',\n        '--plugin',\n        Path('tests/plugins/tesseract_noop.py'),\n    )\n    assert result == ExitCode.ok", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_missing_docinfo\\n```python\\ndef test_missing_docinfo(resources, outpdf):\\n    result = run_ocrmypdf_api(\\n        resources / 'missing_docinfo.pdf',\\n        outpdf,\\n        '-l',\\n        'eng',\\n        '--skip-text',\\n        '--plugin',\\n        Path('tests/plugins/tesseract_noop.py'),\\n    )\\n    assert result == ExitCode.ok\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `test_missing_docinfo` is designed to test the behavior of an OCR (Optical Character Recognition) tool when applied to a PDF file that lacks metadata. The primary purpose is to ensure that the OCR tool handles such files correctly and returns an expected exit code.\n\n### Parameter Analysis\n- **resources**: A path object representing the directory containing the resource files used in the test.\n- **outpdf**: A path object specifying where the output PDF should be saved.\n\n### Behavior\nThe function calls `run_ocrmypdf_api` with specific arguments to perform OCR on a PDF file named 'missing_docinfo.pdf'. The command includes options such as language ('eng'), skipping text extraction, and using a custom plugin (`tesseract_noop.py`). It asserts that the exit code of the OCR operation is `ExitCode.ok`, indicating successful execution.\n\n### Edge Cases\n- If 'missing_docinfo.pdf' does not exist or cannot be accessed.\n- The OCR tool may behave unexpectedly if there are issues with the resource files or plugin configuration.\n- The output PDF file might not contain any changes due to the '--skip-text' option, which skips text extraction.\n\n### Python Docstring Summary\n```python\ndef test_missing_docinfo(resources, outpdf):\n    \"\"\"\n    Test OCR on a PDF without metadata to ensure proper handling and successful execution.\n\n    Parameters:\n    resources (pathlib.Path): Path to the directory containing resource files.\n    outpdf (pathlib.Path): Output path for the processed PDF file.\n\n    Asserts that the OCR operation completes successfully with an exit code of ExitCode.ok.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_unpaper.py", "func_name": "test_clean", "whole_func_string": "def test_clean(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_code_string": "def test_clean(resources, outpdf):\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin',\n        'tests/plugins/tesseract_noop.py',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_unpaper.py\\nFunction/Class: test_clean\\n```python\\ndef test_clean(resources, outpdf):\\n    check_ocrmypdf(\\n        resources / \\\"skew.pdf\\\",\\n        outpdf,\\n        \\\"-c\\\",\\n        '--plugin',\\n        'tests/plugins/tesseract_noop.py',\\n    )\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `test_clean` function is part of a test suite for the `unpaper` tool, specifically designed to verify that the OCR (Optical Character Recognition) process can be executed successfully with a custom plugin. The primary purpose is to ensure that the tool handles skew in PDF documents correctly and that plugins like Tesseract can be integrated seamlessly.\n\n### Parameters\n\n- **resources**: A path-like object representing the directory containing various resources used for testing, including the input PDF file.\n- **outpdf**: A path-like object where the output PDF file will be saved after processing by `unpaper`.\n\n### Behavior\n\nThe function calls another function `check_ocrmypdf` with specific arguments to simulate an OCR process on a skewed PDF document. The arguments include:\n- The path to the input PDF file, which is assumed to have skew and is located within the `resources` directory.\n- The output PDF file path where the processed result will be saved.\n- Command-line options `-c` (which may represent a cleaning option in OCRmypdf) and `--plugin tests/plugins/tesseract_noop.py`, indicating that a no-operation plugin for Tesseract should be used.\n\n### Edge Cases\n\n1. **Non-existent Input File**: If the input PDF file specified in `resources / \"skew.pdf\"` does not exist, the function will raise an error.\n2. **Invalid Output Path**: If the output path provided by `outpdf` is invalid or cannot be written to, the function may fail depending on how `check_ocrmypdf` handles such cases.\n3. **Plugin Errors**: Since a no-operation plugin for Tesseract is used, this edge case is likely not triggered unless there's an error in setting up the environment or handling the plugin.\n\n### Python Docstring\n\n```python\ndef test_clean(resources, outpdf):\n    \"\"\"\n    Test OCR processing on a skewed PDF using a custom no-operation Tesseract plugin.\n    \n    Parameters:\n    resources (path-like): The directory containing the input PDF file \"skew.pdf\".\n    outpdf (path-like): The path where the output PDF file will be saved after processing.\n    \n    Raises:\n    FileNotFoundError: If the input PDF file does not exist.\n    IOError: If there is an issue writing to the output path.\n    \"\"\"\n    check_ocrmypdf(\n        resources / \"skew.pdf\",\n        outpdf,\n        \"-c\",\n        '--plugin', 'tests/plugins/tesseract_noop.py',\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_exec/unpaper.py", "func_name": "__init__", "whole_func_string": "def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_code_string": "def __init__(\n        self,\n        w,\n        h,\n        message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\",\n    ):\n        self.w = w\n        self.h = h\n        self.message = message.format(w, h)\n        super().__init__(self.message)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_exec/unpaper.py\\nFunction/Class: __init__\\n```python\\ndef __init__(\\n        self,\\n        w,\\n        h,\\n        message=\\\"Image with size {}x{} is too large for cleaning with 'unpaper'.\\\",\\n    ):\\n        self.w = w\\n        self.h = h\\n        self.message = message.format(w, h)\\n        super().__init__(self.message)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `__init__` method of the class is responsible for initializing an instance with the width (`w`) and height (`h`) of an image, as well as a custom error message. The purpose is to create an exception object that contains these dimensions in its message, which can then be raised when the image size exceeds the acceptable limit for cleaning with 'unpaper'.\n\n### Parameters\n\n- `self`: Reference to the instance being created.\n- `w` (int): Width of the image.\n- `h` (int): Height of the image.\n- `message` (str, optional): Custom error message. Default is \"Image with size {}x{} is too large for cleaning with 'unpaper'.\"\n\n### Behavior\n\n1. The method sets the instance variables `w` and `h` to the provided width and height values, respectively.\n2. It formats the default error message using the provided width and height and assigns it to the `message` attribute.\n3. It calls the superclass constructor (`super().__init__(self.message)`) with the formatted message, effectively raising an exception with this message.\n\n### Edge Cases\n\n- If no custom message is provided, the default message will include the specific dimensions of the image.\n- The method does not perform any validation on the width and height values; it assumes they are valid integers.\n\n### Python Docstring or Summary\n\n```python\ndef __init__(self, w, h, message=\"Image with size {}x{} is too large for cleaning with 'unpaper'.\"):\n    \"\"\"\n    Initialize an exception object with the specified image dimensions and a custom error message.\n    \n    Parameters:\n    - w (int): Width of the image.\n    - h (int): Height of the image.\n    - message (str, optional): Custom error message. Default is \"Image with size {}x{} is too large for cleaning with 'unpaper'.\"\n\n    Raises:\n    - Exception: With a formatted message indicating the image size and why it is not suitable for cleaning with 'unpaper'.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipelines/_common.py", "func_name": "dict_to_object", "whole_func_string": "def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_code_string": "def dict_to_object(self, d):\n        if 'Path' in d:\n            return Path(d['Path'])\n        return d", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipelines/_common.py\\nFunction/Class: dict_to_object\\n```python\\ndef dict_to_object(self, d):\\n        if 'Path' in d:\\n            return Path(d['Path'])\\n        return d\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `dict_to_object` function is designed to convert dictionary data into a more structured object format, specifically converting paths specified under the key `'Path'` into Python's `Path` objects. This helps in handling file paths more conveniently and ensures that path-related operations can be performed directly on these objects.\n\n### Parameters\n- **d (dict)**: The input dictionary that may contain a key `'Path'`.\n\n### Behavior\n1. If the dictionary `d` contains a key `'Path'`, the function converts the value associated with this key into a `Path` object from Python's `pathlib` module.\n2. For any other dictionary, the function returns the dictionary unchanged.\n\n### Edge Cases\n- If the input is not a dictionary, the function will raise a `TypeError`.\n- If the dictionary does not contain the `'Path'` key, it returns the dictionary as is.\n\n### Python Docstring\n\n```python\ndef dict_to_object(self, d):\n    \"\"\"\n    Converts a dictionary into an object with Path handling.\n    \n    Args:\n        d (dict): The input dictionary that may contain a 'Path' key.\n        \n    Returns:\n        dict or Path: If 'Path' is in the dictionary, returns a Path object; otherwise, returns the original dictionary.\n        \n    Raises:\n        TypeError: If the input is not a dictionary.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise TypeError(\"Input must be a dictionary\")\n    \n    if 'Path' in d:\n        return Path(d['Path'])\n    return d\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_german", "whole_func_string": "def test_german(resources, outdir):\n                                                                        \n                                                                              \n                                                                 \n    sidecar = outdir / 'francais.txt'\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outdir / 'francais.pdf',\n            '-l',\n            'deu',                           \n            '--sidecar',\n            sidecar,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )\n    except MissingDependencyError:\n        if 'deu' not in tesseract.get_languages():\n            pytest.xfail(reason=\"tesseract-deu language pack not installed\")\n        raise", "func_code_string": "def test_german(resources, outdir):\n                                                                        \n                                                                              \n                                                                 \n    sidecar = outdir / 'francais.txt'\n    try:\n        check_ocrmypdf(\n            resources / 'francais.pdf',\n            outdir / 'francais.pdf',\n            '-l',\n            'deu',                           \n            '--sidecar',\n            sidecar,\n            '--plugin',\n            'tests/plugins/tesseract_cache.py',\n        )\n    except MissingDependencyError:\n        if 'deu' not in tesseract.get_languages():\n            pytest.xfail(reason=\"tesseract-deu language pack not installed\")\n        raise", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_german\\n```python\\ndef test_german(resources, outdir):\\n                                                                        \\n                                                                              \\n                                                                 \\n    sidecar = outdir / 'francais.txt'\\n    try:\\n        check_ocrmypdf(\\n            resources / 'francais.pdf',\\n            outdir / 'francais.pdf',\\n            '-l',\\n            'deu',                           \\n            '--sidecar',\\n            sidecar,\\n            '--plugin',\\n            'tests/plugins/tesseract_cache.py',\\n        )\\n    except MissingDependencyError:\\n        if 'deu' not in tesseract.get_languages():\\n            pytest.xfail(reason=\\\"tesseract-deu language pack not installed\\\")\\n        raise\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The function `test_german` is designed to test the OCR (Optical Character Recognition) functionality for German text using a specific PDF file. It checks if the Tesseract OCR engine can correctly recognize German text and generate a sidecar file with additional information.\n\n2. **Parameter Analysis**:\n   - `resources`: A directory containing the input PDF (`francais.pdf`) which is expected to have German content.\n   - `outdir`: The output directory where the processed PDF and sidecar files will be saved.\n\n3. **Behavior**:\n   - The function attempts to run OCR on a German PDF file using Tesseract with the language code 'deu'.\n   - It creates a sidecar file named `francais.txt` in the output directory.\n   - If the Tesseract 'deu' language pack is not installed, the test will be marked as an expected failure (`xfail`) and the reason for this will be provided.\n\n4. **Edge Cases**:\n   - The function assumes that the `check_ocrmypdf` function is properly defined and can handle the OCR process.\n   - If the 'deu' language pack is not installed, a `MissingDependencyError` is caught, and the test is marked as expected to fail with a specific reason.\n\n### Python Docstring or Summary\n\n```python\ndef test_german(resources, outdir):\n    \"\"\"\n    Test OCR functionality for German text using a specific PDF file.\n\n    Parameters:\n    resources (Path): Directory containing the input PDF (`francais.pdf`) with German content.\n    outdir (Path): Output directory where the processed PDF and sidecar files will be saved.\n\n    Raises:\n    MissingDependencyError: If the 'deu' Tesseract language pack is not installed, the test will be marked as expected to fail with a specific reason.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_plugin_manager.py", "func_name": "get_parser_options_plugins", "whole_func_string": "def get_parser_options_plugins(\n    args: Sequence[str],\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\n    pre_options, _unused = plugins_only_parser.parse_known_args(args=args)\n    plugin_manager = get_plugin_manager(pre_options.plugins)\n\n    parser = get_parser()\n    plugin_manager.hook.initialize(                             \n        plugin_manager=plugin_manager\n    )\n    plugin_manager.hook.add_options(parser=parser)                             \n\n    options = parser.parse_args(args=args)\n    return parser, options, plugin_manager", "func_code_string": "def get_parser_options_plugins(\n    args: Sequence[str],\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\n    pre_options, _unused = plugins_only_parser.parse_known_args(args=args)\n    plugin_manager = get_plugin_manager(pre_options.plugins)\n\n    parser = get_parser()\n    plugin_manager.hook.initialize(                             \n        plugin_manager=plugin_manager\n    )\n    plugin_manager.hook.add_options(parser=parser)                             \n\n    options = parser.parse_args(args=args)\n    return parser, options, plugin_manager", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_plugin_manager.py\\nFunction/Class: get_parser_options_plugins\\n```python\\ndef get_parser_options_plugins(\\n    args: Sequence[str],\\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\\n    pre_options, _unused = plugins_only_parser.parse_known_args(args=args)\\n    plugin_manager = get_plugin_manager(pre_options.plugins)\\n\\n    parser = get_parser()\\n    plugin_manager.hook.initialize(                             \\n        plugin_manager=plugin_manager\\n    )\\n    plugin_manager.hook.add_options(parser=parser)                             \\n\\n    options = parser.parse_args(args=args)\\n    return parser, options, plugin_manager\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe function `get_parser_options_plugins` is designed to manage the initialization and configuration of a command-line argument parser along with associated plugins. It processes input arguments, sets up a plugin manager, and integrates custom options from plugins into the main argument parser.\n\n### Analysis of Parameters, Behavior, and Edge Cases\n\n- **Parameters**:\n  - `args`: A sequence of strings representing command-line arguments.\n\n- **Behavior**:\n  - Parses only known arguments to identify if any plugins should be loaded.\n  - Initializes a plugin manager based on the identified plugins.\n  - Creates a default argument parser.\n  - Hooks into the plugin manager to initialize and add custom options to the parser.\n  - Parses all provided arguments, including those added by plugins.\n\n- **Edge Cases**:\n  - If no plugins are specified or recognized, the function will still return an argument parser with standard options and an empty plugin manager.\n  - If there is a parsing error due to invalid arguments, the function will raise an exception, causing the program to terminate.\n\n### Concise Python Docstring\n\n```python\ndef get_parser_options_plugins(\n    args: Sequence[str],  # Command-line arguments\n) -> tuple[argparse.ArgumentParser, argparse.Namespace, pluggy.PluginManager]:\n    \"\"\"\n    Initialize a command-line parser with custom options from plugins.\n\n    Parameters:\n    - args (Sequence[str]): Command-line arguments to be parsed.\n\n    Returns:\n    - tuple: A tuple containing the argument parser, parsed options, and plugin manager.\n    \n    Edge Cases:\n    - If no plugins are specified or recognized, returns an empty plugin manager.\n    - Raises exceptions on parsing errors.\n    \"\"\"\n```\n\nThis docstring clearly states the purpose of the function, its parameters, return values, and notes on edge cases."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/exceptions.py", "func_name": "ExitCodeException", "whole_func_string": "class ExitCodeException(Exception):\n                                                                        \n\n    exit_code = ExitCode.other_error\n    message = \"\"\n\n    def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_code_string": "class ExitCodeException(Exception):\n                                                                        \n\n    exit_code = ExitCode.other_error\n    message = \"\"\n\n    def __str__(self):\n                                                              \n        super_msg = super().__str__()                         \n        if self.message:\n            return self.message.format(super_msg)\n        return super_msg", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/exceptions.py\\nFunction/Class: ExitCodeException\\n```python\\nclass ExitCodeException(Exception):\\n                                                                        \\n\\n    exit_code = ExitCode.other_error\\n    message = \\\"\\\"\\n\\n    def __str__(self):\\n                                                              \\n        super_msg = super().__str__()                         \\n        if self.message:\\n            return self.message.format(super_msg)\\n        return super_msg\\n```\", \"assistant\": \"\"}", "response": "### High-Level Purpose\n\nThe `ExitCodeException` class is a custom exception in the OCRmyPDF library designed to handle and report errors related to the exit codes from the underlying OCR software. This exception extends Python's built-in `Exception` class, providing a structured way to communicate error details while maintaining compatibility with general exception handling mechanisms.\n\n### Parameters and Behavior\n\n- **exit_code (int)**: An integer representing the specific error code associated with the OCR operation. This value is stored as an attribute of the exception object.\n- **message (str)**: A string that provides a human-readable description of the error. If provided, this message will be formatted to include any additional context from the base exception.\n\n### Edge Cases\n\n1. **Default Message**: If no custom message is provided when raising the `ExitCodeException`, it defaults to an empty string.\n2. **Message Formatting**: If a custom message is provided, it is expected to use Python's string formatting (e.g., `{}` placeholders). The formatted message will include any details from the base exception.\n\n### Example Usage\n\n```python\ntry:\n    # Simulate OCR operation that fails\n    raise ExitCodeException(ExitCode.invalid_pdf, \"Failed to process PDF due to invalid format.\")\nexcept ExitCodeException as e:\n    print(e)  # Output: Failed to process PDF due to invalid format.\n```\n\n### Summary\n\nThe `ExitCodeException` class is used to encapsulate errors that occur during OCR operations, providing a structured way to report both the error code and any custom messages. This makes it easier to handle and debug issues related to OCR processing in applications that use OCRmyPDF."}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_tesseract_config_valid", "whole_func_string": "def test_tesseract_config_valid(resources, valid_tess_config, outpdf):\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--tesseract-config',\n        valid_tess_config,\n        '--pages',\n        '1',\n    )", "func_code_string": "def test_tesseract_config_valid(resources, valid_tess_config, outpdf):\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--tesseract-config',\n        valid_tess_config,\n        '--pages',\n        '1',\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_tesseract_config_valid\\n```python\\ndef test_tesseract_config_valid(resources, valid_tess_config, outpdf):\\n    check_ocrmypdf(\\n        resources / '3small.pdf',\\n        outpdf,\\n        '--tesseract-config',\\n        valid_tess_config,\\n        '--pages',\\n        '1',\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose\nThe function `test_tesseract_config_valid` is designed to test the functionality of OCRMyPDF when using a valid Tesseract configuration file for OCR processing.\n\n### Parameters\n- `resources`: A path object representing the directory containing input resources.\n- `valid_tess_config`: A path object pointing to a valid Tesseract configuration file that should be used during the OCR process.\n- `outpdf`: A path object indicating where the output PDF file should be saved after the OCR operation.\n\n### Behavior\nThe function uses the `check_ocrmypdf` utility to perform OCR on a specific page (`--pages 1`) of a PDF document located at `resources / '3small.pdf'`. It specifies the Tesseract configuration file using the `--tesseract-config` option. The output of the OCR process is saved to the location indicated by `outpdf`.\n\n### Edge Cases\n- If the specified `valid_tess_config` file does not exist or is invalid, the OCR process may fail or produce unexpected results.\n- If `resources / '3small.pdf'` does not contain a valid PDF document, the OCR process will likely fail.\n\n### Python Docstring\n```python\ndef test_tesseract_config_valid(resources, valid_tess_config, outpdf):\n    \"\"\"\n    Test OCRMyPDF functionality with a valid Tesseract configuration file for OCR processing.\n    \n    Parameters:\n    - resources (pathlib.Path): The path to the directory containing input resources.\n    - valid_tess_config (pathlib.Path): The path to the valid Tesseract configuration file.\n    - outpdf (pathlib.Path): The output PDF file path where the processed document will be saved.\n    \n    Edge Cases:\n    - Ensure that `valid_tess_config` is a valid Tesseract configuration file.\n    - Verify that `resources / '3small.pdf'` contains a valid PDF document for OCR processing.\n    \"\"\"\n    check_ocrmypdf(\n        resources / '3small.pdf',\n        outpdf,\n        '--tesseract-config',\n        valid_tess_config,\n        '--pages',\n        '1',\n    )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/_pipeline.py", "func_name": "enumerate_compress_ranges", "whole_func_string": "def enumerate_compress_ranges(\n    iterable: Iterable[T],\n) -> Iterator[tuple[tuple[int, int], T | None]]:\n           \n    skipped_from, index = None, None\n    for index, txt_file in enumerate(iterable):\n        index += 1\n        if txt_file:\n            if skipped_from is not None:\n                yield (skipped_from, index - 1), None\n                skipped_from = None\n            yield (index, index), txt_file\n        else:\n            if skipped_from is None:\n                skipped_from = index\n    if skipped_from is not None:\n        yield (skipped_from, index), None", "func_code_string": "def enumerate_compress_ranges(\n    iterable: Iterable[T],\n) -> Iterator[tuple[tuple[int, int], T | None]]:\n           \n    skipped_from, index = None, None\n    for index, txt_file in enumerate(iterable):\n        index += 1\n        if txt_file:\n            if skipped_from is not None:\n                yield (skipped_from, index - 1), None\n                skipped_from = None\n            yield (index, index), txt_file\n        else:\n            if skipped_from is None:\n                skipped_from = index\n    if skipped_from is not None:\n        yield (skipped_from, index), None", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/_pipeline.py\\nFunction/Class: enumerate_compress_ranges\\n```python\\ndef enumerate_compress_ranges(\\n    iterable: Iterable[T],\\n) -> Iterator[tuple[tuple[int, int], T | None]]:\\n           \\n    skipped_from, index = None, None\\n    for index, txt_file in enumerate(iterable):\\n        index += 1\\n        if txt_file:\\n            if skipped_from is not None:\\n                yield (skipped_from, index - 1), None\\n                skipped_from = None\\n            yield (index, index), txt_file\\n        else:\\n            if skipped_from is None:\\n                skipped_from = index\\n    if skipped_from is not None:\\n        yield (skipped_from, index), None\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `enumerate_compress_ranges` function processes an iterable of text files and generates a sequence of ranges indicating which indices are compressed (i.e., non-empty) in the input. It also yields `None` for empty items.\n\n### Parameters\n\n- **iterable**: An iterable of text files (`Iterable[T]`). Each item is expected to be either a string (representing a text file) or `None`.\n\n### Behavior\n\n1. The function iterates over each item in the input iterable.\n2. For each item, it checks if the item is non-empty:\n   - If it is non-empty and was preceded by a skipped range (`skipped_from` is not `None`), it yields a tuple containing the range of indices that were skipped (inclusive) and `None`.\n   - It then yields a tuple with the current index as both the start and end, along with the item itself.\n3. If an item is empty:\n   - If there was no previous skipped range (`skipped_from` is `None`), it marks the current index as the start of a new skipped range by setting `skipped_from` to the current index.\n4. After iterating through all items, if there is a remaining skipped range (i.e., `skipped_from` is not `None`), it yields the final range along with `None`.\n\n### Edge Cases\n\n- If the input iterable is empty, no output will be generated.\n- If the first item in the iterable is empty, the function will immediately mark it as the start of a skipped range.\n\n### Example Usage\n\n```python\ntexts = [\"Hello\", None, \"World\", \"\", \"Python\"]\nfor (start, end), txt_file in enumerate_compress_ranges(texts):\n    print(f\"Range: ({start}, {end}), Text: {txt_file}\")\n```\n\nOutput:\n```\nRange: (0, 0), Text: Hello\nRange: (2, 2), Text: World\nRange: (4, 4), Text: Python\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/optimize.py", "func_name": "transcode_jpegs", "whole_func_string": "def transcode_jpegs(\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\n) -> None:\n                                                            \n\n    def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality\n\n    def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                   \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Recompressing JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_optimize_jpeg,\n        task_arguments=jpeg_args(),\n        task_finished=finish_jpeg,\n    )", "func_code_string": "def transcode_jpegs(\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\n) -> None:\n                                                            \n\n    def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\n        for xref in jpegs:\n            in_jpg = jpg_name(root, xref)\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality\n\n    def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\n        xref, opt_jpg = result\n        if opt_jpg:\n            compdata = opt_jpg.read_bytes()                                    \n            im_obj = pdf.get_object(xref, 0)\n            im_obj.write(compdata, filter=Name.DCTDecode)\n        pbar.update()\n\n    executor(\n        use_threads=True,                                                   \n        max_workers=options.jobs,\n        progress_kwargs=dict(\n            desc=\"Recompressing JPEGs\",\n            total=len(jpegs),\n            unit='image',\n            disable=not options.progress_bar,\n        ),\n        task=_optimize_jpeg,\n        task_arguments=jpeg_args(),\n        task_finished=finish_jpeg,\n    )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/optimize.py\\nFunction/Class: transcode_jpegs\\n```python\\ndef transcode_jpegs(\\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\\n) -> None:\\n                                                            \\n\\n    def jpeg_args() -> Iterator[tuple[Xref, Path, Path, int]]:\\n        for xref in jpegs:\\n            in_jpg = jpg_name(root, xref)\\n            opt_jpg = in_jpg.with_suffix('.opt.jpg')\\n            yield xref, in_jpg, opt_jpg, options.jpeg_quality\\n\\n    def finish_jpeg(result: tuple[Xref, Path | None], pbar: ProgressBar):\\n        xref, opt_jpg = result\\n        if opt_jpg:\\n            compdata = opt_jpg.read_bytes()                                    \\n            im_obj = pdf.get_object(xref, 0)\\n            im_obj.write(compdata, filter=Name.DCTDecode)\\n        pbar.update()\\n\\n    executor(\\n        use_threads=True,                                                   \\n        max_workers=options.jobs,\\n        progress_kwargs=dict(\\n            desc=\\\"Recompressing JPEGs\\\",\\n            total=len(jpegs),\\n            unit='image',\\n            disable=not options.progress_bar,\\n        ),\\n        task=_optimize_jpeg,\\n        task_arguments=jpeg_args(),\\n        task_finished=finish_jpeg,\\n    )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\nThe `transcode_jpegs` function is designed to optimize JPEG images within a PDF file. It processes a sequence of JPEG references in the PDF, compresses them using specified options, and updates the PDF with the optimized images.\n\n### Parameters\n\n1. **pdf (Pdf)**: The input PDF file containing JPEGs that need optimization.\n2. **jpegs (Sequence[Xref])**: A sequence of JPEG reference objects within the PDF.\n3. **root (Path)**: The root directory used for temporary files.\n4. **options**: An object containing various configuration options, including `jpeg_quality` and `jobs`.\n5. **executor (Executor)**: An executor object responsible for managing parallel execution.\n\n### Behavior\n\n1. **JPEG Argument Generator**: The function defines an inner generator `jpeg_args` that yields tuples containing the JPEG reference, input JPEG file path, output JPEG file path, and the JPEG quality option.\n2. **Finish JPEG Function**: The inner function `finish_jpeg` is called after each JPEG optimization task is completed. It updates a progress bar if enabled and updates the PDF object with the optimized JPEG data.\n3. **Parallel Execution**: The main part of the function uses the provided executor to perform JPEG optimizations in parallel. It sets up a progress bar with appropriate parameters and specifies `_optimize_jpeg` as the task to be executed for each JPEG.\n\n### Edge Cases\n\n- If `options.progress_bar` is `False`, the progress bar will not be displayed.\n- If any error occurs during JPEG optimization, it will need to be handled by the caller of this function, as it does not raise exceptions itself.\n- The function assumes that the input PDF and JPEG references are valid and correctly formatted.\n\n### Python Docstring\n\n```python\ndef transcode_jpegs(\n    pdf: Pdf, jpegs: Sequence[Xref], root: Path, options, executor: Executor\n) -> None:\n    \"\"\"\n    Optimize JPEG images within a PDF file in parallel.\n\n    Parameters:\n    pdf (Pdf): The input PDF file containing JPEGs that need optimization.\n    jpegs (Sequence[Xref]): A sequence of JPEG reference objects within the PDF.\n    root (Path): The root directory used for temporary files.\n    options: An object containing various configuration options, including `jpeg_quality` and `jobs`.\n    executor (Executor): An executor object responsible for managing parallel execution.\n\n    This function processes a sequence of JPEG references in the PDF, compresses them using specified options,\n    and updates the PDF with the optimized images. It utilizes parallel processing to speed up the optimization\n    process.\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/subprocess/_windows.py", "func_name": "ghostscript_version_key", "whole_func_string": "def ghostscript_version_key(s: str) -> tuple[int, int, int]:\n                                              \n    try:\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\n        while len(release) < 3:\n            release.append(0)\n        return (release[0], release[1], release[2])\n    except ValueError:\n        return (0, 0, 0)", "func_code_string": "def ghostscript_version_key(s: str) -> tuple[int, int, int]:\n                                              \n    try:\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\n        while len(release) < 3:\n            release.append(0)\n        return (release[0], release[1], release[2])\n    except ValueError:\n        return (0, 0, 0)", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/subprocess/_windows.py\\nFunction/Class: ghostscript_version_key\\n```python\\ndef ghostscript_version_key(s: str) -> tuple[int, int, int]:\\n                                              \\n    try:\\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\\n        while len(release) < 3:\\n            release.append(0)\\n        return (release[0], release[1], release[2])\\n    except ValueError:\\n        return (0, 0, 0)\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n#### High-Level Purpose\nThe `ghostscript_version_key` function is designed to parse a string representing a version number of GhostScript and convert it into a tuple of integers. This allows for easy comparison and sorting of GhostScript versions.\n\n#### Analysis of Parameters, Behavior, and Edge Cases\n- **Parameters**:\n  - `s`: A string that represents the version number of GhostScript. The format is expected to be in the form of \"major.minor.patch\", but can handle strings with fewer components (e.g., \"1.7\" or \"9\").\n\n- **Behavior**:\n  - The function attempts to split the input string `s` by the '.' character up to three times.\n  - It then converts each component into an integer and stores them in a list called `release`.\n  - If the number of components is less than three, zeros are appended to ensure that the resulting tuple has exactly three elements.\n  - Finally, the function returns this list as a tuple.\n\n- **Edge Cases**:\n  - If the input string cannot be converted to integers (due to non-numeric characters), a `ValueError` will occur. In such cases, the function catches the exception and returns `(0, 0, 0)`.\n\n#### Python Docstring\n```python\ndef ghostscript_version_key(s: str) -> tuple[int, int, int]:\n    \"\"\"\n    Parse a GhostScript version string and return it as a tuple of integers.\n    \n    Parameters:\n    s (str): A string representing the version number of GhostScript in the format \"major.minor.patch\".\n    \n    Returns:\n    tuple[int, int, int]: A tuple containing the major, minor, and patch versions as integers. If the input\n                          is invalid, returns (0, 0, 0).\n    \n    Raises:\n    ValueError: If the version string contains non-numeric characters.\n    \"\"\"\n    try:\n        release = [int(elem) for elem in s.split('.', maxsplit=3)]\n        while len(release) < 3:\n            release.append(0)\n        return tuple(release)\n    except ValueError:\n        return (0, 0, 0)\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "tests/test_main.py", "func_name": "test_invalid_input_pdf", "whole_func_string": "def test_invalid_input_pdf(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\n    assert result == ExitCode.input_file", "func_code_string": "def test_invalid_input_pdf(resources, no_outpdf):\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\n    assert result == ExitCode.input_file", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: tests/test_main.py\\nFunction/Class: test_invalid_input_pdf\\n```python\\ndef test_invalid_input_pdf(resources, no_outpdf):\\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\\n    assert result == ExitCode.input_file\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought\n\n1. **High-Level Purpose**: The function `test_invalid_input_pdf` is designed to test the behavior of the OCRMyPDF API when it encounters an invalid input PDF file.\n\n2. **Parameter Analysis**:\n   - `resources`: A path object pointing to a directory containing various resource files, including the invalid PDF.\n   - `no_outpdf`: An argument that might be used to specify whether the output PDF should be generated or not.\n\n3. **Behavior**:\n   - The function calls `run_ocrmypdf_api` with the path to an invalid PDF file.\n   - It asserts that the result of calling `run_ocrmypdf_api` is equal to `ExitCode.input_file`, which indicates that the input file was invalid and caused the API to fail.\n\n4. **Edge Cases**:\n   - The function does not handle edge cases related to different types of invalid input PDFs (e.g., corrupt files, non-PDF files).\n   - It assumes that `run_ocrmypdf_api` correctly identifies invalid input files and returns the appropriate exit code.\n\n### Python Docstring\n\n```python\ndef test_invalid_input_pdf(resources, no_outpdf):\n    \"\"\"\n    Test the OCRMyPDF API with an invalid input PDF file.\n\n    Parameters:\n    resources (Path): A path object pointing to a directory containing various resource files.\n    no_outpdf (bool or None): An argument that might be used to specify whether the output PDF should be generated or not.\n\n    Asserts:\n    - The result of calling `run_ocrmypdf_api` with an invalid input file is equal to `ExitCode.input_file`.\n    \"\"\"\n    result = run_ocrmypdf_api(resources / 'invalid.pdf', no_outpdf)\n    assert result == ExitCode.input_file\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/hocrtransform/_font.py", "func_name": "Courier", "whole_func_string": "class Courier(EncodableFont):\n                       \n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')\n\n    def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_code_string": "class Courier(EncodableFont):\n                       \n\n    def text_width(self, text: str, fontsize: float) -> float:\n                                                                                    \n        return len(text) * fontsize\n\n    def text_encode(self, text: str) -> bytes:\n        return text.encode('pdfdoc', errors='ignore')\n\n    def register(self, pdf: Pdf) -> Dictionary:\n                                \n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/hocrtransform/_font.py\\nFunction/Class: Courier\\n```python\\nclass Courier(EncodableFont):\\n                       \\n\\n    def text_width(self, text: str, fontsize: float) -> float:\\n                                                                                    \\n        return len(text) * fontsize\\n\\n    def text_encode(self, text: str) -> bytes:\\n        return text.encode('pdfdoc', errors='ignore')\\n\\n    def register(self, pdf: Pdf) -> Dictionary:\\n                                \\n        return pdf.make_indirect(\\n            Dictionary(\\n                BaseFont=Name.Courier,\\n                Type=Name.Font,\\n                Subtype=Name.Type1,\\n            )\\n        )\\n```\", \"assistant\": \"\"}", "response": "### Purpose-First Chain-of-Thought:\n\n**High-level purpose of the function/class:**\nThe `Courier` class is a subclass of `EncodableFont` designed to handle fonts of the Courier family in OCR (Optical Character Recognition) processing. It provides methods for calculating text width, encoding text into bytes suitable for PDF documents, and registering the font with a PDF document.\n\n**Analysis of parameters, behavior, and edge cases:**\n- **Parameters:**\n  - `text` (str): The input text for which operations are to be performed.\n  - `fontsize` (float): The size at which the text is being rendered.\n  \n- **Behavior:**\n  - `text_width`: Calculates the width of the provided text based on the specified font size. It multiplies the length of the text by the font size, assuming a monospaced font like Courier where each character has an equal width.\n  - `text_encode`: Encodes the input text into bytes using the 'pdfdoc' encoding scheme with error handling set to ignore any characters that cannot be encoded.\n  - `register`: Registers the font with a PDF document by creating a dictionary representing the font and making it indirect in the PDF document.\n\n- **Edge cases:**\n  - If `text` is an empty string, both `text_width` and `text_encode` will return `0` or an empty byte array respectively.\n  - Errors during encoding (e.g., if 'pdfdoc' encoding encounters characters not supported) are silently ignored by setting the error handling parameter to `'ignore'`.\n\n**Python docstring:**\n```python\nclass Courier(EncodableFont):\n    \"\"\"\n    Represents a Courier font in OCR processing. Provides methods for text width calculation, text encoding,\n    and registration with a PDF document.\n\n    Attributes:\n        None\n\n    Methods:\n        text_width(text: str, fontsize: float) -> float: Calculates the width of the provided text based on the specified font size.\n        text_encode(text: str) -> bytes: Encodes the input text into bytes using the 'pdfdoc' encoding scheme with error handling set to ignore any characters that cannot be encoded.\n        register(pdf: Pdf) -> Dictionary: Registers the font with a PDF document by creating a dictionary representing the font and making it indirect in the PDF document.\n    \"\"\"\n    \n    def text_width(self, text: str, fontsize: float) -> float:\n        \"\"\"\n        Calculates the width of the provided text based on the specified font size.\n\n        Parameters:\n            text (str): The input text for which the width is to be calculated.\n            fontsize (float): The size at which the text is being rendered.\n\n        Returns:\n            float: The calculated width of the text.\n        \"\"\"\n        return len(text) * fontsize\n\n    def text_encode(self, text: str) -> bytes:\n        \"\"\"\n        Encodes the input text into bytes using the 'pdfdoc' encoding scheme with error handling set to ignore any characters that cannot be encoded.\n\n        Parameters:\n            text (str): The input text to encode.\n\n        Returns:\n            bytes: The encoded text.\n        \"\"\"\n        return text.encode('pdfdoc', errors='ignore')\n\n    def register(self, pdf: Pdf) -> Dictionary:\n        \"\"\"\n        Registers the font with a PDF document by creating a dictionary representing the font and making it indirect in the PDF document.\n\n        Parameters:\n            pdf (Pdf): The PDF document to which the font is to be registered.\n\n        Returns:\n            Dictionary: A dictionary representing the registered font.\n        \"\"\"\n        return pdf.make_indirect(\n            Dictionary(\n                BaseFont=Name.Courier,\n                Type=Name.Font,\n                Subtype=Name.Type1,\n            )\n        )\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/imageops.py", "func_name": "_calculate_downsample", "whole_func_string": "def _calculate_downsample(\n    image_size: tuple[int, int],\n    bytes_per_pixel: int,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    size = image_size\n\n    if max_size is not None:\n        overage = max_size[0] / size[0], max_size[1] / size[1]\n        size_factor = min(overage)\n        if size_factor < 1.0:\n            log.debug(\"Resizing image to fit image dimensions limit\")\n            size = floor(size[0] * size_factor), floor(size[1] * size_factor)\n            if size[0] == 0:\n                size = 1, min(size[1], max_size[1])\n            elif size[1] == 0:\n                size = min(size[0], max_size[0]), 1\n\n    if max_pixels is not None:\n        if size[0] * size[1] > max_pixels:\n            log.debug(\"Resizing image to fit image pixel limit\")\n            pixels_factor = sqrt(max_pixels / (size[0] * size[1]))\n            size = floor(size[0] * pixels_factor), floor(size[1] * pixels_factor)\n\n    if max_bytes is not None:\n        bpp = bytes_per_pixel\n                                 \n        stride = size[0] * bpp\n        height = size[1]\n        if stride * height > max_bytes:\n            log.debug(\"Resizing image to fit image byte size limit\")\n            bytes_factor = sqrt(max_bytes / (stride * height))\n            scaled_stride = floor(stride * bytes_factor)\n            scaled_height = floor(height * bytes_factor)\n            if scaled_stride == 0:\n                scaled_stride = bpp\n                scaled_height = min(max_bytes // bpp, scaled_height)\n            if scaled_height == 0:\n                scaled_height = 1\n                scaled_stride = min(max_bytes // scaled_height, scaled_stride)\n            size = floor(scaled_stride / bpp), scaled_height\n\n    return size", "func_code_string": "def _calculate_downsample(\n    image_size: tuple[int, int],\n    bytes_per_pixel: int,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n           \n    size = image_size\n\n    if max_size is not None:\n        overage = max_size[0] / size[0], max_size[1] / size[1]\n        size_factor = min(overage)\n        if size_factor < 1.0:\n            log.debug(\"Resizing image to fit image dimensions limit\")\n            size = floor(size[0] * size_factor), floor(size[1] * size_factor)\n            if size[0] == 0:\n                size = 1, min(size[1], max_size[1])\n            elif size[1] == 0:\n                size = min(size[0], max_size[0]), 1\n\n    if max_pixels is not None:\n        if size[0] * size[1] > max_pixels:\n            log.debug(\"Resizing image to fit image pixel limit\")\n            pixels_factor = sqrt(max_pixels / (size[0] * size[1]))\n            size = floor(size[0] * pixels_factor), floor(size[1] * pixels_factor)\n\n    if max_bytes is not None:\n        bpp = bytes_per_pixel\n                                 \n        stride = size[0] * bpp\n        height = size[1]\n        if stride * height > max_bytes:\n            log.debug(\"Resizing image to fit image byte size limit\")\n            bytes_factor = sqrt(max_bytes / (stride * height))\n            scaled_stride = floor(stride * bytes_factor)\n            scaled_height = floor(height * bytes_factor)\n            if scaled_stride == 0:\n                scaled_stride = bpp\n                scaled_height = min(max_bytes // bpp, scaled_height)\n            if scaled_height == 0:\n                scaled_height = 1\n                scaled_stride = min(max_bytes // scaled_height, scaled_stride)\n            size = floor(scaled_stride / bpp), scaled_height\n\n    return size", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/imageops.py\\nFunction/Class: _calculate_downsample\\n```python\\ndef _calculate_downsample(\\n    image_size: tuple[int, int],\\n    bytes_per_pixel: int,\\n    *,\\n    max_size: tuple[int, int] | None = None,\\n    max_pixels: int | None = None,\\n    max_bytes: int | None = None,\\n) -> tuple[int, int]:\\n           \\n    size = image_size\\n\\n    if max_size is not None:\\n        overage = max_size[0] / size[0], max_size[1] / size[1]\\n        size_factor = min(overage)\\n        if size_factor < 1.0:\\n            log.debug(\\\"Resizing image to fit image dimensions limit\\\")\\n            size = floor(size[0] * size_factor), floor(size[1] * size_factor)\\n            if size[0] == 0:\\n                size = 1, min(size[1], max_size[1])\\n            elif size[1] == 0:\\n                size = min(size[0], max_size[0]), 1\\n\\n    if max_pixels is not None:\\n        if size[0] * size[1] > max_pixels:\\n            log.debug(\\\"Resizing image to fit image pixel limit\\\")\\n            pixels_factor = sqrt(max_pixels / (size[0] * size[1]))\\n            size = floor(size[0] * pixels_factor), floor(size[1] * pixels_factor)\\n\\n    if max_bytes is not None:\\n        bpp = bytes_per_pixel\\n                                 \\n        stride = size[0] * bpp\\n        height = size[1]\\n        if stride * height > max_bytes:\\n            log.debug(\\\"Resizing image to fit image byte size limit\\\")\\n            bytes_factor = sqrt(max_bytes / (stride * height))\\n            scaled_stride = floor(stride * bytes_factor)\\n            scaled_height = floor(height * bytes_factor)\\n            if scaled_stride == 0:\\n                scaled_stride = bpp\\n                scaled_height = min(max_bytes // bpp, scaled_height)\\n            if scaled_height == 0:\\n                scaled_height = 1\\n                scaled_stride = min(max_bytes // scaled_height, scaled_stride)\\n            size = floor(scaled_stride / bpp), scaled_height\\n\\n    return size\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `_calculate_downsample` function is designed to calculate the new dimensions of an image while adhering to specified maximum limits for size, pixels, or bytes. This ensures that the image does not exceed these constraints before processing.\n\n### Parameters\n\n- `image_size: tuple[int, int]`: The original dimensions of the image as a tuple (width, height).\n- `bytes_per_pixel: int`: The number of bytes per pixel in the image.\n- `max_size: tuple[int, int] | None = None`: An optional tuple representing the maximum allowable width and height for the image.\n- `max_pixels: int | None = None`: An optional integer representing the maximum allowable total number of pixels (width * height) for the image.\n- `max_bytes: int | None = None`: An optional integer representing the maximum allowable byte size for the image.\n\n### Behavior\n\nThe function calculates the new dimensions of the image by adjusting its width and height based on the provided constraints. It considers each constraint in order:\n1. **Max Size**: If a maximum size is specified, the function scales down the image if either dimension exceeds this limit.\n2. **Max Pixels**: If a maximum number of pixels is specified, the function scales down the image to ensure it does not exceed this pixel count.\n3. **Max Bytes**: If a maximum byte size is specified, the function scales down the image to ensure it does not exceed this byte size.\n\nThe function logs a debug message for each resizing operation that is performed. The new dimensions are returned as a tuple (width, height).\n\n### Edge Cases\n\n- If `max_size` is provided and either dimension of the image exceeds it, the image is scaled down.\n- If `max_pixels` is provided and the total number of pixels exceeds this limit, the image is scaled down.\n- If `max_bytes` is provided and the byte size exceeds this limit, the image is scaled down.\n- If scaling down an image results in a dimension that would be zero or less, the function ensures at least one pixel remains along each axis.\n\n### Docstring\n\n```python\ndef _calculate_downsample(\n    image_size: tuple[int, int],\n    bytes_per_pixel: int,\n    *,\n    max_size: tuple[int, int] | None = None,\n    max_pixels: int | None = None,\n    max_bytes: int | None = None,\n) -> tuple[int, int]:\n    \"\"\"\n    Calculate the new dimensions of an image while adhering to specified maximum limits for size, pixels, or bytes.\n\n    Parameters:\n    - image_size: The original dimensions of the image as a tuple (width, height).\n    - bytes_per_pixel: The number of bytes per pixel in the image.\n    - max_size: An optional tuple representing the maximum allowable width and height for the image.\n    - max_pixels: An optional integer representing the maximum allowable total number of pixels (width * height) for the image.\n    - max_bytes: An optional integer representing the maximum allowable byte size for the image.\n\n    Returns:\n    - A tuple containing the new dimensions of the image as a tuple (width, height).\n    \"\"\"\n```"}
{"repository_name": "OCRmyPDF-main", "func_path_in_repository": "src/ocrmypdf/builtin_plugins/tesseract_ocr.py", "func_name": "get_ocr_engine", "whole_func_string": "def get_ocr_engine():\n    return TesseractOcrEngine()", "func_code_string": "def get_ocr_engine():\n    return TesseractOcrEngine()", "func_documentation_string": "", "func_code_url": "", "language": "python", "split_name": "test", "func_code_tokens": [], "func_documentation_tokens": [], "llm_used": "qwen2.5-coder:7b", "prompt": "{\"system\": \"You are an expert Python code documentation assistant. Use Purpose-First Chain-of-Thought when generating documentation: 1. State the high-level purpose of the function or class. 2. Analyze its parameters, behavior, and edge cases. 3. Provide a concise Python docstring or summary.\", \"user\": \"File: src/ocrmypdf/builtin_plugins/tesseract_ocr.py\\nFunction/Class: get_ocr_engine\\n```python\\ndef get_ocr_engine():\\n    return TesseractOcrEngine()\\n```\", \"assistant\": \"\"}", "response": "### Purpose\n\nThe `get_ocr_engine` function is designed to provide a standardized interface for obtaining an instance of the OCR (Optical Character Recognition) engine, specifically using the Tesseract OCR engine. This function simplifies the process of creating and managing OCR engines by encapsulating the instantiation logic within a single point.\n\n### Parameters\n\n- **No parameters**.\n\n### Behavior\n\nThe function does not take any input parameters. It simply returns an instance of the `TesseractOcrEngine` class, which is assumed to be defined elsewhere in the codebase.\n\n### Edge Cases\n\n1. **Class Definition**: If the `TesseractOcrEngine` class has not been defined anywhere within the project or imported from another module, attempting to create an instance of it will raise a `NameError`.\n2. **Initialization Errors**: If the `TesseractOcrEngine` class constructor (`__init__`) raises an exception (e.g., due to missing dependencies), this exception will be propagated back up to the caller of `get_ocr_engine`.\n\n### Python Docstring\n\n```python\ndef get_ocr_engine():\n    \"\"\"\n    Returns a pre-configured instance of the Tesseract OCR engine.\n\n    :return: An instance of TesseractOcrEngine.\n    :rtype: TesseractOcrEngine\n    \"\"\"\n```"}
